/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.0.0 (NJsonSchema v10.1.24.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class ActivityFormDataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllActivityForms(sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ActivityFormListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityFormData/GetAllActivityForms?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActivityForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActivityForms(<any>response_);
                } catch (e) {
                    return <Observable<ActivityFormListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityFormListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllActivityForms(response: HttpResponseBase): Observable<ActivityFormListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityFormListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityFormListDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllActivityFormsWithoutParams(): Observable<ActivityFormListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ActivityFormData/GetAllActivityFormsWithoutParams";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActivityFormsWithoutParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActivityFormsWithoutParams(<any>response_);
                } catch (e) {
                    return <Observable<ActivityFormListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityFormListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllActivityFormsWithoutParams(response: HttpResponseBase): Observable<ActivityFormListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ActivityFormListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityFormListDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getActivityForm(id: number | undefined): Observable<ActivityFormDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityFormData/GetActivityForm?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityForm(<any>response_);
                } catch (e) {
                    return <Observable<ActivityFormDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityFormDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityForm(response: HttpResponseBase): Observable<ActivityFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityFormDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getActivityFormForEdit(id: number | null | undefined): Observable<GetActivityFormEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ActivityFormData/GetActivityFormForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityFormForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityFormForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetActivityFormEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetActivityFormEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivityFormForEdit(response: HttpResponseBase): Observable<GetActivityFormEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetActivityFormEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetActivityFormEditOutput>(<any>null);
    }

    /**
     * @param prefixText (optional) 
     * @return Success
     */
    getUsersFromEMS(prefixText: string | null | undefined): Observable<UsersResultOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/ActivityFormData/GetUsersFromEMS?";
        if (prefixText !== undefined && prefixText !== null)
            url_ += "prefixText=" + encodeURIComponent("" + prefixText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersFromEMS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersFromEMS(<any>response_);
                } catch (e) {
                    return <Observable<UsersResultOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UsersResultOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersFromEMS(response: HttpResponseBase): Observable<UsersResultOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UsersResultOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UsersResultOutput[]>(<any>null);
    }

    /**
     * @return Success
     */
    getBUFromEMS(): Observable<BUResultOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/ActivityFormData/GetBUFromEMS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBUFromEMS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBUFromEMS(<any>response_);
                } catch (e) {
                    return <Observable<BUResultOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BUResultOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBUFromEMS(response: HttpResponseBase): Observable<BUResultOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BUResultOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BUResultOutput[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateActivityForm(body: CreateOrUpdateActivityFormDto | undefined): Observable<NewActivitiesDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityFormData/CreateOrUpdateActivityForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateActivityForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateActivityForm(<any>response_);
                } catch (e) {
                    return <Observable<NewActivitiesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NewActivitiesDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateActivityForm(response: HttpResponseBase): Observable<NewActivitiesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewActivitiesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NewActivitiesDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteActivityForm(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityFormData/DeleteActivityForm?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteActivityForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteActivityForm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteActivityForm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getActivitiesForForm(id: number | undefined): Observable<ActivityDetailsForForm> {
        let url_ = this.baseUrl + "/api/services/app/ActivityFormData/GetActivitiesForForm?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivitiesForForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivitiesForForm(<any>response_);
                } catch (e) {
                    return <Observable<ActivityDetailsForForm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityDetailsForForm>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivitiesForForm(response: HttpResponseBase): Observable<ActivityDetailsForForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityDetailsForForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDetailsForForm>(<any>null);
    }

    /**
     * @param meetingIds (optional) 
     * @return Success
     */
    getMeetingsForForm(meetingIds: number | undefined): Observable<MeetingDetailsForForm> {
        let url_ = this.baseUrl + "/api/services/app/ActivityFormData/GetMeetingsForForm?";
        if (meetingIds === null)
            throw new Error("The parameter 'meetingIds' cannot be null.");
        else if (meetingIds !== undefined)
            url_ += "MeetingIds=" + encodeURIComponent("" + meetingIds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMeetingsForForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMeetingsForForm(<any>response_);
                } catch (e) {
                    return <Observable<MeetingDetailsForForm>><any>_observableThrow(e);
                }
            } else
                return <Observable<MeetingDetailsForForm>><any>_observableThrow(response_);
        }));
    }

    protected processGetMeetingsForForm(response: HttpResponseBase): Observable<MeetingDetailsForForm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MeetingDetailsForForm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MeetingDetailsForForm>(<any>null);
    }
}

@Injectable()
export class BusinessRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<BusinessRoleDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BusinessRole/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<BusinessRoleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessRoleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BusinessRoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BusinessRoleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessRoleDto[]>(<any>null);
    }

    /**
     * @param prefixText (optional) 
     * @return Success
     */
    getAllBusinessRolesByPrefixText(prefixText: string | null | undefined): Observable<BusinessRoleDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BusinessRole/GetAllBusinessRolesByPrefixText?";
        if (prefixText !== undefined && prefixText !== null)
            url_ += "prefixText=" + encodeURIComponent("" + prefixText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessRolesByPrefixText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessRolesByPrefixText(<any>response_);
                } catch (e) {
                    return <Observable<BusinessRoleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessRoleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBusinessRolesByPrefixText(response: HttpResponseBase): Observable<BusinessRoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BusinessRoleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessRoleDto[]>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllBusinessRoles(sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<BusinessRoleListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessRole/GetAllBusinessRoles?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessRoles(<any>response_);
                } catch (e) {
                    return <Observable<BusinessRoleListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessRoleListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBusinessRoles(response: HttpResponseBase): Observable<BusinessRoleListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessRoleListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessRoleListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessRole(id: number | undefined): Observable<BusinessRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessRole/GetBusinessRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessRole(<any>response_);
                } catch (e) {
                    return <Observable<BusinessRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessRole(response: HttpResponseBase): Observable<BusinessRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessRoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessRoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessRoleForEdit(id: number | null | undefined): Observable<GetBusinessRoleEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusinessRole/GetBusinessRoleForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBusinessRoleEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBusinessRoleEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessRoleForEdit(response: HttpResponseBase): Observable<GetBusinessRoleEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessRoleEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBusinessRoleEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateBusinessRole(body: CreateOrUpdateBusinessRoleDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessRole/CreateOrUpdateBusinessRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateBusinessRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateBusinessRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateBusinessRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteBusinessRole(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessRole/DeleteBusinessRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBusinessRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBusinessRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBusinessRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BusinessUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllBusinessUnits(sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<BusinessUnitListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetAllBusinessUnits?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessUnits(<any>response_);
                } catch (e) {
                    return <Observable<BusinessUnitListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessUnitListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBusinessUnits(response: HttpResponseBase): Observable<BusinessUnitListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessUnitListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessUnitListDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getBusinessUnitlist(): Observable<BusinessUnitListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetBusinessUnitlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessUnitlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessUnitlist(<any>response_);
                } catch (e) {
                    return <Observable<BusinessUnitListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessUnitListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessUnitlist(response: HttpResponseBase): Observable<BusinessUnitListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BusinessUnitListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessUnitListDto[]>(<any>null);
    }

    /**
     * @param businessUnitsIds (optional) 
     * @return Success
     */
    getBusinessUnitlistDto(businessUnitsIds: number[] | null | undefined): Observable<BusinessUnitListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetBusinessUnitlistDto?";
        if (businessUnitsIds !== undefined && businessUnitsIds !== null)
            businessUnitsIds && businessUnitsIds.forEach(item => { url_ += "BusinessUnitsIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessUnitlistDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessUnitlistDto(<any>response_);
                } catch (e) {
                    return <Observable<BusinessUnitListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessUnitListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessUnitlistDto(response: HttpResponseBase): Observable<BusinessUnitListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BusinessUnitListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessUnitListDto[]>(<any>null);
    }

    /**
     * @param prefixText (optional) 
     * @return Success
     */
    getAllBusinessUnitsByPrefixText(prefixText: string | null | undefined): Observable<BusinessUnitDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetAllBusinessUnitsByPrefixText?";
        if (prefixText !== undefined && prefixText !== null)
            url_ += "prefixText=" + encodeURIComponent("" + prefixText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessUnitsByPrefixText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessUnitsByPrefixText(<any>response_);
                } catch (e) {
                    return <Observable<BusinessUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBusinessUnitsByPrefixText(response: HttpResponseBase): Observable<BusinessUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BusinessUnitDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessUnitDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessUnit(id: number | undefined): Observable<BusinessUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetBusinessUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessUnit(<any>response_);
                } catch (e) {
                    return <Observable<BusinessUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessUnit(response: HttpResponseBase): Observable<BusinessUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessUnitForEdit(id: number | null | undefined): Observable<GetBusinessUnitEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/GetBusinessUnitForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessUnitForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessUnitForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBusinessUnitEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBusinessUnitEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessUnitForEdit(response: HttpResponseBase): Observable<GetBusinessUnitEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessUnitEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBusinessUnitEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateBusinessUnit(body: CreateOrUpdateBusinessUnitDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/CreateOrUpdateBusinessUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateBusinessUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateBusinessUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateBusinessUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteBusinessUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUnit/DeleteBusinessUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBusinessUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBusinessUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBusinessUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CubeQueryMappingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllCubeQueryMappings(sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<CubeQueryMappingListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CubeQueryMapping/GetAllCubeQueryMappings?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCubeQueryMappings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCubeQueryMappings(<any>response_);
                } catch (e) {
                    return <Observable<CubeQueryMappingListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubeQueryMappingListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCubeQueryMappings(response: HttpResponseBase): Observable<CubeQueryMappingListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubeQueryMappingListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubeQueryMappingListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCubeQueryMapping(id: number | undefined): Observable<CubeQueryMappingDto> {
        let url_ = this.baseUrl + "/api/services/app/CubeQueryMapping/GetCubeQueryMapping?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubeQueryMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubeQueryMapping(<any>response_);
                } catch (e) {
                    return <Observable<CubeQueryMappingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubeQueryMappingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubeQueryMapping(response: HttpResponseBase): Observable<CubeQueryMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CubeQueryMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubeQueryMappingDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCubeQueryMappingForEdit(id: number | null | undefined): Observable<GetCubeQueryMappingEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CubeQueryMapping/GetCubeQueryMappingForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCubeQueryMappingForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCubeQueryMappingForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCubeQueryMappingEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCubeQueryMappingEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCubeQueryMappingForEdit(response: HttpResponseBase): Observable<GetCubeQueryMappingEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCubeQueryMappingEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCubeQueryMappingEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateCubeQueryMapping(body: CreateOrUpdateCubeQueryMappingDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CubeQueryMapping/CreateOrUpdateCubeQueryMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateCubeQueryMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateCubeQueryMapping(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateCubeQueryMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCubeQueryMapping(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CubeQueryMapping/DeleteCubeQueryMapping?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCubeQueryMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCubeQueryMapping(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCubeQueryMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @return Success
     */
    getFormViewStructureFromCube(formId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CubeQueryMapping/GetFormViewStructureFromCube?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormViewStructureFromCube(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormViewStructureFromCube(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormViewStructureFromCube(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ExportFormToExcelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param formId (optional) 
     * @param businessUnitId (optional) 
     * @param weeks (optional) 
     * @param month (optional) 
     * @param year (optional) 
     * @return Success
     */
    getExportFormExcelFile(formId: number | undefined, businessUnitId: number | undefined, weeks: number[] | null | undefined, month: number | undefined, year: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ExportFormToExcel/GetExportFormExcelFile?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "BusinessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (weeks !== undefined && weeks !== null)
            weeks && weeks.forEach(item => { url_ += "Weeks=" + encodeURIComponent("" + item) + "&"; });
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportFormExcelFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportFormExcelFile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetExportFormExcelFile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @param businessUnitId (optional) 
     * @param formTypeId (optional) 
     * @param businessRoleId (optional) 
     * @param monthId (optional) 
     * @param weekId (optional) 
     * @return Success
     */
    getActivitySheet(formId: number | undefined, businessUnitId: number | undefined, formTypeId: number | undefined, businessRoleId: number | undefined, monthId: number | undefined, weekId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ExportFormToExcel/GetActivitySheet?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "BusinessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (formTypeId === null)
            throw new Error("The parameter 'formTypeId' cannot be null.");
        else if (formTypeId !== undefined)
            url_ += "FormTypeId=" + encodeURIComponent("" + formTypeId) + "&";
        if (businessRoleId === null)
            throw new Error("The parameter 'businessRoleId' cannot be null.");
        else if (businessRoleId !== undefined)
            url_ += "BusinessRoleId=" + encodeURIComponent("" + businessRoleId) + "&";
        if (monthId === null)
            throw new Error("The parameter 'monthId' cannot be null.");
        else if (monthId !== undefined)
            url_ += "MonthId=" + encodeURIComponent("" + monthId) + "&";
        if (weekId === null)
            throw new Error("The parameter 'weekId' cannot be null.");
        else if (weekId !== undefined)
            url_ += "WeekId=" + encodeURIComponent("" + weekId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivitySheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivitySheet(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivitySheet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @param businessUnitId (optional) 
     * @param formTypeId (optional) 
     * @param businessRoleId (optional) 
     * @param monthId (optional) 
     * @param weekId (optional) 
     * @return Success
     */
    getMeetingSheet(formId: number | undefined, businessUnitId: number | undefined, formTypeId: number | undefined, businessRoleId: number | undefined, monthId: number | undefined, weekId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ExportFormToExcel/GetMeetingSheet?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "BusinessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (formTypeId === null)
            throw new Error("The parameter 'formTypeId' cannot be null.");
        else if (formTypeId !== undefined)
            url_ += "FormTypeId=" + encodeURIComponent("" + formTypeId) + "&";
        if (businessRoleId === null)
            throw new Error("The parameter 'businessRoleId' cannot be null.");
        else if (businessRoleId !== undefined)
            url_ += "BusinessRoleId=" + encodeURIComponent("" + businessRoleId) + "&";
        if (monthId === null)
            throw new Error("The parameter 'monthId' cannot be null.");
        else if (monthId !== undefined)
            url_ += "MonthId=" + encodeURIComponent("" + monthId) + "&";
        if (weekId === null)
            throw new Error("The parameter 'weekId' cannot be null.");
        else if (weekId !== undefined)
            url_ += "WeekId=" + encodeURIComponent("" + weekId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMeetingSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMeetingSheet(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetMeetingSheet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class FormServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllForms(userId: number): Observable<FormListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Form/GetAllForms?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForms(<any>response_);
                } catch (e) {
                    return <Observable<FormListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllForms(response: HttpResponseBase): Observable<FormListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormListDto[]>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @param statusId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllFormsList(roleId: number | null | undefined, statusId: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FormRoleListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Form/GetAllFormsList?";
        if (roleId !== undefined && roleId !== null)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (statusId !== undefined && statusId !== null)
            url_ += "StatusId=" + encodeURIComponent("" + statusId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFormsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFormsList(<any>response_);
                } catch (e) {
                    return <Observable<FormRoleListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormRoleListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFormsList(response: HttpResponseBase): Observable<FormRoleListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormRoleListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormRoleListDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllFormsWithoutUser(): Observable<FormListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Form/GetAllFormsWithoutUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFormsWithoutUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFormsWithoutUser(<any>response_);
                } catch (e) {
                    return <Observable<FormListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFormsWithoutUser(response: HttpResponseBase): Observable<FormListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormListDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForm(id: number | undefined): Observable<FormDto> {
        let url_ = this.baseUrl + "/api/services/app/Form/GetForm?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForm(<any>response_);
                } catch (e) {
                    return <Observable<FormDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForm(response: HttpResponseBase): Observable<FormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getFormForEdit(id: number | null | undefined): Observable<GetFormEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Form/GetFormForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetFormEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFormEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormForEdit(response: HttpResponseBase): Observable<GetFormEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFormEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFormEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createForm(body: CreateFormDto | undefined): Observable<FormRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Form/CreateForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForm(<any>response_);
                } catch (e) {
                    return <Observable<FormRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateForm(response: HttpResponseBase): Observable<FormRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormRoleListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateForm(body: UpdateFormDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Form/UpdateForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForm(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateForm(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFormStatus(body: UpdateFormStatusDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Form/UpdateFormStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFormStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFormStatus(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateFormStatus(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteForm(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Form/DeleteForm?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteForm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param formSearchQuery (optional) 
     * @return Success
     */
    getAllFormsByName(formSearchQuery: string | null | undefined): Observable<FormListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Form/GetAllFormsByName?";
        if (formSearchQuery !== undefined && formSearchQuery !== null)
            url_ += "FormSearchQuery=" + encodeURIComponent("" + formSearchQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFormsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFormsByName(<any>response_);
                } catch (e) {
                    return <Observable<FormListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFormsByName(response: HttpResponseBase): Observable<FormListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormListDto[]>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @param businessUnitId (optional) 
     * @param weeks (optional) 
     * @param month (optional) 
     * @param year (optional) 
     * @return Success
     */
    getCompressedFormStructureAndData(formId: number | undefined, businessUnitId: number | undefined, weeks: number[] | null | undefined, month: number | undefined, year: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Form/GetCompressedFormStructureAndData?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "BusinessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (weeks !== undefined && weeks !== null)
            weeks && weeks.forEach(item => { url_ += "Weeks=" + encodeURIComponent("" + item) + "&"; });
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompressedFormStructureAndData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompressedFormStructureAndData(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompressedFormStructureAndData(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @param businessUnitId (optional) 
     * @param weeks (optional) 
     * @param month (optional) 
     * @param year (optional) 
     * @return Success
     */
    getFormStructureAndData(formId: number | undefined, businessUnitId: number | undefined, weeks: number[] | null | undefined, month: number | undefined, year: number | undefined): Observable<FormStructureDataDto> {
        let url_ = this.baseUrl + "/api/services/app/Form/GetFormStructureAndData?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "BusinessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (weeks !== undefined && weeks !== null)
            weeks && weeks.forEach(item => { url_ += "Weeks=" + encodeURIComponent("" + item) + "&"; });
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormStructureAndData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormStructureAndData(<any>response_);
                } catch (e) {
                    return <Observable<FormStructureDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructureDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormStructureAndData(response: HttpResponseBase): Observable<FormStructureDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormStructureDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructureDataDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCellsValues(body: FormStructerDataCellDto[] | null | undefined): Observable<FormStructerDataCellDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Form/UpdateCellsValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCellsValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCellsValues(<any>response_);
                } catch (e) {
                    return <Observable<FormStructerDataCellDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructerDataCellDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCellsValues(response: HttpResponseBase): Observable<FormStructerDataCellDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormStructerDataCellDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructerDataCellDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPublishedForms(): Observable<FormListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Form/GetPublishedForms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPublishedForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPublishedForms(<any>response_);
                } catch (e) {
                    return <Observable<FormListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPublishedForms(response: HttpResponseBase): Observable<FormListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormListDto[]>(<any>null);
    }
}

@Injectable()
export class FormBusinessUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllBusinessUnitsByForm(formId: number): Observable<BusinessFormListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormBusinessUnit/GetAllBusinessUnitsByForm?";
        if (formId === undefined || formId === null)
            throw new Error("The parameter 'formId' must be defined and cannot be null.");
        else
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessUnitsByForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessUnitsByForm(<any>response_);
                } catch (e) {
                    return <Observable<BusinessFormListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessFormListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBusinessUnitsByForm(response: HttpResponseBase): Observable<BusinessFormListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BusinessFormListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessFormListDto[]>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getAllBusinessUnitsAssigneToUserByForm(formId: number | undefined, userId: number | undefined): Observable<BusinessFormListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormBusinessUnit/GetAllBusinessUnitsAssigneToUserByForm?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessUnitsAssigneToUserByForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessUnitsAssigneToUserByForm(<any>response_);
                } catch (e) {
                    return <Observable<BusinessFormListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessFormListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBusinessUnitsAssigneToUserByForm(response: HttpResponseBase): Observable<BusinessFormListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BusinessFormListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessFormListDto[]>(<any>null);
    }

    /**
     * @param businessUnitId (optional) 
     * @param formId (optional) 
     * @param id (optional) 
     * @return Success
     */
    getBusinessForm(businessUnitId: number | undefined, formId: number | undefined, id: number | undefined): Observable<BusinessFormDto> {
        let url_ = this.baseUrl + "/api/services/app/FormBusinessUnit/GetBusinessForm?";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "BusinessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessForm(<any>response_);
                } catch (e) {
                    return <Observable<BusinessFormDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessFormDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessForm(response: HttpResponseBase): Observable<BusinessFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessFormDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param businessUnitId (optional) 
     * @param formId (optional) 
     * @return Success
     */
    getBusinessFormForEdit(id: number | null | undefined, businessUnitId: number | undefined, formId: number | undefined): Observable<GetBusinessFormEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/FormBusinessUnit/GetBusinessFormForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "BusinessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessFormForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessFormForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBusinessFormEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBusinessFormEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessFormForEdit(response: HttpResponseBase): Observable<GetBusinessFormEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessFormEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBusinessFormEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateBusinessForm(body: CreateOrUpdateBusinessFormDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FormBusinessUnit/CreateOrUpdateBusinessForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateBusinessForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateBusinessForm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateBusinessForm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param businessUnitId (optional) 
     * @param formId (optional) 
     * @param businessUnit_ShortTitle (optional) 
     * @param businessUnit_TBL_FormBusinessUnits (optional) 
     * @param businessUnit_TBL_Structure (optional) 
     * @param businessUnit_IsDeleted (optional) 
     * @param businessUnit_DeleterUserId (optional) 
     * @param businessUnit_DeletionTime (optional) 
     * @param businessUnit_LastModificationTime (optional) 
     * @param businessUnit_LastModifierUserId (optional) 
     * @param businessUnit_CreationTime (optional) 
     * @param businessUnit_CreatorUserId (optional) 
     * @param businessUnit_Id (optional) 
     * @param form_Code (optional) 
     * @param form_IsActive (optional) 
     * @param form_IsPublished (optional) 
     * @param form_PublishDate (optional) 
     * @param form_PeriodTypeId (optional) 
     * @param form_DisplayType (optional) 
     * @param form_StatusId (optional) 
     * @param form_BusinessRoleId (optional) 
     * @param form_BusinessRole_TBL_Forms (optional) 
     * @param form_BusinessRole_IsDeleted (optional) 
     * @param form_BusinessRole_DeleterUserId (optional) 
     * @param form_BusinessRole_DeletionTime (optional) 
     * @param form_BusinessRole_LastModificationTime (optional) 
     * @param form_BusinessRole_LastModifierUserId (optional) 
     * @param form_BusinessRole_CreationTime (optional) 
     * @param form_BusinessRole_CreatorUserId (optional) 
     * @param form_BusinessRole_Id (optional) 
     * @param form_Status_TBL_Forms (optional) 
     * @param form_Status_IsDeleted (optional) 
     * @param form_Status_DeleterUserId (optional) 
     * @param form_Status_DeletionTime (optional) 
     * @param form_Status_LastModificationTime (optional) 
     * @param form_Status_LastModifierUserId (optional) 
     * @param form_Status_CreationTime (optional) 
     * @param form_Status_CreatorUserId (optional) 
     * @param form_Status_Id (optional) 
     * @param form_PeriodType_TBL_Forms (optional) 
     * @param form_PeriodType_IsDeleted (optional) 
     * @param form_PeriodType_DeleterUserId (optional) 
     * @param form_PeriodType_DeletionTime (optional) 
     * @param form_PeriodType_LastModificationTime (optional) 
     * @param form_PeriodType_LastModifierUserId (optional) 
     * @param form_PeriodType_CreationTime (optional) 
     * @param form_PeriodType_CreatorUserId (optional) 
     * @param form_PeriodType_Id (optional) 
     * @param form_TBL_FormBusinessUnits (optional) 
     * @param form_TBL_FormStructureRows (optional) 
     * @param form_TBL_PivotQueries (optional) 
     * @param form_FormName (optional) 
     * @param form_IsDeleted (optional) 
     * @param form_DeleterUserId (optional) 
     * @param form_DeletionTime (optional) 
     * @param form_LastModificationTime (optional) 
     * @param form_LastModifierUserId (optional) 
     * @param form_CreationTime (optional) 
     * @param form_CreatorUserId (optional) 
     * @param form_Id (optional) 
     * @param tBL_UserForms (optional) 
     * @param isDeleted (optional) 
     * @param deleterUserId (optional) 
     * @param deletionTime (optional) 
     * @param lastModificationTime (optional) 
     * @param lastModifierUserId (optional) 
     * @param creationTime (optional) 
     * @param creatorUserId (optional) 
     * @param id (optional) 
     * @return Success
     */
    deleteBusinessForm(businessUnitId: number | undefined, formId: number | undefined, businessUnit_Title: string, businessUnit_ShortTitle: string | null | undefined, businessUnit_TBL_FormBusinessUnits: TBL_FormBusinessUnit[] | null | undefined, businessUnit_TBL_Structure: TBL_Structure[] | null | undefined, businessUnit_IsDeleted: boolean | undefined, businessUnit_DeleterUserId: number | null | undefined, businessUnit_DeletionTime: moment.Moment | null | undefined, businessUnit_LastModificationTime: moment.Moment | null | undefined, businessUnit_LastModifierUserId: number | null | undefined, businessUnit_CreationTime: moment.Moment | undefined, businessUnit_CreatorUserId: number | null | undefined, businessUnit_Id: number | undefined, form_Code: string | null | undefined, form_IsActive: boolean | undefined, form_IsPublished: boolean | undefined, form_PublishDate: moment.Moment | null | undefined, form_PeriodTypeId: number | undefined, form_DisplayType: FormDisplayType | undefined, form_StatusId: number | undefined, form_BusinessRoleId: number | undefined, form_BusinessRole_Title: string, form_BusinessRole_TBL_Forms: TBL_Form[] | null | undefined, form_BusinessRole_IsDeleted: boolean | undefined, form_BusinessRole_DeleterUserId: number | null | undefined, form_BusinessRole_DeletionTime: moment.Moment | null | undefined, form_BusinessRole_LastModificationTime: moment.Moment | null | undefined, form_BusinessRole_LastModifierUserId: number | null | undefined, form_BusinessRole_CreationTime: moment.Moment | undefined, form_BusinessRole_CreatorUserId: number | null | undefined, form_BusinessRole_Id: number | undefined, form_Status_Status: string, form_Status_TBL_Forms: TBL_Form[] | null | undefined, form_Status_IsDeleted: boolean | undefined, form_Status_DeleterUserId: number | null | undefined, form_Status_DeletionTime: moment.Moment | null | undefined, form_Status_LastModificationTime: moment.Moment | null | undefined, form_Status_LastModifierUserId: number | null | undefined, form_Status_CreationTime: moment.Moment | undefined, form_Status_CreatorUserId: number | null | undefined, form_Status_Id: number | undefined, form_PeriodType_Title: string, form_PeriodType_TBL_Forms: TBL_Form[] | null | undefined, form_PeriodType_IsDeleted: boolean | undefined, form_PeriodType_DeleterUserId: number | null | undefined, form_PeriodType_DeletionTime: moment.Moment | null | undefined, form_PeriodType_LastModificationTime: moment.Moment | null | undefined, form_PeriodType_LastModifierUserId: number | null | undefined, form_PeriodType_CreationTime: moment.Moment | undefined, form_PeriodType_CreatorUserId: number | null | undefined, form_PeriodType_Id: number | undefined, form_TBL_FormBusinessUnits: TBL_FormBusinessUnit[] | null | undefined, form_TBL_FormStructureRows: TBL_FormStructureRow[] | null | undefined, form_TBL_PivotQueries: TBL_PivotQuery[] | null | undefined, form_FormName: string | null | undefined, form_IsDeleted: boolean | undefined, form_DeleterUserId: number | null | undefined, form_DeletionTime: moment.Moment | null | undefined, form_LastModificationTime: moment.Moment | null | undefined, form_LastModifierUserId: number | null | undefined, form_CreationTime: moment.Moment | undefined, form_CreatorUserId: number | null | undefined, form_Id: number | undefined, tBL_UserForms: TBL_UserForm[] | null | undefined, isDeleted: boolean | undefined, deleterUserId: number | null | undefined, deletionTime: moment.Moment | null | undefined, lastModificationTime: moment.Moment | null | undefined, lastModifierUserId: number | null | undefined, creationTime: moment.Moment | undefined, creatorUserId: number | null | undefined, id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FormBusinessUnit/DeleteBusinessForm?";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "BusinessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (businessUnit_Title === undefined || businessUnit_Title === null)
            throw new Error("The parameter 'businessUnit_Title' must be defined and cannot be null.");
        else
            url_ += "BusinessUnit.Title=" + encodeURIComponent("" + businessUnit_Title) + "&";
        if (businessUnit_ShortTitle !== undefined && businessUnit_ShortTitle !== null)
            url_ += "BusinessUnit.ShortTitle=" + encodeURIComponent("" + businessUnit_ShortTitle) + "&";
        if (businessUnit_TBL_FormBusinessUnits !== undefined && businessUnit_TBL_FormBusinessUnits !== null)
            businessUnit_TBL_FormBusinessUnits && businessUnit_TBL_FormBusinessUnits.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "BusinessUnit.TBL_FormBusinessUnits[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (businessUnit_TBL_Structure !== undefined && businessUnit_TBL_Structure !== null)
            businessUnit_TBL_Structure && businessUnit_TBL_Structure.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "BusinessUnit.TBL_Structure[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (businessUnit_IsDeleted === null)
            throw new Error("The parameter 'businessUnit_IsDeleted' cannot be null.");
        else if (businessUnit_IsDeleted !== undefined)
            url_ += "BusinessUnit.IsDeleted=" + encodeURIComponent("" + businessUnit_IsDeleted) + "&";
        if (businessUnit_DeleterUserId !== undefined && businessUnit_DeleterUserId !== null)
            url_ += "BusinessUnit.DeleterUserId=" + encodeURIComponent("" + businessUnit_DeleterUserId) + "&";
        if (businessUnit_DeletionTime !== undefined && businessUnit_DeletionTime !== null)
            url_ += "BusinessUnit.DeletionTime=" + encodeURIComponent(businessUnit_DeletionTime ? "" + businessUnit_DeletionTime.toJSON() : "") + "&";
        if (businessUnit_LastModificationTime !== undefined && businessUnit_LastModificationTime !== null)
            url_ += "BusinessUnit.LastModificationTime=" + encodeURIComponent(businessUnit_LastModificationTime ? "" + businessUnit_LastModificationTime.toJSON() : "") + "&";
        if (businessUnit_LastModifierUserId !== undefined && businessUnit_LastModifierUserId !== null)
            url_ += "BusinessUnit.LastModifierUserId=" + encodeURIComponent("" + businessUnit_LastModifierUserId) + "&";
        if (businessUnit_CreationTime === null)
            throw new Error("The parameter 'businessUnit_CreationTime' cannot be null.");
        else if (businessUnit_CreationTime !== undefined)
            url_ += "BusinessUnit.CreationTime=" + encodeURIComponent(businessUnit_CreationTime ? "" + businessUnit_CreationTime.toJSON() : "") + "&";
        if (businessUnit_CreatorUserId !== undefined && businessUnit_CreatorUserId !== null)
            url_ += "BusinessUnit.CreatorUserId=" + encodeURIComponent("" + businessUnit_CreatorUserId) + "&";
        if (businessUnit_Id === null)
            throw new Error("The parameter 'businessUnit_Id' cannot be null.");
        else if (businessUnit_Id !== undefined)
            url_ += "BusinessUnit.Id=" + encodeURIComponent("" + businessUnit_Id) + "&";
        if (form_Code !== undefined && form_Code !== null)
            url_ += "Form.Code=" + encodeURIComponent("" + form_Code) + "&";
        if (form_IsActive === null)
            throw new Error("The parameter 'form_IsActive' cannot be null.");
        else if (form_IsActive !== undefined)
            url_ += "Form.IsActive=" + encodeURIComponent("" + form_IsActive) + "&";
        if (form_IsPublished === null)
            throw new Error("The parameter 'form_IsPublished' cannot be null.");
        else if (form_IsPublished !== undefined)
            url_ += "Form.IsPublished=" + encodeURIComponent("" + form_IsPublished) + "&";
        if (form_PublishDate !== undefined && form_PublishDate !== null)
            url_ += "Form.PublishDate=" + encodeURIComponent(form_PublishDate ? "" + form_PublishDate.toJSON() : "") + "&";
        if (form_PeriodTypeId === null)
            throw new Error("The parameter 'form_PeriodTypeId' cannot be null.");
        else if (form_PeriodTypeId !== undefined)
            url_ += "Form.PeriodTypeId=" + encodeURIComponent("" + form_PeriodTypeId) + "&";
        if (form_DisplayType === null)
            throw new Error("The parameter 'form_DisplayType' cannot be null.");
        else if (form_DisplayType !== undefined)
            url_ += "Form.DisplayType=" + encodeURIComponent("" + form_DisplayType) + "&";
        if (form_StatusId === null)
            throw new Error("The parameter 'form_StatusId' cannot be null.");
        else if (form_StatusId !== undefined)
            url_ += "Form.StatusId=" + encodeURIComponent("" + form_StatusId) + "&";
        if (form_BusinessRoleId === null)
            throw new Error("The parameter 'form_BusinessRoleId' cannot be null.");
        else if (form_BusinessRoleId !== undefined)
            url_ += "Form.BusinessRoleId=" + encodeURIComponent("" + form_BusinessRoleId) + "&";
        if (form_BusinessRole_Title === undefined || form_BusinessRole_Title === null)
            throw new Error("The parameter 'form_BusinessRole_Title' must be defined and cannot be null.");
        else
            url_ += "Form.BusinessRole.Title=" + encodeURIComponent("" + form_BusinessRole_Title) + "&";
        if (form_BusinessRole_TBL_Forms !== undefined && form_BusinessRole_TBL_Forms !== null)
            form_BusinessRole_TBL_Forms && form_BusinessRole_TBL_Forms.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Form.BusinessRole.TBL_Forms[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (form_BusinessRole_IsDeleted === null)
            throw new Error("The parameter 'form_BusinessRole_IsDeleted' cannot be null.");
        else if (form_BusinessRole_IsDeleted !== undefined)
            url_ += "Form.BusinessRole.IsDeleted=" + encodeURIComponent("" + form_BusinessRole_IsDeleted) + "&";
        if (form_BusinessRole_DeleterUserId !== undefined && form_BusinessRole_DeleterUserId !== null)
            url_ += "Form.BusinessRole.DeleterUserId=" + encodeURIComponent("" + form_BusinessRole_DeleterUserId) + "&";
        if (form_BusinessRole_DeletionTime !== undefined && form_BusinessRole_DeletionTime !== null)
            url_ += "Form.BusinessRole.DeletionTime=" + encodeURIComponent(form_BusinessRole_DeletionTime ? "" + form_BusinessRole_DeletionTime.toJSON() : "") + "&";
        if (form_BusinessRole_LastModificationTime !== undefined && form_BusinessRole_LastModificationTime !== null)
            url_ += "Form.BusinessRole.LastModificationTime=" + encodeURIComponent(form_BusinessRole_LastModificationTime ? "" + form_BusinessRole_LastModificationTime.toJSON() : "") + "&";
        if (form_BusinessRole_LastModifierUserId !== undefined && form_BusinessRole_LastModifierUserId !== null)
            url_ += "Form.BusinessRole.LastModifierUserId=" + encodeURIComponent("" + form_BusinessRole_LastModifierUserId) + "&";
        if (form_BusinessRole_CreationTime === null)
            throw new Error("The parameter 'form_BusinessRole_CreationTime' cannot be null.");
        else if (form_BusinessRole_CreationTime !== undefined)
            url_ += "Form.BusinessRole.CreationTime=" + encodeURIComponent(form_BusinessRole_CreationTime ? "" + form_BusinessRole_CreationTime.toJSON() : "") + "&";
        if (form_BusinessRole_CreatorUserId !== undefined && form_BusinessRole_CreatorUserId !== null)
            url_ += "Form.BusinessRole.CreatorUserId=" + encodeURIComponent("" + form_BusinessRole_CreatorUserId) + "&";
        if (form_BusinessRole_Id === null)
            throw new Error("The parameter 'form_BusinessRole_Id' cannot be null.");
        else if (form_BusinessRole_Id !== undefined)
            url_ += "Form.BusinessRole.Id=" + encodeURIComponent("" + form_BusinessRole_Id) + "&";
        if (form_Status_Status === undefined || form_Status_Status === null)
            throw new Error("The parameter 'form_Status_Status' must be defined and cannot be null.");
        else
            url_ += "Form.Status.Status=" + encodeURIComponent("" + form_Status_Status) + "&";
        if (form_Status_TBL_Forms !== undefined && form_Status_TBL_Forms !== null)
            form_Status_TBL_Forms && form_Status_TBL_Forms.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Form.Status.TBL_Forms[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (form_Status_IsDeleted === null)
            throw new Error("The parameter 'form_Status_IsDeleted' cannot be null.");
        else if (form_Status_IsDeleted !== undefined)
            url_ += "Form.Status.IsDeleted=" + encodeURIComponent("" + form_Status_IsDeleted) + "&";
        if (form_Status_DeleterUserId !== undefined && form_Status_DeleterUserId !== null)
            url_ += "Form.Status.DeleterUserId=" + encodeURIComponent("" + form_Status_DeleterUserId) + "&";
        if (form_Status_DeletionTime !== undefined && form_Status_DeletionTime !== null)
            url_ += "Form.Status.DeletionTime=" + encodeURIComponent(form_Status_DeletionTime ? "" + form_Status_DeletionTime.toJSON() : "") + "&";
        if (form_Status_LastModificationTime !== undefined && form_Status_LastModificationTime !== null)
            url_ += "Form.Status.LastModificationTime=" + encodeURIComponent(form_Status_LastModificationTime ? "" + form_Status_LastModificationTime.toJSON() : "") + "&";
        if (form_Status_LastModifierUserId !== undefined && form_Status_LastModifierUserId !== null)
            url_ += "Form.Status.LastModifierUserId=" + encodeURIComponent("" + form_Status_LastModifierUserId) + "&";
        if (form_Status_CreationTime === null)
            throw new Error("The parameter 'form_Status_CreationTime' cannot be null.");
        else if (form_Status_CreationTime !== undefined)
            url_ += "Form.Status.CreationTime=" + encodeURIComponent(form_Status_CreationTime ? "" + form_Status_CreationTime.toJSON() : "") + "&";
        if (form_Status_CreatorUserId !== undefined && form_Status_CreatorUserId !== null)
            url_ += "Form.Status.CreatorUserId=" + encodeURIComponent("" + form_Status_CreatorUserId) + "&";
        if (form_Status_Id === null)
            throw new Error("The parameter 'form_Status_Id' cannot be null.");
        else if (form_Status_Id !== undefined)
            url_ += "Form.Status.Id=" + encodeURIComponent("" + form_Status_Id) + "&";
        if (form_PeriodType_Title === undefined || form_PeriodType_Title === null)
            throw new Error("The parameter 'form_PeriodType_Title' must be defined and cannot be null.");
        else
            url_ += "Form.PeriodType.Title=" + encodeURIComponent("" + form_PeriodType_Title) + "&";
        if (form_PeriodType_TBL_Forms !== undefined && form_PeriodType_TBL_Forms !== null)
            form_PeriodType_TBL_Forms && form_PeriodType_TBL_Forms.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Form.PeriodType.TBL_Forms[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (form_PeriodType_IsDeleted === null)
            throw new Error("The parameter 'form_PeriodType_IsDeleted' cannot be null.");
        else if (form_PeriodType_IsDeleted !== undefined)
            url_ += "Form.PeriodType.IsDeleted=" + encodeURIComponent("" + form_PeriodType_IsDeleted) + "&";
        if (form_PeriodType_DeleterUserId !== undefined && form_PeriodType_DeleterUserId !== null)
            url_ += "Form.PeriodType.DeleterUserId=" + encodeURIComponent("" + form_PeriodType_DeleterUserId) + "&";
        if (form_PeriodType_DeletionTime !== undefined && form_PeriodType_DeletionTime !== null)
            url_ += "Form.PeriodType.DeletionTime=" + encodeURIComponent(form_PeriodType_DeletionTime ? "" + form_PeriodType_DeletionTime.toJSON() : "") + "&";
        if (form_PeriodType_LastModificationTime !== undefined && form_PeriodType_LastModificationTime !== null)
            url_ += "Form.PeriodType.LastModificationTime=" + encodeURIComponent(form_PeriodType_LastModificationTime ? "" + form_PeriodType_LastModificationTime.toJSON() : "") + "&";
        if (form_PeriodType_LastModifierUserId !== undefined && form_PeriodType_LastModifierUserId !== null)
            url_ += "Form.PeriodType.LastModifierUserId=" + encodeURIComponent("" + form_PeriodType_LastModifierUserId) + "&";
        if (form_PeriodType_CreationTime === null)
            throw new Error("The parameter 'form_PeriodType_CreationTime' cannot be null.");
        else if (form_PeriodType_CreationTime !== undefined)
            url_ += "Form.PeriodType.CreationTime=" + encodeURIComponent(form_PeriodType_CreationTime ? "" + form_PeriodType_CreationTime.toJSON() : "") + "&";
        if (form_PeriodType_CreatorUserId !== undefined && form_PeriodType_CreatorUserId !== null)
            url_ += "Form.PeriodType.CreatorUserId=" + encodeURIComponent("" + form_PeriodType_CreatorUserId) + "&";
        if (form_PeriodType_Id === null)
            throw new Error("The parameter 'form_PeriodType_Id' cannot be null.");
        else if (form_PeriodType_Id !== undefined)
            url_ += "Form.PeriodType.Id=" + encodeURIComponent("" + form_PeriodType_Id) + "&";
        if (form_TBL_FormBusinessUnits !== undefined && form_TBL_FormBusinessUnits !== null)
            form_TBL_FormBusinessUnits && form_TBL_FormBusinessUnits.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Form.TBL_FormBusinessUnits[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (form_TBL_FormStructureRows !== undefined && form_TBL_FormStructureRows !== null)
            form_TBL_FormStructureRows && form_TBL_FormStructureRows.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Form.TBL_FormStructureRows[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (form_TBL_PivotQueries !== undefined && form_TBL_PivotQueries !== null)
            form_TBL_PivotQueries && form_TBL_PivotQueries.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Form.TBL_PivotQueries[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (form_FormName !== undefined && form_FormName !== null)
            url_ += "Form.FormName=" + encodeURIComponent("" + form_FormName) + "&";
        if (form_IsDeleted === null)
            throw new Error("The parameter 'form_IsDeleted' cannot be null.");
        else if (form_IsDeleted !== undefined)
            url_ += "Form.IsDeleted=" + encodeURIComponent("" + form_IsDeleted) + "&";
        if (form_DeleterUserId !== undefined && form_DeleterUserId !== null)
            url_ += "Form.DeleterUserId=" + encodeURIComponent("" + form_DeleterUserId) + "&";
        if (form_DeletionTime !== undefined && form_DeletionTime !== null)
            url_ += "Form.DeletionTime=" + encodeURIComponent(form_DeletionTime ? "" + form_DeletionTime.toJSON() : "") + "&";
        if (form_LastModificationTime !== undefined && form_LastModificationTime !== null)
            url_ += "Form.LastModificationTime=" + encodeURIComponent(form_LastModificationTime ? "" + form_LastModificationTime.toJSON() : "") + "&";
        if (form_LastModifierUserId !== undefined && form_LastModifierUserId !== null)
            url_ += "Form.LastModifierUserId=" + encodeURIComponent("" + form_LastModifierUserId) + "&";
        if (form_CreationTime === null)
            throw new Error("The parameter 'form_CreationTime' cannot be null.");
        else if (form_CreationTime !== undefined)
            url_ += "Form.CreationTime=" + encodeURIComponent(form_CreationTime ? "" + form_CreationTime.toJSON() : "") + "&";
        if (form_CreatorUserId !== undefined && form_CreatorUserId !== null)
            url_ += "Form.CreatorUserId=" + encodeURIComponent("" + form_CreatorUserId) + "&";
        if (form_Id === null)
            throw new Error("The parameter 'form_Id' cannot be null.");
        else if (form_Id !== undefined)
            url_ += "Form.Id=" + encodeURIComponent("" + form_Id) + "&";
        if (tBL_UserForms !== undefined && tBL_UserForms !== null)
            tBL_UserForms && tBL_UserForms.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "TBL_UserForms[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (isDeleted === null)
            throw new Error("The parameter 'isDeleted' cannot be null.");
        else if (isDeleted !== undefined)
            url_ += "IsDeleted=" + encodeURIComponent("" + isDeleted) + "&";
        if (deleterUserId !== undefined && deleterUserId !== null)
            url_ += "DeleterUserId=" + encodeURIComponent("" + deleterUserId) + "&";
        if (deletionTime !== undefined && deletionTime !== null)
            url_ += "DeletionTime=" + encodeURIComponent(deletionTime ? "" + deletionTime.toJSON() : "") + "&";
        if (lastModificationTime !== undefined && lastModificationTime !== null)
            url_ += "LastModificationTime=" + encodeURIComponent(lastModificationTime ? "" + lastModificationTime.toJSON() : "") + "&";
        if (lastModifierUserId !== undefined && lastModifierUserId !== null)
            url_ += "LastModifierUserId=" + encodeURIComponent("" + lastModifierUserId) + "&";
        if (creationTime === null)
            throw new Error("The parameter 'creationTime' cannot be null.");
        else if (creationTime !== undefined)
            url_ += "CreationTime=" + encodeURIComponent(creationTime ? "" + creationTime.toJSON() : "") + "&";
        if (creatorUserId !== undefined && creatorUserId !== null)
            url_ += "CreatorUserId=" + encodeURIComponent("" + creatorUserId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBusinessForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBusinessForm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBusinessForm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FormDataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertUpdateUserFormData(body: UpdateFormDataDto | undefined): Observable<FormDataCellDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormData/InsertUpdateUserFormData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUpdateUserFormData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUpdateUserFormData(<any>response_);
                } catch (e) {
                    return <Observable<FormDataCellDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDataCellDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUpdateUserFormData(response: HttpResponseBase): Observable<FormDataCellDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormDataCellDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDataCellDto[]>(<any>null);
    }
}

@Injectable()
export class FormDesignerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param formId (optional) 
     * @return Success
     */
    getAllDesignerSections(formId: number | undefined): Observable<FormDesignerAllSectionsDto> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetAllDesignerSections?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDesignerSections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDesignerSections(<any>response_);
                } catch (e) {
                    return <Observable<FormDesignerAllSectionsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDesignerAllSectionsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDesignerSections(response: HttpResponseBase): Observable<FormDesignerAllSectionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormDesignerAllSectionsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDesignerAllSectionsDto>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @return Success
     */
    getAllDesignerSubSections(formId: number | undefined): Observable<FormDesignerAllSubSectionsDto> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetAllDesignerSubSections?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDesignerSubSections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDesignerSubSections(<any>response_);
                } catch (e) {
                    return <Observable<FormDesignerAllSubSectionsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDesignerAllSubSectionsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDesignerSubSections(response: HttpResponseBase): Observable<FormDesignerAllSubSectionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormDesignerAllSubSectionsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDesignerAllSubSectionsDto>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @param isSubSection (optional) 
     * @param subSectionId (optional) 
     * @return Success
     */
    getFormStructureBySubSectionId(formId: number | undefined, isSubSection: boolean | undefined, subSectionId: number | undefined): Observable<FormDesignerSubSectionStructureDto> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetFormStructureBySubSectionId?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (isSubSection === null)
            throw new Error("The parameter 'isSubSection' cannot be null.");
        else if (isSubSection !== undefined)
            url_ += "IsSubSection=" + encodeURIComponent("" + isSubSection) + "&";
        if (subSectionId === null)
            throw new Error("The parameter 'subSectionId' cannot be null.");
        else if (subSectionId !== undefined)
            url_ += "SubSectionId=" + encodeURIComponent("" + subSectionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormStructureBySubSectionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormStructureBySubSectionId(<any>response_);
                } catch (e) {
                    return <Observable<FormDesignerSubSectionStructureDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDesignerSubSectionStructureDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormStructureBySubSectionId(response: HttpResponseBase): Observable<FormDesignerSubSectionStructureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormDesignerSubSectionStructureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDesignerSubSectionStructureDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveFormDesignerMetaData(body: FormDesignerSubSectionStructureDto | undefined): Observable<FormDesignerSubSectionStructureDto> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/SaveFormDesignerMetaData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFormDesignerMetaData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFormDesignerMetaData(<any>response_);
                } catch (e) {
                    return <Observable<FormDesignerSubSectionStructureDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDesignerSubSectionStructureDto>><any>_observableThrow(response_);
        }));
    }

    protected processSaveFormDesignerMetaData(response: HttpResponseBase): Observable<FormDesignerSubSectionStructureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormDesignerSubSectionStructureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDesignerSubSectionStructureDto>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @return Success
     */
    getFormMetaData(formId: number | undefined): Observable<FormDesignerMetaData> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetFormMetaData?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormMetaData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormMetaData(<any>response_);
                } catch (e) {
                    return <Observable<FormDesignerMetaData>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDesignerMetaData>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormMetaData(response: HttpResponseBase): Observable<FormDesignerMetaData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormDesignerMetaData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDesignerMetaData>(<any>null);
    }

    /**
     * @return Success
     */
    getFormColumnsTemplates(): Observable<FormColumnOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetFormColumnsTemplates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormColumnsTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormColumnsTemplates(<any>response_);
                } catch (e) {
                    return <Observable<FormColumnOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormColumnOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormColumnsTemplates(response: HttpResponseBase): Observable<FormColumnOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormColumnOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormColumnOutputDto[]>(<any>null);
    }

    /**
     * @param prefixText (optional) 
     * @return Success
     */
    getAllIndicatorTypesByPrefix(prefixText: string | null | undefined): Observable<IndicatorTypeEditDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetAllIndicatorTypesByPrefix?";
        if (prefixText !== undefined && prefixText !== null)
            url_ += "prefixText=" + encodeURIComponent("" + prefixText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIndicatorTypesByPrefix(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIndicatorTypesByPrefix(<any>response_);
                } catch (e) {
                    return <Observable<IndicatorTypeEditDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IndicatorTypeEditDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIndicatorTypesByPrefix(response: HttpResponseBase): Observable<IndicatorTypeEditDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(IndicatorTypeEditDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndicatorTypeEditDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMeasure(): Observable<FormColumnOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetAllMeasure";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMeasure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMeasure(<any>response_);
                } catch (e) {
                    return <Observable<FormColumnOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormColumnOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMeasure(response: HttpResponseBase): Observable<FormColumnOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormColumnOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormColumnOutputDto[]>(<any>null);
    }

    /**
     * @param dimensionGroupId (optional) 
     * @param businessUnitId (optional) 
     * @param excludedDimensionIds (optional) 
     * @param dimensionPrefixTitle (optional) 
     * @return Success
     */
    getDimensionsData(dimensionGroupId: number | undefined, businessUnitId: number | undefined, excludedDimensionIds: number[] | null | undefined, dimensionPrefixTitle: string | null | undefined): Observable<DimensionFormDesignerListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetDimensionsData?";
        if (dimensionGroupId === null)
            throw new Error("The parameter 'dimensionGroupId' cannot be null.");
        else if (dimensionGroupId !== undefined)
            url_ += "DimensionGroupId=" + encodeURIComponent("" + dimensionGroupId) + "&";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "BusinessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (excludedDimensionIds !== undefined && excludedDimensionIds !== null)
            excludedDimensionIds && excludedDimensionIds.forEach(item => { url_ += "ExcludedDimensionIds=" + encodeURIComponent("" + item) + "&"; });
        if (dimensionPrefixTitle !== undefined && dimensionPrefixTitle !== null)
            url_ += "DimensionPrefixTitle=" + encodeURIComponent("" + dimensionPrefixTitle) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDimensionsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDimensionsData(<any>response_);
                } catch (e) {
                    return <Observable<DimensionFormDesignerListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DimensionFormDesignerListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDimensionsData(response: HttpResponseBase): Observable<DimensionFormDesignerListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DimensionFormDesignerListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DimensionFormDesignerListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDimensionGroup(): Observable<DimensionFormDesignerListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetAllDimensionGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDimensionGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDimensionGroup(<any>response_);
                } catch (e) {
                    return <Observable<DimensionFormDesignerListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DimensionFormDesignerListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDimensionGroup(response: HttpResponseBase): Observable<DimensionFormDesignerListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DimensionFormDesignerListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DimensionFormDesignerListDto[]>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @return Success
     */
    getFormBusinessUnits(formId: number | undefined): Observable<BusinessUnitListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetFormBusinessUnits?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormBusinessUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormBusinessUnits(<any>response_);
                } catch (e) {
                    return <Observable<BusinessUnitListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessUnitListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormBusinessUnits(response: HttpResponseBase): Observable<BusinessUnitListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BusinessUnitListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessUnitListDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUpdateFormStructureRow(body: FormStructureRowDesignerDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/CreateUpdateFormStructureRow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUpdateFormStructureRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUpdateFormStructureRow(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUpdateFormStructureRow(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteFormStructureRow(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/DeleteFormStructureRow?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFormStructureRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFormStructureRow(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFormStructureRow(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUpdateFormStructureCell(body: FormStructureCellDesignerDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/CreateUpdateFormStructureCell";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUpdateFormStructureCell(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUpdateFormStructureCell(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUpdateFormStructureCell(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getStructureWeekDimensioId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetStructureWeekDimensioId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStructureWeekDimensioId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStructureWeekDimensioId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetStructureWeekDimensioId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getCellTypes(): Observable<FormCellTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetCellTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCellTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCellTypes(<any>response_);
                } catch (e) {
                    return <Observable<FormCellTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormCellTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCellTypes(response: HttpResponseBase): Observable<FormCellTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormCellTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormCellTypeDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUpdateFormStructureSection(body: FormDesignerSectionDto[] | null | undefined): Observable<FormDesignerSectionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/CreateUpdateFormStructureSection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUpdateFormStructureSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUpdateFormStructureSection(<any>response_);
                } catch (e) {
                    return <Observable<FormDesignerSectionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDesignerSectionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUpdateFormStructureSection(response: HttpResponseBase): Observable<FormDesignerSectionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormDesignerSectionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDesignerSectionDto[]>(<any>null);
    }

    /**
     * @param rowSectionId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createUpdateFormStructureSubSection(rowSectionId: number | undefined, body: FormDesignerSubSectionDto[] | null | undefined): Observable<FormDesignerSubSectionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/CreateUpdateFormStructureSubSection?";
        if (rowSectionId === null)
            throw new Error("The parameter 'rowSectionId' cannot be null.");
        else if (rowSectionId !== undefined)
            url_ += "rowSectionId=" + encodeURIComponent("" + rowSectionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUpdateFormStructureSubSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUpdateFormStructureSubSection(<any>response_);
                } catch (e) {
                    return <Observable<FormDesignerSubSectionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDesignerSubSectionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUpdateFormStructureSubSection(response: HttpResponseBase): Observable<FormDesignerSubSectionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormDesignerSubSectionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDesignerSubSectionDto[]>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @param formStructureRowId (optional) 
     * @return Success
     */
    getFormDataSource(formId: number | undefined, formStructureRowId: number | undefined): Observable<PivotHierarchyDto> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetFormDataSource?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (formStructureRowId === null)
            throw new Error("The parameter 'formStructureRowId' cannot be null.");
        else if (formStructureRowId !== undefined)
            url_ += "FormStructureRowId=" + encodeURIComponent("" + formStructureRowId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormDataSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormDataSource(<any>response_);
                } catch (e) {
                    return <Observable<PivotHierarchyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PivotHierarchyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormDataSource(response: HttpResponseBase): Observable<PivotHierarchyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PivotHierarchyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PivotHierarchyDto>(<any>null);
    }

    /**
     * @param formStructureColumnId (optional) 
     * @param formStructureRowId (optional) 
     * @return Success
     */
    getSelectedColumnBindingDataSource(formStructureColumnId: number | undefined, formStructureRowId: number | undefined): Observable<FormColumnCubeMappingDto> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetSelectedColumnBindingDataSource?";
        if (formStructureColumnId === null)
            throw new Error("The parameter 'formStructureColumnId' cannot be null.");
        else if (formStructureColumnId !== undefined)
            url_ += "FormStructureColumnId=" + encodeURIComponent("" + formStructureColumnId) + "&";
        if (formStructureRowId === null)
            throw new Error("The parameter 'formStructureRowId' cannot be null.");
        else if (formStructureRowId !== undefined)
            url_ += "FormStructureRowId=" + encodeURIComponent("" + formStructureRowId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelectedColumnBindingDataSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelectedColumnBindingDataSource(<any>response_);
                } catch (e) {
                    return <Observable<FormColumnCubeMappingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormColumnCubeMappingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSelectedColumnBindingDataSource(response: HttpResponseBase): Observable<FormColumnCubeMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormColumnCubeMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormColumnCubeMappingDto>(<any>null);
    }

    /**
     * @param kpiId (optional) 
     * @return Success
     */
    getKpiPercentageColums(kpiId: number | undefined): Observable<FormStructurePercentageDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesigner/GetKpiPercentageColums?";
        if (kpiId === null)
            throw new Error("The parameter 'kpiId' cannot be null.");
        else if (kpiId !== undefined)
            url_ += "kpiId=" + encodeURIComponent("" + kpiId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKpiPercentageColums(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKpiPercentageColums(<any>response_);
                } catch (e) {
                    return <Observable<FormStructurePercentageDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructurePercentageDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetKpiPercentageColums(response: HttpResponseBase): Observable<FormStructurePercentageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormStructurePercentageDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructurePercentageDto[]>(<any>null);
    }
}

@Injectable()
export class FormDesignerReferenceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSubSectionWithSectionName(body: GetReferenceSubSectionInput | undefined): Observable<SubSectionWithSectionNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerReference/GetSubSectionWithSectionName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubSectionWithSectionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubSectionWithSectionName(<any>response_);
                } catch (e) {
                    return <Observable<SubSectionWithSectionNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubSectionWithSectionNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubSectionWithSectionName(response: HttpResponseBase): Observable<SubSectionWithSectionNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubSectionWithSectionNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubSectionWithSectionNameDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getReferencedKPIsStructureAsKPI(body: StructureReferenceDto | undefined): Observable<FormDesignerKPIDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerReference/GetReferencedKPIsStructureAsKPI";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferencedKPIsStructureAsKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencedKPIsStructureAsKPI(<any>response_);
                } catch (e) {
                    return <Observable<FormDesignerKPIDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDesignerKPIDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferencedKPIsStructureAsKPI(response: HttpResponseBase): Observable<FormDesignerKPIDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormDesignerKPIDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDesignerKPIDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getReferencedKPIsStructureAsDimension(body: StructureReferenceDto | undefined): Observable<FormDesignerDimensionDataDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerReference/GetReferencedKPIsStructureAsDimension";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferencedKPIsStructureAsDimension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencedKPIsStructureAsDimension(<any>response_);
                } catch (e) {
                    return <Observable<FormDesignerDimensionDataDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDesignerDimensionDataDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferencedKPIsStructureAsDimension(response: HttpResponseBase): Observable<FormDesignerDimensionDataDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormDesignerDimensionDataDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDesignerDimensionDataDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    retrieveSubSectionForReferenceSum(body: GetReferenceSumInputDto | undefined): Observable<SubSectionWithSectionNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerReference/RetrieveSubSectionForReferenceSum";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveSubSectionForReferenceSum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveSubSectionForReferenceSum(<any>response_);
                } catch (e) {
                    return <Observable<SubSectionWithSectionNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubSectionWithSectionNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveSubSectionForReferenceSum(response: HttpResponseBase): Observable<SubSectionWithSectionNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubSectionWithSectionNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubSectionWithSectionNameDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    retrieveDimensionForReferenceSum(body: GetReferenceDimensionSumInputDto | undefined): Observable<ReferenceDimensionSumDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerReference/RetrieveDimensionForReferenceSum";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveDimensionForReferenceSum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveDimensionForReferenceSum(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDimensionSumDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDimensionSumDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processRetrieveDimensionForReferenceSum(response: HttpResponseBase): Observable<ReferenceDimensionSumDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ReferenceDimensionSumDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDimensionSumDto[]>(<any>null);
    }
}

@Injectable()
export class FormDesignerSharedServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param kpiId (optional) 
     * @return Success
     */
    getKpiPercentageColums(kpiId: number | undefined): Observable<FormStructurePercentageDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/GetKpiPercentageColums?";
        if (kpiId === null)
            throw new Error("The parameter 'kpiId' cannot be null.");
        else if (kpiId !== undefined)
            url_ += "kpiId=" + encodeURIComponent("" + kpiId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKpiPercentageColums(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKpiPercentageColums(<any>response_);
                } catch (e) {
                    return <Observable<FormStructurePercentageDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructurePercentageDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetKpiPercentageColums(response: HttpResponseBase): Observable<FormStructurePercentageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormStructurePercentageDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructurePercentageDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mergeKpiPercentageColums(body: FormStructureColumnDto[] | null | undefined): Observable<FormStructureColumnDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/MergeKpiPercentageColums";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeKpiPercentageColums(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeKpiPercentageColums(<any>response_);
                } catch (e) {
                    return <Observable<FormStructureColumnDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructureColumnDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processMergeKpiPercentageColums(response: HttpResponseBase): Observable<FormStructureColumnDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormStructureColumnDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructureColumnDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mapToFormStructurePercentage(body: FormStructurePercentageDto | undefined): Observable<TBL_FormStructurePercentage> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/MapToFormStructurePercentage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMapToFormStructurePercentage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMapToFormStructurePercentage(<any>response_);
                } catch (e) {
                    return <Observable<TBL_FormStructurePercentage>><any>_observableThrow(e);
                }
            } else
                return <Observable<TBL_FormStructurePercentage>><any>_observableThrow(response_);
        }));
    }

    protected processMapToFormStructurePercentage(response: HttpResponseBase): Observable<TBL_FormStructurePercentage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TBL_FormStructurePercentage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TBL_FormStructurePercentage>(<any>null);
    }

    /**
     * @param kpiId (optional) 
     * @return Success
     */
    getKpiBindingDataSource(kpiId: number | undefined): Observable<FormColumnCubeMappingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/GetKpiBindingDataSource?";
        if (kpiId === null)
            throw new Error("The parameter 'kpiId' cannot be null.");
        else if (kpiId !== undefined)
            url_ += "kpiId=" + encodeURIComponent("" + kpiId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKpiBindingDataSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKpiBindingDataSource(<any>response_);
                } catch (e) {
                    return <Observable<FormColumnCubeMappingDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormColumnCubeMappingDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetKpiBindingDataSource(response: HttpResponseBase): Observable<FormColumnCubeMappingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormColumnCubeMappingDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormColumnCubeMappingDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toFormStructureRow(body: FormStructureDataModel | undefined): Observable<FormStructureRowDto> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/ToFormStructureRow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToFormStructureRow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToFormStructureRow(<any>response_);
                } catch (e) {
                    return <Observable<FormStructureRowDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructureRowDto>><any>_observableThrow(response_);
        }));
    }

    protected processToFormStructureRow(response: HttpResponseBase): Observable<FormStructureRowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormStructureRowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructureRowDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toFormStructureColumn(body: FormStructureDataModel | undefined): Observable<FormStructureColumnDto> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/ToFormStructureColumn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToFormStructureColumn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToFormStructureColumn(<any>response_);
                } catch (e) {
                    return <Observable<FormStructureColumnDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructureColumnDto>><any>_observableThrow(response_);
        }));
    }

    protected processToFormStructureColumn(response: HttpResponseBase): Observable<FormStructureColumnDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormStructureColumnDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructureColumnDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toFormDesignerStructureDataCell(body: FormStructureDataModel | undefined): Observable<FormStructerDataCellDto> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/ToFormDesignerStructureDataCell";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToFormDesignerStructureDataCell(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToFormDesignerStructureDataCell(<any>response_);
                } catch (e) {
                    return <Observable<FormStructerDataCellDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructerDataCellDto>><any>_observableThrow(response_);
        }));
    }

    protected processToFormDesignerStructureDataCell(response: HttpResponseBase): Observable<FormStructerDataCellDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormStructerDataCellDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructerDataCellDto>(<any>null);
    }

    /**
     * @param dimensionId (optional) 
     * @return Success
     */
    getDimensionBindingDataSource(dimensionId: number | undefined): Observable<FormDimensionCubeMappingDto> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/GetDimensionBindingDataSource?";
        if (dimensionId === null)
            throw new Error("The parameter 'dimensionId' cannot be null.");
        else if (dimensionId !== undefined)
            url_ += "dimensionId=" + encodeURIComponent("" + dimensionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDimensionBindingDataSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDimensionBindingDataSource(<any>response_);
                } catch (e) {
                    return <Observable<FormDimensionCubeMappingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDimensionCubeMappingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDimensionBindingDataSource(response: HttpResponseBase): Observable<FormDimensionCubeMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormDimensionCubeMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDimensionCubeMappingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    referencedKPIsStructure(body: StructureReferenceDto | undefined): Observable<FormDesignerKPIDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/ReferencedKPIsStructure";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReferencedKPIsStructure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReferencedKPIsStructure(<any>response_);
                } catch (e) {
                    return <Observable<FormDesignerKPIDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDesignerKPIDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReferencedKPIsStructure(response: HttpResponseBase): Observable<FormDesignerKPIDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormDesignerKPIDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDesignerKPIDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    referencedCells(body: number[] | null | undefined): Observable<FormStructerDataCellDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/ReferencedCells";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReferencedCells(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReferencedCells(<any>response_);
                } catch (e) {
                    return <Observable<FormStructerDataCellDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructerDataCellDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReferencedCells(response: HttpResponseBase): Observable<FormStructerDataCellDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormStructerDataCellDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructerDataCellDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    referenceWeeks(body: number[] | null | undefined): Observable<FormDimensionWeekDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/ReferenceWeeks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReferenceWeeks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReferenceWeeks(<any>response_);
                } catch (e) {
                    return <Observable<FormDimensionWeekDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDimensionWeekDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReferenceWeeks(response: HttpResponseBase): Observable<FormDimensionWeekDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormDimensionWeekDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDimensionWeekDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    referenceDimensions(body: number[] | null | undefined): Observable<FormDesignerDimensionDataDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/ReferenceDimensions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReferenceDimensions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReferenceDimensions(<any>response_);
                } catch (e) {
                    return <Observable<FormDesignerDimensionDataDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDesignerDimensionDataDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReferenceDimensions(response: HttpResponseBase): Observable<FormDesignerDimensionDataDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormDesignerDimensionDataDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDesignerDimensionDataDto[]>(<any>null);
    }

    /**
     * @param showValues (optional) 
     * @param dimensionWeeks (optional) 
     * @param referenceId (optional) 
     * @param referenceType (optional) 
     * @param refDimensionSum (optional) 
     * @param isDeleted (optional) 
     * @param cells (optional) 
     * @param title (optional) 
     * @param code (optional) 
     * @param order (optional) 
     * @param parentId (optional) 
     * @param isLeaf (optional) 
     * @param rowTypeId (optional) 
     * @param structureTypeId (optional) 
     * @param structureId (optional) 
     * @param activityCountDto_TaskCount (optional) 
     * @param activityCountDto_IssueCount (optional) 
     * @param activityCountDto_MeetingCount (optional) 
     * @param referenceData (optional) 
     * @param id (optional) 
     * @param refDimnsionJson (optional) 
     * @param businessUnitId (optional) 
     * @param weeks (optional) 
     * @param month (optional) 
     * @param year (optional) 
     * @return Success
     */
    getReferenceDimensionSummetion(showValues: boolean | undefined, dimensionWeeks: FormDimensionWeekDto[] | null | undefined, referenceId: number | undefined, referenceType: ReferenceType | undefined, refDimensionSum: ReferenceDimensionSumDto[] | null | undefined, isDeleted: boolean | undefined, cells: FormStructerDataCellDto[] | null | undefined, title: string | null | undefined, code: string | null | undefined, order: number | undefined, parentId: number | null | undefined, isLeaf: boolean | undefined, rowTypeId: number | null | undefined, structureTypeId: number | null | undefined, structureId: number | null | undefined, activityCountDto_TaskCount: number | undefined, activityCountDto_IssueCount: number | undefined, activityCountDto_MeetingCount: number | undefined, referenceData: string | null | undefined, id: number | undefined, refDimnsionJson: string | null | undefined, businessUnitId: number | undefined, weeks: number[] | null | undefined, month: number | undefined, year: number | undefined): Observable<FormDimensionDataDto> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/GetReferenceDimensionSummetion?";
        if (showValues === null)
            throw new Error("The parameter 'showValues' cannot be null.");
        else if (showValues !== undefined)
            url_ += "ShowValues=" + encodeURIComponent("" + showValues) + "&";
        if (dimensionWeeks !== undefined && dimensionWeeks !== null)
            dimensionWeeks && dimensionWeeks.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "DimensionWeeks[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (referenceId === null)
            throw new Error("The parameter 'referenceId' cannot be null.");
        else if (referenceId !== undefined)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&";
        if (referenceType === null)
            throw new Error("The parameter 'referenceType' cannot be null.");
        else if (referenceType !== undefined)
            url_ += "ReferenceType=" + encodeURIComponent("" + referenceType) + "&";
        if (refDimensionSum !== undefined && refDimensionSum !== null)
            refDimensionSum && refDimensionSum.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "RefDimensionSum[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (isDeleted === null)
            throw new Error("The parameter 'isDeleted' cannot be null.");
        else if (isDeleted !== undefined)
            url_ += "IsDeleted=" + encodeURIComponent("" + isDeleted) + "&";
        if (cells !== undefined && cells !== null)
            cells && cells.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Cells[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (title !== undefined && title !== null)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (order === null)
            throw new Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (parentId !== undefined && parentId !== null)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (isLeaf === null)
            throw new Error("The parameter 'isLeaf' cannot be null.");
        else if (isLeaf !== undefined)
            url_ += "IsLeaf=" + encodeURIComponent("" + isLeaf) + "&";
        if (rowTypeId !== undefined && rowTypeId !== null)
            url_ += "RowTypeId=" + encodeURIComponent("" + rowTypeId) + "&";
        if (structureTypeId !== undefined && structureTypeId !== null)
            url_ += "StructureTypeId=" + encodeURIComponent("" + structureTypeId) + "&";
        if (structureId !== undefined && structureId !== null)
            url_ += "StructureId=" + encodeURIComponent("" + structureId) + "&";
        if (activityCountDto_TaskCount === null)
            throw new Error("The parameter 'activityCountDto_TaskCount' cannot be null.");
        else if (activityCountDto_TaskCount !== undefined)
            url_ += "activityCountDto.TaskCount=" + encodeURIComponent("" + activityCountDto_TaskCount) + "&";
        if (activityCountDto_IssueCount === null)
            throw new Error("The parameter 'activityCountDto_IssueCount' cannot be null.");
        else if (activityCountDto_IssueCount !== undefined)
            url_ += "activityCountDto.IssueCount=" + encodeURIComponent("" + activityCountDto_IssueCount) + "&";
        if (activityCountDto_MeetingCount === null)
            throw new Error("The parameter 'activityCountDto_MeetingCount' cannot be null.");
        else if (activityCountDto_MeetingCount !== undefined)
            url_ += "activityCountDto.MeetingCount=" + encodeURIComponent("" + activityCountDto_MeetingCount) + "&";
        if (referenceData !== undefined && referenceData !== null)
            url_ += "ReferenceData=" + encodeURIComponent("" + referenceData) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (refDimnsionJson !== undefined && refDimnsionJson !== null)
            url_ += "refDimnsionJson=" + encodeURIComponent("" + refDimnsionJson) + "&";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "businessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (weeks !== undefined && weeks !== null)
            weeks && weeks.forEach(item => { url_ += "weeks=" + encodeURIComponent("" + item) + "&"; });
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceDimensionSummetion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceDimensionSummetion(<any>response_);
                } catch (e) {
                    return <Observable<FormDimensionDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormDimensionDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceDimensionSummetion(response: HttpResponseBase): Observable<FormDimensionDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormDimensionDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormDimensionDataDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toFormColumn(body: SubSectionDataModel | undefined): Observable<FormStructureColumnDto> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/ToFormColumn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToFormColumn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToFormColumn(<any>response_);
                } catch (e) {
                    return <Observable<FormStructureColumnDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructureColumnDto>><any>_observableThrow(response_);
        }));
    }

    protected processToFormColumn(response: HttpResponseBase): Observable<FormStructureColumnDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormStructureColumnDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructureColumnDto>(<any>null);
    }

    /**
     * @param kpiIds (optional) 
     * @return Success
     */
    getSelectedKpisPercentageColums(kpiIds: number[] | null | undefined): Observable<FormStructurePercentageDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormDesignerShared/GetSelectedKpisPercentageColums?";
        if (kpiIds !== undefined && kpiIds !== null)
            kpiIds && kpiIds.forEach(item => { url_ += "kpiIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelectedKpisPercentageColums(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelectedKpisPercentageColums(<any>response_);
                } catch (e) {
                    return <Observable<FormStructurePercentageDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructurePercentageDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSelectedKpisPercentageColums(response: HttpResponseBase): Observable<FormStructurePercentageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormStructurePercentageDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructurePercentageDto[]>(<any>null);
    }
}

@Injectable()
export class FormPeriodTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllFormTypes(sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FormTypeListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FormPeriodType/GetAllFormTypes?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFormTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFormTypes(<any>response_);
                } catch (e) {
                    return <Observable<FormTypeListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormTypeListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFormTypes(response: HttpResponseBase): Observable<FormTypeListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormTypeListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormTypeListDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getFormTypesList(): Observable<FormTypeListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormPeriodType/GetFormTypesList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormTypesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormTypesList(<any>response_);
                } catch (e) {
                    return <Observable<FormTypeListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormTypeListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormTypesList(response: HttpResponseBase): Observable<FormTypeListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormTypeListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormTypeListDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getFormType(id: number | undefined): Observable<FormTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/FormPeriodType/GetFormType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormType(<any>response_);
                } catch (e) {
                    return <Observable<FormTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormType(response: HttpResponseBase): Observable<FormTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormTypeDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getFormTypeForEdit(id: number | null | undefined): Observable<GetFormTypeEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/FormPeriodType/GetFormTypeForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetFormTypeEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFormTypeEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormTypeForEdit(response: HttpResponseBase): Observable<GetFormTypeEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFormTypeEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFormTypeEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateFormType(body: CreateOrUpdateFormTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FormPeriodType/CreateOrUpdateFormType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateFormType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateFormType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateFormType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteFormType(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FormPeriodType/DeleteFormType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFormType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFormType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFormType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FormPreviewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param formId (optional) 
     * @param subSectionId (optional) 
     * @return Success
     */
    getFormPreviewStructure(formId: number | undefined, subSectionId: number | undefined): Observable<FormSubsectionDto> {
        let url_ = this.baseUrl + "/api/services/app/FormPreview/GetFormPreviewStructure?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (subSectionId === null)
            throw new Error("The parameter 'subSectionId' cannot be null.");
        else if (subSectionId !== undefined)
            url_ += "SubSectionId=" + encodeURIComponent("" + subSectionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormPreviewStructure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormPreviewStructure(<any>response_);
                } catch (e) {
                    return <Observable<FormSubsectionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormSubsectionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormPreviewStructure(response: HttpResponseBase): Observable<FormSubsectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormSubsectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormSubsectionDto>(<any>null);
    }
}

@Injectable()
export class FormStatusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllFormsStatus(): Observable<FormStatusListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FormStatus/GetAllFormsStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFormsStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFormsStatus(<any>response_);
                } catch (e) {
                    return <Observable<FormStatusListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStatusListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFormsStatus(response: HttpResponseBase): Observable<FormStatusListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormStatusListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStatusListDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getFormStatus(id: number | undefined): Observable<FormStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/FormStatus/GetFormStatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormStatus(<any>response_);
                } catch (e) {
                    return <Observable<FormStatusDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStatusDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormStatus(response: HttpResponseBase): Observable<FormStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStatusDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getFormStatusForEdit(id: number | null | undefined): Observable<GetFormStatusEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/FormStatus/GetFormStatusForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetFormStatusEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFormStatusEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormStatusForEdit(response: HttpResponseBase): Observable<GetFormStatusEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFormStatusEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFormStatusEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateFormStatus(body: CreateOrUpdateFormStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FormStatus/CreateOrUpdateFormStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateFormStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateFormStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateFormStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteFormStatus(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FormStatus/DeleteFormStatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFormStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFormStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFormStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param formStatusTitle (optional) 
     * @return Success
     */
    getFormStatusId(formStatusTitle: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/FormStatus/GetFormStatusId?";
        if (formStatusTitle !== undefined && formStatusTitle !== null)
            url_ += "FormStatusTitle=" + encodeURIComponent("" + formStatusTitle) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormStatusId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormStatusId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormStatusId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class FormStructurePercentageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllFormStructurePercentages(sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FormStructurePercentageListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FormStructurePercentage/GetAllFormStructurePercentages?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFormStructurePercentages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFormStructurePercentages(<any>response_);
                } catch (e) {
                    return <Observable<FormStructurePercentageListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructurePercentageListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFormStructurePercentages(response: HttpResponseBase): Observable<FormStructurePercentageListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormStructurePercentageListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructurePercentageListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getFormStructurePercentage(id: number | undefined): Observable<FormStructurePercentageDto> {
        let url_ = this.baseUrl + "/api/services/app/FormStructurePercentage/GetFormStructurePercentage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormStructurePercentage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormStructurePercentage(<any>response_);
                } catch (e) {
                    return <Observable<FormStructurePercentageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructurePercentageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormStructurePercentage(response: HttpResponseBase): Observable<FormStructurePercentageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormStructurePercentageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructurePercentageDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getFormStructurePercentageForEdit(id: number | null | undefined): Observable<GetFormStructurePercentageEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/FormStructurePercentage/GetFormStructurePercentageForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormStructurePercentageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormStructurePercentageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetFormStructurePercentageEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFormStructurePercentageEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormStructurePercentageForEdit(response: HttpResponseBase): Observable<GetFormStructurePercentageEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFormStructurePercentageEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFormStructurePercentageEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateFormStructurePercentage(body: CreateOrUpdateFormStructurePercentageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FormStructurePercentage/CreateOrUpdateFormStructurePercentage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateFormStructurePercentage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateFormStructurePercentage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateFormStructurePercentage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteFormStructurePercentage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FormStructurePercentage/DeleteFormStructurePercentage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFormStructurePercentage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFormStructurePercentage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFormStructurePercentage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FormViewServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    testReadFromFile(): Observable<DataTable> {
        let url_ = this.baseUrl + "/api/services/app/FormView/TestReadFromFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestReadFromFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestReadFromFile(<any>response_);
                } catch (e) {
                    return <Observable<DataTable>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataTable>><any>_observableThrow(response_);
        }));
    }

    protected processTestReadFromFile(response: HttpResponseBase): Observable<DataTable> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataTable.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataTable>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @param businessUnitId (optional) 
     * @param weeks (optional) 
     * @param month (optional) 
     * @param year (optional) 
     * @return Success
     */
    getAllFormSections(formId: number | undefined, businessUnitId: number | undefined, weeks: number[] | null | undefined, month: number | undefined, year: number | undefined): Observable<FormStructureDataDto> {
        let url_ = this.baseUrl + "/api/services/app/FormView/GetAllFormSections?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "BusinessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (weeks !== undefined && weeks !== null)
            weeks && weeks.forEach(item => { url_ += "Weeks=" + encodeURIComponent("" + item) + "&"; });
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFormSections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFormSections(<any>response_);
                } catch (e) {
                    return <Observable<FormStructureDataDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormStructureDataDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFormSections(response: HttpResponseBase): Observable<FormStructureDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormStructureDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormStructureDataDto>(<any>null);
    }

    /**
     * @param sectionId (optional) 
     * @param formId (optional) 
     * @param businessUnitId (optional) 
     * @param weeks (optional) 
     * @param month (optional) 
     * @param year (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCompressedSubSectionStructureAndData(sectionId: number | undefined, formId: number | undefined, businessUnitId: number | undefined, weeks: number[] | null | undefined, month: number | undefined, year: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/FormView/GetCompressedSubSectionStructureAndData?";
        if (sectionId === null)
            throw new Error("The parameter 'sectionId' cannot be null.");
        else if (sectionId !== undefined)
            url_ += "SectionId=" + encodeURIComponent("" + sectionId) + "&";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "BusinessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (weeks !== undefined && weeks !== null)
            weeks && weeks.forEach(item => { url_ += "Weeks=" + encodeURIComponent("" + item) + "&"; });
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompressedSubSectionStructureAndData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompressedSubSectionStructureAndData(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompressedSubSectionStructureAndData(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param sectionId (optional) 
     * @param formId (optional) 
     * @param businessUnitId (optional) 
     * @param weeks (optional) 
     * @param month (optional) 
     * @param year (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getFormStructureAndDataBySubSectionId(sectionId: number | undefined, formId: number | undefined, businessUnitId: number | undefined, weeks: number[] | null | undefined, month: number | undefined, year: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FormSubsectionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FormView/GetFormStructureAndDataBySubSectionId?";
        if (sectionId === null)
            throw new Error("The parameter 'sectionId' cannot be null.");
        else if (sectionId !== undefined)
            url_ += "SectionId=" + encodeURIComponent("" + sectionId) + "&";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (businessUnitId === null)
            throw new Error("The parameter 'businessUnitId' cannot be null.");
        else if (businessUnitId !== undefined)
            url_ += "BusinessUnitId=" + encodeURIComponent("" + businessUnitId) + "&";
        if (weeks !== undefined && weeks !== null)
            weeks && weeks.forEach(item => { url_ += "Weeks=" + encodeURIComponent("" + item) + "&"; });
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormStructureAndDataBySubSectionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormStructureAndDataBySubSectionId(<any>response_);
                } catch (e) {
                    return <Observable<FormSubsectionDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormSubsectionDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormStructureAndDataBySubSectionId(response: HttpResponseBase): Observable<FormSubsectionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormSubsectionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormSubsectionDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class PivotControlServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    pivotDataBuilder(body: GetPivotTableInput | undefined): Observable<CubeSchema[]> {
        let url_ = this.baseUrl + "/api/services/app/PivotControl/PivotDataBuilder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPivotDataBuilder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPivotDataBuilder(<any>response_);
                } catch (e) {
                    return <Observable<CubeSchema[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CubeSchema[]>><any>_observableThrow(response_);
        }));
    }

    protected processPivotDataBuilder(response: HttpResponseBase): Observable<CubeSchema[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CubeSchema.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CubeSchema[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    pivotTableHtml(body: PivotTableReportConfig | undefined): Observable<PivotTableBuilder> {
        let url_ = this.baseUrl + "/api/services/app/PivotControl/PivotTableHtml";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPivotTableHtml(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPivotTableHtml(<any>response_);
                } catch (e) {
                    return <Observable<PivotTableBuilder>><any>_observableThrow(e);
                }
            } else
                return <Observable<PivotTableBuilder>><any>_observableThrow(response_);
        }));
    }

    protected processPivotTableHtml(response: HttpResponseBase): Observable<PivotTableBuilder> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PivotTableBuilder.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PivotTableBuilder>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePivotQuery(body: CreateOrUpdatePivotQueryDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PivotControl/SavePivotQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePivotQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePivotQuery(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSavePivotQuery(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class PivotQueryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param query (optional) 
     * @return Success
     */
    getPivotData(query: string | null | undefined): Observable<QueryResultOutPutDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PivotQuery/GetPivotData?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPivotData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPivotData(<any>response_);
                } catch (e) {
                    return <Observable<QueryResultOutPutDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QueryResultOutPutDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPivotData(response: HttpResponseBase): Observable<QueryResultOutPutDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(QueryResultOutPutDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QueryResultOutPutDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDimension(): Observable<{ [key: string]: string[]; }> {
        let url_ = this.baseUrl + "/api/services/app/PivotQuery/GetDimension";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDimension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDimension(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: string[]; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: string[]; }>><any>_observableThrow(response_);
        }));
    }

    protected processGetDimension(response: HttpResponseBase): Observable<{ [key: string]: string[]; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key] !== undefined ? resultData200[key] : [];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string[]; }>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined && permission !== null)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: Int32EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUsers(): Observable<CustomUserDtoList[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<CustomUserDtoList[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomUserDtoList[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<CustomUserDtoList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomUserDtoList.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomUserDtoList[]>(<any>null);
    }

    /**
     * @param prefixText (optional) 
     * @return Success
     */
    getAllUsersByPrefix(prefixText: string | null | undefined): Observable<CustomUserDtoList[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllUsersByPrefix?";
        if (prefixText !== undefined && prefixText !== null)
            url_ += "prefixText=" + encodeURIComponent("" + prefixText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsersByPrefix(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsersByPrefix(<any>response_);
                } catch (e) {
                    return <Observable<CustomUserDtoList[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomUserDtoList[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsersByPrefix(response: HttpResponseBase): Observable<CustomUserDtoList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomUserDtoList.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomUserDtoList[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class UserFormServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param formId (optional) 
     * @param userId (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllUsersForms(formId: number | undefined, userId: number | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FormUsersGroupDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/UserForm/GetAllUsersForms?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "FormId=" + encodeURIComponent("" + formId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsersForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsersForms(<any>response_);
                } catch (e) {
                    return <Observable<FormUsersGroupDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormUsersGroupDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsersForms(response: HttpResponseBase): Observable<FormUsersGroupDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormUsersGroupDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormUsersGroupDtoPagedResultDto>(<any>null);
    }

    /**
     * @param forms (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getUserFormAssignmentsGroups(forms: TBL_Form[] | null | undefined, userId: number | undefined): Observable<FormUsersGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserForm/GetUserFormAssignmentsGroups?";
        if (forms !== undefined && forms !== null)
            forms && forms.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "forms[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserFormAssignmentsGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserFormAssignmentsGroups(<any>response_);
                } catch (e) {
                    return <Observable<FormUsersGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormUsersGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserFormAssignmentsGroups(response: HttpResponseBase): Observable<FormUsersGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormUsersGroupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormUsersGroupDto[]>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param isActive (optional) 
     * @param isPublished (optional) 
     * @param publishDate (optional) 
     * @param periodTypeId (optional) 
     * @param displayType (optional) 
     * @param statusId (optional) 
     * @param businessRoleId (optional) 
     * @param businessRole_TBL_Forms (optional) 
     * @param businessRole_IsDeleted (optional) 
     * @param businessRole_DeleterUserId (optional) 
     * @param businessRole_DeletionTime (optional) 
     * @param businessRole_LastModificationTime (optional) 
     * @param businessRole_LastModifierUserId (optional) 
     * @param businessRole_CreationTime (optional) 
     * @param businessRole_CreatorUserId (optional) 
     * @param businessRole_Id (optional) 
     * @param status_TBL_Forms (optional) 
     * @param status_IsDeleted (optional) 
     * @param status_DeleterUserId (optional) 
     * @param status_DeletionTime (optional) 
     * @param status_LastModificationTime (optional) 
     * @param status_LastModifierUserId (optional) 
     * @param status_CreationTime (optional) 
     * @param status_CreatorUserId (optional) 
     * @param status_Id (optional) 
     * @param periodType_TBL_Forms (optional) 
     * @param periodType_IsDeleted (optional) 
     * @param periodType_DeleterUserId (optional) 
     * @param periodType_DeletionTime (optional) 
     * @param periodType_LastModificationTime (optional) 
     * @param periodType_LastModifierUserId (optional) 
     * @param periodType_CreationTime (optional) 
     * @param periodType_CreatorUserId (optional) 
     * @param periodType_Id (optional) 
     * @param tBL_FormBusinessUnits (optional) 
     * @param tBL_FormStructureRows (optional) 
     * @param tBL_PivotQueries (optional) 
     * @param formName (optional) 
     * @param isDeleted (optional) 
     * @param deleterUserId (optional) 
     * @param deletionTime (optional) 
     * @param lastModificationTime (optional) 
     * @param lastModifierUserId (optional) 
     * @param creationTime (optional) 
     * @param creatorUserId (optional) 
     * @param id (optional) 
     * @param usersForm (optional) 
     * @return Success
     */
    getUserFormAssignmentsGroup(code: string | null | undefined, isActive: boolean | undefined, isPublished: boolean | undefined, publishDate: moment.Moment | null | undefined, periodTypeId: number | undefined, displayType: FormDisplayType | undefined, statusId: number | undefined, businessRoleId: number | undefined, businessRole_Title: string, businessRole_TBL_Forms: TBL_Form[] | null | undefined, businessRole_IsDeleted: boolean | undefined, businessRole_DeleterUserId: number | null | undefined, businessRole_DeletionTime: moment.Moment | null | undefined, businessRole_LastModificationTime: moment.Moment | null | undefined, businessRole_LastModifierUserId: number | null | undefined, businessRole_CreationTime: moment.Moment | undefined, businessRole_CreatorUserId: number | null | undefined, businessRole_Id: number | undefined, status_Status: string, status_TBL_Forms: TBL_Form[] | null | undefined, status_IsDeleted: boolean | undefined, status_DeleterUserId: number | null | undefined, status_DeletionTime: moment.Moment | null | undefined, status_LastModificationTime: moment.Moment | null | undefined, status_LastModifierUserId: number | null | undefined, status_CreationTime: moment.Moment | undefined, status_CreatorUserId: number | null | undefined, status_Id: number | undefined, periodType_Title: string, periodType_TBL_Forms: TBL_Form[] | null | undefined, periodType_IsDeleted: boolean | undefined, periodType_DeleterUserId: number | null | undefined, periodType_DeletionTime: moment.Moment | null | undefined, periodType_LastModificationTime: moment.Moment | null | undefined, periodType_LastModifierUserId: number | null | undefined, periodType_CreationTime: moment.Moment | undefined, periodType_CreatorUserId: number | null | undefined, periodType_Id: number | undefined, tBL_FormBusinessUnits: TBL_FormBusinessUnit[] | null | undefined, tBL_FormStructureRows: TBL_FormStructureRow[] | null | undefined, tBL_PivotQueries: TBL_PivotQuery[] | null | undefined, formName: string | null | undefined, isDeleted: boolean | undefined, deleterUserId: number | null | undefined, deletionTime: moment.Moment | null | undefined, lastModificationTime: moment.Moment | null | undefined, lastModifierUserId: number | null | undefined, creationTime: moment.Moment | undefined, creatorUserId: number | null | undefined, id: number | undefined, usersForm: TBL_UserForm[][] | null | undefined): Observable<FormUsersGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/UserForm/GetUserFormAssignmentsGroup?";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (isPublished === null)
            throw new Error("The parameter 'isPublished' cannot be null.");
        else if (isPublished !== undefined)
            url_ += "IsPublished=" + encodeURIComponent("" + isPublished) + "&";
        if (publishDate !== undefined && publishDate !== null)
            url_ += "PublishDate=" + encodeURIComponent(publishDate ? "" + publishDate.toJSON() : "") + "&";
        if (periodTypeId === null)
            throw new Error("The parameter 'periodTypeId' cannot be null.");
        else if (periodTypeId !== undefined)
            url_ += "PeriodTypeId=" + encodeURIComponent("" + periodTypeId) + "&";
        if (displayType === null)
            throw new Error("The parameter 'displayType' cannot be null.");
        else if (displayType !== undefined)
            url_ += "DisplayType=" + encodeURIComponent("" + displayType) + "&";
        if (statusId === null)
            throw new Error("The parameter 'statusId' cannot be null.");
        else if (statusId !== undefined)
            url_ += "StatusId=" + encodeURIComponent("" + statusId) + "&";
        if (businessRoleId === null)
            throw new Error("The parameter 'businessRoleId' cannot be null.");
        else if (businessRoleId !== undefined)
            url_ += "BusinessRoleId=" + encodeURIComponent("" + businessRoleId) + "&";
        if (businessRole_Title === undefined || businessRole_Title === null)
            throw new Error("The parameter 'businessRole_Title' must be defined and cannot be null.");
        else
            url_ += "BusinessRole.Title=" + encodeURIComponent("" + businessRole_Title) + "&";
        if (businessRole_TBL_Forms !== undefined && businessRole_TBL_Forms !== null)
            businessRole_TBL_Forms && businessRole_TBL_Forms.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "BusinessRole.TBL_Forms[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (businessRole_IsDeleted === null)
            throw new Error("The parameter 'businessRole_IsDeleted' cannot be null.");
        else if (businessRole_IsDeleted !== undefined)
            url_ += "BusinessRole.IsDeleted=" + encodeURIComponent("" + businessRole_IsDeleted) + "&";
        if (businessRole_DeleterUserId !== undefined && businessRole_DeleterUserId !== null)
            url_ += "BusinessRole.DeleterUserId=" + encodeURIComponent("" + businessRole_DeleterUserId) + "&";
        if (businessRole_DeletionTime !== undefined && businessRole_DeletionTime !== null)
            url_ += "BusinessRole.DeletionTime=" + encodeURIComponent(businessRole_DeletionTime ? "" + businessRole_DeletionTime.toJSON() : "") + "&";
        if (businessRole_LastModificationTime !== undefined && businessRole_LastModificationTime !== null)
            url_ += "BusinessRole.LastModificationTime=" + encodeURIComponent(businessRole_LastModificationTime ? "" + businessRole_LastModificationTime.toJSON() : "") + "&";
        if (businessRole_LastModifierUserId !== undefined && businessRole_LastModifierUserId !== null)
            url_ += "BusinessRole.LastModifierUserId=" + encodeURIComponent("" + businessRole_LastModifierUserId) + "&";
        if (businessRole_CreationTime === null)
            throw new Error("The parameter 'businessRole_CreationTime' cannot be null.");
        else if (businessRole_CreationTime !== undefined)
            url_ += "BusinessRole.CreationTime=" + encodeURIComponent(businessRole_CreationTime ? "" + businessRole_CreationTime.toJSON() : "") + "&";
        if (businessRole_CreatorUserId !== undefined && businessRole_CreatorUserId !== null)
            url_ += "BusinessRole.CreatorUserId=" + encodeURIComponent("" + businessRole_CreatorUserId) + "&";
        if (businessRole_Id === null)
            throw new Error("The parameter 'businessRole_Id' cannot be null.");
        else if (businessRole_Id !== undefined)
            url_ += "BusinessRole.Id=" + encodeURIComponent("" + businessRole_Id) + "&";
        if (status_Status === undefined || status_Status === null)
            throw new Error("The parameter 'status_Status' must be defined and cannot be null.");
        else
            url_ += "Status.Status=" + encodeURIComponent("" + status_Status) + "&";
        if (status_TBL_Forms !== undefined && status_TBL_Forms !== null)
            status_TBL_Forms && status_TBL_Forms.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Status.TBL_Forms[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (status_IsDeleted === null)
            throw new Error("The parameter 'status_IsDeleted' cannot be null.");
        else if (status_IsDeleted !== undefined)
            url_ += "Status.IsDeleted=" + encodeURIComponent("" + status_IsDeleted) + "&";
        if (status_DeleterUserId !== undefined && status_DeleterUserId !== null)
            url_ += "Status.DeleterUserId=" + encodeURIComponent("" + status_DeleterUserId) + "&";
        if (status_DeletionTime !== undefined && status_DeletionTime !== null)
            url_ += "Status.DeletionTime=" + encodeURIComponent(status_DeletionTime ? "" + status_DeletionTime.toJSON() : "") + "&";
        if (status_LastModificationTime !== undefined && status_LastModificationTime !== null)
            url_ += "Status.LastModificationTime=" + encodeURIComponent(status_LastModificationTime ? "" + status_LastModificationTime.toJSON() : "") + "&";
        if (status_LastModifierUserId !== undefined && status_LastModifierUserId !== null)
            url_ += "Status.LastModifierUserId=" + encodeURIComponent("" + status_LastModifierUserId) + "&";
        if (status_CreationTime === null)
            throw new Error("The parameter 'status_CreationTime' cannot be null.");
        else if (status_CreationTime !== undefined)
            url_ += "Status.CreationTime=" + encodeURIComponent(status_CreationTime ? "" + status_CreationTime.toJSON() : "") + "&";
        if (status_CreatorUserId !== undefined && status_CreatorUserId !== null)
            url_ += "Status.CreatorUserId=" + encodeURIComponent("" + status_CreatorUserId) + "&";
        if (status_Id === null)
            throw new Error("The parameter 'status_Id' cannot be null.");
        else if (status_Id !== undefined)
            url_ += "Status.Id=" + encodeURIComponent("" + status_Id) + "&";
        if (periodType_Title === undefined || periodType_Title === null)
            throw new Error("The parameter 'periodType_Title' must be defined and cannot be null.");
        else
            url_ += "PeriodType.Title=" + encodeURIComponent("" + periodType_Title) + "&";
        if (periodType_TBL_Forms !== undefined && periodType_TBL_Forms !== null)
            periodType_TBL_Forms && periodType_TBL_Forms.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "PeriodType.TBL_Forms[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (periodType_IsDeleted === null)
            throw new Error("The parameter 'periodType_IsDeleted' cannot be null.");
        else if (periodType_IsDeleted !== undefined)
            url_ += "PeriodType.IsDeleted=" + encodeURIComponent("" + periodType_IsDeleted) + "&";
        if (periodType_DeleterUserId !== undefined && periodType_DeleterUserId !== null)
            url_ += "PeriodType.DeleterUserId=" + encodeURIComponent("" + periodType_DeleterUserId) + "&";
        if (periodType_DeletionTime !== undefined && periodType_DeletionTime !== null)
            url_ += "PeriodType.DeletionTime=" + encodeURIComponent(periodType_DeletionTime ? "" + periodType_DeletionTime.toJSON() : "") + "&";
        if (periodType_LastModificationTime !== undefined && periodType_LastModificationTime !== null)
            url_ += "PeriodType.LastModificationTime=" + encodeURIComponent(periodType_LastModificationTime ? "" + periodType_LastModificationTime.toJSON() : "") + "&";
        if (periodType_LastModifierUserId !== undefined && periodType_LastModifierUserId !== null)
            url_ += "PeriodType.LastModifierUserId=" + encodeURIComponent("" + periodType_LastModifierUserId) + "&";
        if (periodType_CreationTime === null)
            throw new Error("The parameter 'periodType_CreationTime' cannot be null.");
        else if (periodType_CreationTime !== undefined)
            url_ += "PeriodType.CreationTime=" + encodeURIComponent(periodType_CreationTime ? "" + periodType_CreationTime.toJSON() : "") + "&";
        if (periodType_CreatorUserId !== undefined && periodType_CreatorUserId !== null)
            url_ += "PeriodType.CreatorUserId=" + encodeURIComponent("" + periodType_CreatorUserId) + "&";
        if (periodType_Id === null)
            throw new Error("The parameter 'periodType_Id' cannot be null.");
        else if (periodType_Id !== undefined)
            url_ += "PeriodType.Id=" + encodeURIComponent("" + periodType_Id) + "&";
        if (tBL_FormBusinessUnits !== undefined && tBL_FormBusinessUnits !== null)
            tBL_FormBusinessUnits && tBL_FormBusinessUnits.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "TBL_FormBusinessUnits[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tBL_FormStructureRows !== undefined && tBL_FormStructureRows !== null)
            tBL_FormStructureRows && tBL_FormStructureRows.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "TBL_FormStructureRows[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tBL_PivotQueries !== undefined && tBL_PivotQueries !== null)
            tBL_PivotQueries && tBL_PivotQueries.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "TBL_PivotQueries[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (formName !== undefined && formName !== null)
            url_ += "FormName=" + encodeURIComponent("" + formName) + "&";
        if (isDeleted === null)
            throw new Error("The parameter 'isDeleted' cannot be null.");
        else if (isDeleted !== undefined)
            url_ += "IsDeleted=" + encodeURIComponent("" + isDeleted) + "&";
        if (deleterUserId !== undefined && deleterUserId !== null)
            url_ += "DeleterUserId=" + encodeURIComponent("" + deleterUserId) + "&";
        if (deletionTime !== undefined && deletionTime !== null)
            url_ += "DeletionTime=" + encodeURIComponent(deletionTime ? "" + deletionTime.toJSON() : "") + "&";
        if (lastModificationTime !== undefined && lastModificationTime !== null)
            url_ += "LastModificationTime=" + encodeURIComponent(lastModificationTime ? "" + lastModificationTime.toJSON() : "") + "&";
        if (lastModifierUserId !== undefined && lastModifierUserId !== null)
            url_ += "LastModifierUserId=" + encodeURIComponent("" + lastModifierUserId) + "&";
        if (creationTime === null)
            throw new Error("The parameter 'creationTime' cannot be null.");
        else if (creationTime !== undefined)
            url_ += "CreationTime=" + encodeURIComponent(creationTime ? "" + creationTime.toJSON() : "") + "&";
        if (creatorUserId !== undefined && creatorUserId !== null)
            url_ += "CreatorUserId=" + encodeURIComponent("" + creatorUserId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (usersForm !== undefined && usersForm !== null)
            usersForm && usersForm.forEach(item => { url_ += "usersForm=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserFormAssignmentsGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserFormAssignmentsGroup(<any>response_);
                } catch (e) {
                    return <Observable<FormUsersGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormUsersGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserFormAssignmentsGroup(response: HttpResponseBase): Observable<FormUsersGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormUsersGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormUsersGroupDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserForms(userId: number): Observable<UserFormListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/UserForm/GetAllUserForms?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForms(<any>response_);
                } catch (e) {
                    return <Observable<UserFormListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserFormListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForms(response: HttpResponseBase): Observable<UserFormListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserFormListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserFormListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUpdateUserForm(body: CreateOrUpdateUserFormDto | undefined): Observable<FormUsersGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/UserForm/CreateUpdateUserForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUpdateUserForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUpdateUserForm(<any>response_);
                } catch (e) {
                    return <Observable<FormUsersGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormUsersGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUpdateUserForm(response: HttpResponseBase): Observable<FormUsersGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormUsersGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormUsersGroupDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUserForm(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserForm/DeleteUserForm?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserForm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserForm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteUserForms(body: DeleteUserFormsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserForm/DeleteUserForms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserForms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserForms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class ActivityFormListDto implements IActivityFormListDto {
    activityId: number | undefined;
    activityType: number | undefined;
    bestPractice: number | undefined;
    baseLine: number | undefined;
    historical: number | undefined;
    actual: number | undefined;
    target: number | undefined;
    actual_Growth_BP: number | undefined;
    required_Growth_BL: number | undefined;
    bL_Growth_Achievement: number | undefined;
    bP_Growth_Achievement: number | undefined;
    required_Growth_BP: number | undefined;
    actual_Growth_BL: number | undefined;
    formDataId: number;
    parentActivityId: number | undefined;
    id: number;

    constructor(data?: IActivityFormListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.activityType = _data["activityType"];
            this.bestPractice = _data["bestPractice"];
            this.baseLine = _data["baseLine"];
            this.historical = _data["historical"];
            this.actual = _data["actual"];
            this.target = _data["target"];
            this.actual_Growth_BP = _data["actual_Growth_BP"];
            this.required_Growth_BL = _data["required_Growth_BL"];
            this.bL_Growth_Achievement = _data["bL_Growth_Achievement"];
            this.bP_Growth_Achievement = _data["bP_Growth_Achievement"];
            this.required_Growth_BP = _data["required_Growth_BP"];
            this.actual_Growth_BL = _data["actual_Growth_BL"];
            this.formDataId = _data["formDataId"];
            this.parentActivityId = _data["parentActivityId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityFormListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFormListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["activityType"] = this.activityType;
        data["bestPractice"] = this.bestPractice;
        data["baseLine"] = this.baseLine;
        data["historical"] = this.historical;
        data["actual"] = this.actual;
        data["target"] = this.target;
        data["actual_Growth_BP"] = this.actual_Growth_BP;
        data["required_Growth_BL"] = this.required_Growth_BL;
        data["bL_Growth_Achievement"] = this.bL_Growth_Achievement;
        data["bP_Growth_Achievement"] = this.bP_Growth_Achievement;
        data["required_Growth_BP"] = this.required_Growth_BP;
        data["actual_Growth_BL"] = this.actual_Growth_BL;
        data["formDataId"] = this.formDataId;
        data["parentActivityId"] = this.parentActivityId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityFormListDto {
        const json = this.toJSON();
        let result = new ActivityFormListDto();
        result.init(json);
        return result;
    }
}

export interface IActivityFormListDto {
    activityId: number | undefined;
    activityType: number | undefined;
    bestPractice: number | undefined;
    baseLine: number | undefined;
    historical: number | undefined;
    actual: number | undefined;
    target: number | undefined;
    actual_Growth_BP: number | undefined;
    required_Growth_BL: number | undefined;
    bL_Growth_Achievement: number | undefined;
    bP_Growth_Achievement: number | undefined;
    required_Growth_BP: number | undefined;
    actual_Growth_BL: number | undefined;
    formDataId: number;
    parentActivityId: number | undefined;
    id: number;
}

export class ActivityFormListDtoPagedResultDto implements IActivityFormListDtoPagedResultDto {
    totalCount: number;
    items: ActivityFormListDto[] | undefined;

    constructor(data?: IActivityFormListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ActivityFormListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActivityFormListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFormListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ActivityFormListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ActivityFormListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IActivityFormListDtoPagedResultDto {
    totalCount: number;
    items: ActivityFormListDto[] | undefined;
}

export class ActivityFormDto implements IActivityFormDto {
    id: number;

    constructor(data?: IActivityFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ActivityFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityFormDto {
        const json = this.toJSON();
        let result = new ActivityFormDto();
        result.init(json);
        return result;
    }
}

export interface IActivityFormDto {
    id: number;
}

export enum ActivityType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ActivitiesCellDto implements IActivitiesCellDto {
    id: number;
    value: number;

    constructor(data?: IActivitiesCellDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ActivitiesCellDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivitiesCellDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data; 
    }

    clone(): ActivitiesCellDto {
        const json = this.toJSON();
        let result = new ActivitiesCellDto();
        result.init(json);
        return result;
    }
}

export interface IActivitiesCellDto {
    id: number;
    value: number;
}

export class UsersResultOutput implements IUsersResultOutput {
    id: number;
    userName: string | undefined;

    constructor(data?: IUsersResultOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UsersResultOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersResultOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): UsersResultOutput {
        const json = this.toJSON();
        let result = new UsersResultOutput();
        result.init(json);
        return result;
    }
}

export interface IUsersResultOutput {
    id: number;
    userName: string | undefined;
}

export class SubActivityFormDto implements ISubActivityFormDto {
    subActivityTitel: string | undefined;
    subActivityDueDate: moment.Moment | undefined;
    subActivityAssignees: UsersResultOutput[] | undefined;

    constructor(data?: ISubActivityFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subActivityTitel = _data["subActivityTitel"];
            this.subActivityDueDate = _data["subActivityDueDate"] ? moment(_data["subActivityDueDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["subActivityAssignees"])) {
                this.subActivityAssignees = [] as any;
                for (let item of _data["subActivityAssignees"])
                    this.subActivityAssignees.push(UsersResultOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubActivityFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubActivityFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subActivityTitel"] = this.subActivityTitel;
        data["subActivityDueDate"] = this.subActivityDueDate ? this.subActivityDueDate.toISOString() : <any>undefined;
        if (Array.isArray(this.subActivityAssignees)) {
            data["subActivityAssignees"] = [];
            for (let item of this.subActivityAssignees)
                data["subActivityAssignees"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SubActivityFormDto {
        const json = this.toJSON();
        let result = new SubActivityFormDto();
        result.init(json);
        return result;
    }
}

export interface ISubActivityFormDto {
    subActivityTitel: string | undefined;
    subActivityDueDate: moment.Moment | undefined;
    subActivityAssignees: UsersResultOutput[] | undefined;
}

export class ActivityFormEditDto implements IActivityFormEditDto {
    id: number | undefined;
    activityTitel: string | undefined;
    activityType: ActivityType;
    userLoginName: string | undefined;
    businessUnitId: number;
    startDate: moment.Moment;
    cells: ActivitiesCellDto[] | undefined;
    rowId: number;
    week: number;
    month: number;
    year: number;
    activityDescription: string | undefined;
    priorityId: number | undefined;
    activityFollowersID: number[] | undefined;
    activityAssigneesID: number[] | undefined;
    dueDate: moment.Moment | undefined;
    reminderDate: moment.Moment | undefined;
    subActivities: SubActivityFormDto[] | undefined;
    meetingOrganizerId: number | undefined;
    meetingLocation: string | undefined;
    meetingRequiredAttendees: number[] | undefined;
    meetingOptionalAttendees: number[] | undefined;
    meetingTimeFrom: string | undefined;
    meetingTimeTo: string | undefined;

    constructor(data?: IActivityFormEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.activityTitel = _data["activityTitel"];
            this.activityType = _data["activityType"];
            this.userLoginName = _data["userLoginName"];
            this.businessUnitId = _data["businessUnitId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["cells"])) {
                this.cells = [] as any;
                for (let item of _data["cells"])
                    this.cells.push(ActivitiesCellDto.fromJS(item));
            }
            this.rowId = _data["rowId"];
            this.week = _data["week"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.activityDescription = _data["activityDescription"];
            this.priorityId = _data["priorityId"];
            if (Array.isArray(_data["activityFollowersID"])) {
                this.activityFollowersID = [] as any;
                for (let item of _data["activityFollowersID"])
                    this.activityFollowersID.push(item);
            }
            if (Array.isArray(_data["activityAssigneesID"])) {
                this.activityAssigneesID = [] as any;
                for (let item of _data["activityAssigneesID"])
                    this.activityAssigneesID.push(item);
            }
            this.dueDate = _data["dueDate"] ? moment(_data["dueDate"].toString()) : <any>undefined;
            this.reminderDate = _data["reminderDate"] ? moment(_data["reminderDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["subActivities"])) {
                this.subActivities = [] as any;
                for (let item of _data["subActivities"])
                    this.subActivities.push(SubActivityFormDto.fromJS(item));
            }
            this.meetingOrganizerId = _data["meetingOrganizerId"];
            this.meetingLocation = _data["meetingLocation"];
            if (Array.isArray(_data["meetingRequiredAttendees"])) {
                this.meetingRequiredAttendees = [] as any;
                for (let item of _data["meetingRequiredAttendees"])
                    this.meetingRequiredAttendees.push(item);
            }
            if (Array.isArray(_data["meetingOptionalAttendees"])) {
                this.meetingOptionalAttendees = [] as any;
                for (let item of _data["meetingOptionalAttendees"])
                    this.meetingOptionalAttendees.push(item);
            }
            this.meetingTimeFrom = _data["meetingTimeFrom"];
            this.meetingTimeTo = _data["meetingTimeTo"];
        }
    }

    static fromJS(data: any): ActivityFormEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityFormEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityTitel"] = this.activityTitel;
        data["activityType"] = this.activityType;
        data["userLoginName"] = this.userLoginName;
        data["businessUnitId"] = this.businessUnitId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        if (Array.isArray(this.cells)) {
            data["cells"] = [];
            for (let item of this.cells)
                data["cells"].push(item.toJSON());
        }
        data["rowId"] = this.rowId;
        data["week"] = this.week;
        data["month"] = this.month;
        data["year"] = this.year;
        data["activityDescription"] = this.activityDescription;
        data["priorityId"] = this.priorityId;
        if (Array.isArray(this.activityFollowersID)) {
            data["activityFollowersID"] = [];
            for (let item of this.activityFollowersID)
                data["activityFollowersID"].push(item);
        }
        if (Array.isArray(this.activityAssigneesID)) {
            data["activityAssigneesID"] = [];
            for (let item of this.activityAssigneesID)
                data["activityAssigneesID"].push(item);
        }
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["reminderDate"] = this.reminderDate ? this.reminderDate.toISOString() : <any>undefined;
        if (Array.isArray(this.subActivities)) {
            data["subActivities"] = [];
            for (let item of this.subActivities)
                data["subActivities"].push(item.toJSON());
        }
        data["meetingOrganizerId"] = this.meetingOrganizerId;
        data["meetingLocation"] = this.meetingLocation;
        if (Array.isArray(this.meetingRequiredAttendees)) {
            data["meetingRequiredAttendees"] = [];
            for (let item of this.meetingRequiredAttendees)
                data["meetingRequiredAttendees"].push(item);
        }
        if (Array.isArray(this.meetingOptionalAttendees)) {
            data["meetingOptionalAttendees"] = [];
            for (let item of this.meetingOptionalAttendees)
                data["meetingOptionalAttendees"].push(item);
        }
        data["meetingTimeFrom"] = this.meetingTimeFrom;
        data["meetingTimeTo"] = this.meetingTimeTo;
        return data; 
    }

    clone(): ActivityFormEditDto {
        const json = this.toJSON();
        let result = new ActivityFormEditDto();
        result.init(json);
        return result;
    }
}

export interface IActivityFormEditDto {
    id: number | undefined;
    activityTitel: string | undefined;
    activityType: ActivityType;
    userLoginName: string | undefined;
    businessUnitId: number;
    startDate: moment.Moment;
    cells: ActivitiesCellDto[] | undefined;
    rowId: number;
    week: number;
    month: number;
    year: number;
    activityDescription: string | undefined;
    priorityId: number | undefined;
    activityFollowersID: number[] | undefined;
    activityAssigneesID: number[] | undefined;
    dueDate: moment.Moment | undefined;
    reminderDate: moment.Moment | undefined;
    subActivities: SubActivityFormDto[] | undefined;
    meetingOrganizerId: number | undefined;
    meetingLocation: string | undefined;
    meetingRequiredAttendees: number[] | undefined;
    meetingOptionalAttendees: number[] | undefined;
    meetingTimeFrom: string | undefined;
    meetingTimeTo: string | undefined;
}

export class GetActivityFormEditOutput implements IGetActivityFormEditOutput {
    activityForm: ActivityFormEditDto;

    constructor(data?: IGetActivityFormEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityForm = _data["activityForm"] ? ActivityFormEditDto.fromJS(_data["activityForm"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetActivityFormEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityFormEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityForm"] = this.activityForm ? this.activityForm.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetActivityFormEditOutput {
        const json = this.toJSON();
        let result = new GetActivityFormEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetActivityFormEditOutput {
    activityForm: ActivityFormEditDto;
}

export class BUResultOutput implements IBUResultOutput {
    id: number;
    value: string | undefined;

    constructor(data?: IBUResultOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BUResultOutput {
        data = typeof data === 'object' ? data : {};
        let result = new BUResultOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data; 
    }

    clone(): BUResultOutput {
        const json = this.toJSON();
        let result = new BUResultOutput();
        result.init(json);
        return result;
    }
}

export interface IBUResultOutput {
    id: number;
    value: string | undefined;
}

export class CreateOrUpdateActivityFormDto implements ICreateOrUpdateActivityFormDto {
    activityForm: ActivityFormEditDto;

    constructor(data?: ICreateOrUpdateActivityFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityForm = _data["activityForm"] ? ActivityFormEditDto.fromJS(_data["activityForm"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateActivityFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateActivityFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityForm"] = this.activityForm ? this.activityForm.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateActivityFormDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateActivityFormDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateActivityFormDto {
    activityForm: ActivityFormEditDto;
}

export class NewActivitiesDto implements INewActivitiesDto {
    activitiesIds: number[] | undefined;

    constructor(data?: INewActivitiesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["activitiesIds"])) {
                this.activitiesIds = [] as any;
                for (let item of _data["activitiesIds"])
                    this.activitiesIds.push(item);
            }
        }
    }

    static fromJS(data: any): NewActivitiesDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewActivitiesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.activitiesIds)) {
            data["activitiesIds"] = [];
            for (let item of this.activitiesIds)
                data["activitiesIds"].push(item);
        }
        return data; 
    }

    clone(): NewActivitiesDto {
        const json = this.toJSON();
        let result = new NewActivitiesDto();
        result.init(json);
        return result;
    }
}

export interface INewActivitiesDto {
    activitiesIds: number[] | undefined;
}

export class ActivityDetailsForForm implements IActivityDetailsForForm {
    activityName: string | undefined;
    activityType: string | undefined;
    startDate: string | undefined;
    dueDate: string | undefined;
    owner: string | undefined;
    assignees: string[] | undefined;
    followers: string[] | undefined;

    constructor(data?: IActivityDetailsForForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityName = _data["activityName"];
            this.activityType = _data["activityType"];
            this.startDate = _data["startDate"];
            this.dueDate = _data["dueDate"];
            this.owner = _data["owner"];
            if (Array.isArray(_data["assignees"])) {
                this.assignees = [] as any;
                for (let item of _data["assignees"])
                    this.assignees.push(item);
            }
            if (Array.isArray(_data["followers"])) {
                this.followers = [] as any;
                for (let item of _data["followers"])
                    this.followers.push(item);
            }
        }
    }

    static fromJS(data: any): ActivityDetailsForForm {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDetailsForForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityName"] = this.activityName;
        data["activityType"] = this.activityType;
        data["startDate"] = this.startDate;
        data["dueDate"] = this.dueDate;
        data["owner"] = this.owner;
        if (Array.isArray(this.assignees)) {
            data["assignees"] = [];
            for (let item of this.assignees)
                data["assignees"].push(item);
        }
        if (Array.isArray(this.followers)) {
            data["followers"] = [];
            for (let item of this.followers)
                data["followers"].push(item);
        }
        return data; 
    }

    clone(): ActivityDetailsForForm {
        const json = this.toJSON();
        let result = new ActivityDetailsForForm();
        result.init(json);
        return result;
    }
}

export interface IActivityDetailsForForm {
    activityName: string | undefined;
    activityType: string | undefined;
    startDate: string | undefined;
    dueDate: string | undefined;
    owner: string | undefined;
    assignees: string[] | undefined;
    followers: string[] | undefined;
}

export class MeetingDetailsForForm implements IMeetingDetailsForForm {
    meetingName: string | undefined;
    location: string | undefined;
    startDate: string | undefined;
    timeFrom: string | undefined;
    timeTo: string | undefined;
    organizer: string | undefined;
    attendees: string[] | undefined;

    constructor(data?: IMeetingDetailsForForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.meetingName = _data["meetingName"];
            this.location = _data["location"];
            this.startDate = _data["startDate"];
            this.timeFrom = _data["timeFrom"];
            this.timeTo = _data["timeTo"];
            this.organizer = _data["organizer"];
            if (Array.isArray(_data["attendees"])) {
                this.attendees = [] as any;
                for (let item of _data["attendees"])
                    this.attendees.push(item);
            }
        }
    }

    static fromJS(data: any): MeetingDetailsForForm {
        data = typeof data === 'object' ? data : {};
        let result = new MeetingDetailsForForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["meetingName"] = this.meetingName;
        data["location"] = this.location;
        data["startDate"] = this.startDate;
        data["timeFrom"] = this.timeFrom;
        data["timeTo"] = this.timeTo;
        data["organizer"] = this.organizer;
        if (Array.isArray(this.attendees)) {
            data["attendees"] = [];
            for (let item of this.attendees)
                data["attendees"].push(item);
        }
        return data; 
    }

    clone(): MeetingDetailsForForm {
        const json = this.toJSON();
        let result = new MeetingDetailsForForm();
        result.init(json);
        return result;
    }
}

export interface IMeetingDetailsForForm {
    meetingName: string | undefined;
    location: string | undefined;
    startDate: string | undefined;
    timeFrom: string | undefined;
    timeTo: string | undefined;
    organizer: string | undefined;
    attendees: string[] | undefined;
}

export class BusinessRoleDto implements IBusinessRoleDto {
    title: string | undefined;
    id: number;

    constructor(data?: IBusinessRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["id"] = this.id;
        return data; 
    }

    clone(): BusinessRoleDto {
        const json = this.toJSON();
        let result = new BusinessRoleDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessRoleDto {
    title: string | undefined;
    id: number;
}

export class BusinessRoleListDto implements IBusinessRoleListDto {
    title: string | undefined;
    id: number;

    constructor(data?: IBusinessRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["id"] = this.id;
        return data; 
    }

    clone(): BusinessRoleListDto {
        const json = this.toJSON();
        let result = new BusinessRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessRoleListDto {
    title: string | undefined;
    id: number;
}

export class BusinessRoleListDtoPagedResultDto implements IBusinessRoleListDtoPagedResultDto {
    totalCount: number;
    items: BusinessRoleListDto[] | undefined;

    constructor(data?: IBusinessRoleListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BusinessRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BusinessRoleListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRoleListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BusinessRoleListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BusinessRoleListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessRoleListDtoPagedResultDto {
    totalCount: number;
    items: BusinessRoleListDto[] | undefined;
}

export class BusinessRoleEditDto implements IBusinessRoleEditDto {
    id: number | undefined;
    title: string | undefined;

    constructor(data?: IBusinessRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): BusinessRoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }

    clone(): BusinessRoleEditDto {
        const json = this.toJSON();
        let result = new BusinessRoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessRoleEditDto {
    id: number | undefined;
    title: string | undefined;
}

export class GetBusinessRoleEditOutput implements IGetBusinessRoleEditOutput {
    businessRole: BusinessRoleEditDto;

    constructor(data?: IGetBusinessRoleEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessRole = _data["businessRole"] ? BusinessRoleEditDto.fromJS(_data["businessRole"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBusinessRoleEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessRoleEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessRole"] = this.businessRole ? this.businessRole.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetBusinessRoleEditOutput {
        const json = this.toJSON();
        let result = new GetBusinessRoleEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBusinessRoleEditOutput {
    businessRole: BusinessRoleEditDto;
}

export class CreateOrUpdateBusinessRoleDto implements ICreateOrUpdateBusinessRoleDto {
    businessRole: BusinessRoleEditDto;

    constructor(data?: ICreateOrUpdateBusinessRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessRole = _data["businessRole"] ? BusinessRoleEditDto.fromJS(_data["businessRole"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateBusinessRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBusinessRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessRole"] = this.businessRole ? this.businessRole.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateBusinessRoleDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateBusinessRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateBusinessRoleDto {
    businessRole: BusinessRoleEditDto;
}

export class BusinessUnitListDto implements IBusinessUnitListDto {
    businessUnitId: number;
    businessUnitTitle: string | undefined;

    constructor(data?: IBusinessUnitListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessUnitId = _data["businessUnitId"];
            this.businessUnitTitle = _data["businessUnitTitle"];
        }
    }

    static fromJS(data: any): BusinessUnitListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUnitListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessUnitId"] = this.businessUnitId;
        data["businessUnitTitle"] = this.businessUnitTitle;
        return data; 
    }

    clone(): BusinessUnitListDto {
        const json = this.toJSON();
        let result = new BusinessUnitListDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessUnitListDto {
    businessUnitId: number;
    businessUnitTitle: string | undefined;
}

export class BusinessUnitListDtoPagedResultDto implements IBusinessUnitListDtoPagedResultDto {
    totalCount: number;
    items: BusinessUnitListDto[] | undefined;

    constructor(data?: IBusinessUnitListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BusinessUnitListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BusinessUnitListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUnitListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BusinessUnitListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BusinessUnitListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessUnitListDtoPagedResultDto {
    totalCount: number;
    items: BusinessUnitListDto[] | undefined;
}

export class BusinessUnitDto implements IBusinessUnitDto {
    title: string | undefined;
    shortTitle: string | undefined;
    bindLabel: string | undefined;
    id: number;

    constructor(data?: IBusinessUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.shortTitle = _data["shortTitle"];
            this.bindLabel = _data["bindLabel"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["shortTitle"] = this.shortTitle;
        data["bindLabel"] = this.bindLabel;
        data["id"] = this.id;
        return data; 
    }

    clone(): BusinessUnitDto {
        const json = this.toJSON();
        let result = new BusinessUnitDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessUnitDto {
    title: string | undefined;
    shortTitle: string | undefined;
    bindLabel: string | undefined;
    id: number;
}

export class BusinessUnitEditDto implements IBusinessUnitEditDto {
    id: number | undefined;
    title: string | undefined;

    constructor(data?: IBusinessUnitEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): BusinessUnitEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUnitEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }

    clone(): BusinessUnitEditDto {
        const json = this.toJSON();
        let result = new BusinessUnitEditDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessUnitEditDto {
    id: number | undefined;
    title: string | undefined;
}

export class GetBusinessUnitEditOutput implements IGetBusinessUnitEditOutput {
    businessUnit: BusinessUnitEditDto;

    constructor(data?: IGetBusinessUnitEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessUnit = _data["businessUnit"] ? BusinessUnitEditDto.fromJS(_data["businessUnit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBusinessUnitEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessUnitEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessUnit"] = this.businessUnit ? this.businessUnit.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetBusinessUnitEditOutput {
        const json = this.toJSON();
        let result = new GetBusinessUnitEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBusinessUnitEditOutput {
    businessUnit: BusinessUnitEditDto;
}

export class CreateOrUpdateBusinessUnitDto implements ICreateOrUpdateBusinessUnitDto {
    businessUnit: BusinessUnitEditDto;

    constructor(data?: ICreateOrUpdateBusinessUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessUnit = _data["businessUnit"] ? BusinessUnitEditDto.fromJS(_data["businessUnit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateBusinessUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBusinessUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessUnit"] = this.businessUnit ? this.businessUnit.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateBusinessUnitDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateBusinessUnitDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateBusinessUnitDto {
    businessUnit: BusinessUnitEditDto;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class CubeQueryMappingListDto implements ICubeQueryMappingListDto {
    id: number;

    constructor(data?: ICubeQueryMappingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubeQueryMappingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubeQueryMappingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): CubeQueryMappingListDto {
        const json = this.toJSON();
        let result = new CubeQueryMappingListDto();
        result.init(json);
        return result;
    }
}

export interface ICubeQueryMappingListDto {
    id: number;
}

export class CubeQueryMappingListDtoPagedResultDto implements ICubeQueryMappingListDtoPagedResultDto {
    totalCount: number;
    items: CubeQueryMappingListDto[] | undefined;

    constructor(data?: ICubeQueryMappingListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CubeQueryMappingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CubeQueryMappingListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubeQueryMappingListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CubeQueryMappingListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CubeQueryMappingListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICubeQueryMappingListDtoPagedResultDto {
    totalCount: number;
    items: CubeQueryMappingListDto[] | undefined;
}

export class CubeQueryMappingDto implements ICubeQueryMappingDto {
    id: number;

    constructor(data?: ICubeQueryMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubeQueryMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubeQueryMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): CubeQueryMappingDto {
        const json = this.toJSON();
        let result = new CubeQueryMappingDto();
        result.init(json);
        return result;
    }
}

export interface ICubeQueryMappingDto {
    id: number;
}

export class CubeQueryMappingEditDto implements ICubeQueryMappingEditDto {
    id: number | undefined;

    constructor(data?: ICubeQueryMappingEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CubeQueryMappingEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CubeQueryMappingEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): CubeQueryMappingEditDto {
        const json = this.toJSON();
        let result = new CubeQueryMappingEditDto();
        result.init(json);
        return result;
    }
}

export interface ICubeQueryMappingEditDto {
    id: number | undefined;
}

export class GetCubeQueryMappingEditOutput implements IGetCubeQueryMappingEditOutput {
    cubeQueryMapping: CubeQueryMappingEditDto;

    constructor(data?: IGetCubeQueryMappingEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubeQueryMapping = _data["cubeQueryMapping"] ? CubeQueryMappingEditDto.fromJS(_data["cubeQueryMapping"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCubeQueryMappingEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCubeQueryMappingEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubeQueryMapping"] = this.cubeQueryMapping ? this.cubeQueryMapping.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCubeQueryMappingEditOutput {
        const json = this.toJSON();
        let result = new GetCubeQueryMappingEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCubeQueryMappingEditOutput {
    cubeQueryMapping: CubeQueryMappingEditDto;
}

export class CreateOrUpdateCubeQueryMappingDto implements ICreateOrUpdateCubeQueryMappingDto {
    cubeQueryMapping: CubeQueryMappingEditDto;

    constructor(data?: ICreateOrUpdateCubeQueryMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubeQueryMapping = _data["cubeQueryMapping"] ? CubeQueryMappingEditDto.fromJS(_data["cubeQueryMapping"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateCubeQueryMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateCubeQueryMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubeQueryMapping"] = this.cubeQueryMapping ? this.cubeQueryMapping.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateCubeQueryMappingDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateCubeQueryMappingDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateCubeQueryMappingDto {
    cubeQueryMapping: CubeQueryMappingEditDto;
}

export class FormListDto implements IFormListDto {
    formId: number;
    formName: string | undefined;
    businessRoleId: number;
    formTypeID: number;

    constructor(data?: IFormListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.formName = _data["formName"];
            this.businessRoleId = _data["businessRoleId"];
            this.formTypeID = _data["formTypeID"];
        }
    }

    static fromJS(data: any): FormListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["formName"] = this.formName;
        data["businessRoleId"] = this.businessRoleId;
        data["formTypeID"] = this.formTypeID;
        return data; 
    }

    clone(): FormListDto {
        const json = this.toJSON();
        let result = new FormListDto();
        result.init(json);
        return result;
    }
}

export interface IFormListDto {
    formId: number;
    formName: string | undefined;
    businessRoleId: number;
    formTypeID: number;
}

export class FormRoleListDto implements IFormRoleListDto {
    formId: number;
    formTypeId: number | undefined;
    formStatusId: number | undefined;
    formDisplayId: number;
    roleName: string | undefined;
    formType: string | undefined;
    formStatus: string | undefined;
    formCode: string | undefined;
    businessUnits: BusinessUnitListDto[] | undefined;

    constructor(data?: IFormRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.formTypeId = _data["formTypeId"];
            this.formStatusId = _data["formStatusId"];
            this.formDisplayId = _data["formDisplayId"];
            this.roleName = _data["roleName"];
            this.formType = _data["formType"];
            this.formStatus = _data["formStatus"];
            this.formCode = _data["formCode"];
            if (Array.isArray(_data["businessUnits"])) {
                this.businessUnits = [] as any;
                for (let item of _data["businessUnits"])
                    this.businessUnits.push(BusinessUnitListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["formTypeId"] = this.formTypeId;
        data["formStatusId"] = this.formStatusId;
        data["formDisplayId"] = this.formDisplayId;
        data["roleName"] = this.roleName;
        data["formType"] = this.formType;
        data["formStatus"] = this.formStatus;
        data["formCode"] = this.formCode;
        if (Array.isArray(this.businessUnits)) {
            data["businessUnits"] = [];
            for (let item of this.businessUnits)
                data["businessUnits"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FormRoleListDto {
        const json = this.toJSON();
        let result = new FormRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IFormRoleListDto {
    formId: number;
    formTypeId: number | undefined;
    formStatusId: number | undefined;
    formDisplayId: number;
    roleName: string | undefined;
    formType: string | undefined;
    formStatus: string | undefined;
    formCode: string | undefined;
    businessUnits: BusinessUnitListDto[] | undefined;
}

export class FormRoleListDtoPagedResultDto implements IFormRoleListDtoPagedResultDto {
    totalCount: number;
    items: FormRoleListDto[] | undefined;

    constructor(data?: IFormRoleListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FormRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormRoleListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormRoleListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FormRoleListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FormRoleListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFormRoleListDtoPagedResultDto {
    totalCount: number;
    items: FormRoleListDto[] | undefined;
}

export class BusinessFormDto implements IBusinessFormDto {
    businessUnitId: number;
    formId: number;
    id: number;

    constructor(data?: IBusinessFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessUnitId = _data["businessUnitId"];
            this.formId = _data["formId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessUnitId"] = this.businessUnitId;
        data["formId"] = this.formId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BusinessFormDto {
        const json = this.toJSON();
        let result = new BusinessFormDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessFormDto {
    businessUnitId: number;
    formId: number;
    id: number;
}

export class SectionTypeDto implements ISectionTypeDto {
    title: string | undefined;
    isParent: boolean;
    id: number;

    constructor(data?: ISectionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.isParent = _data["isParent"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SectionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SectionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["isParent"] = this.isParent;
        data["id"] = this.id;
        return data; 
    }

    clone(): SectionTypeDto {
        const json = this.toJSON();
        let result = new SectionTypeDto();
        result.init(json);
        return result;
    }
}

export interface ISectionTypeDto {
    title: string | undefined;
    isParent: boolean;
    id: number;
}

export class FormColumnTypeDto implements IFormColumnTypeDto {
    columnType: string | undefined;
    attributeName: string | undefined;
    id: number;

    constructor(data?: IFormColumnTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.columnType = _data["columnType"];
            this.attributeName = _data["attributeName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormColumnTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormColumnTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columnType"] = this.columnType;
        data["attributeName"] = this.attributeName;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormColumnTypeDto {
        const json = this.toJSON();
        let result = new FormColumnTypeDto();
        result.init(json);
        return result;
    }
}

export interface IFormColumnTypeDto {
    columnType: string | undefined;
    attributeName: string | undefined;
    id: number;
}

export class FormColumnDto implements IFormColumnDto {
    header: string | undefined;
    order: number;
    isDefault: boolean;
    bindingSource: string | undefined;
    sectionId: number;
    indicatorId: number | undefined;
    formColumnTypeId: number;
    formColumnTemplateId: number | undefined;
    businessRuleId: number | undefined;
    formColumnType: FormColumnTypeDto;
    id: number;

    constructor(data?: IFormColumnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"];
            this.order = _data["order"];
            this.isDefault = _data["isDefault"];
            this.bindingSource = _data["bindingSource"];
            this.sectionId = _data["sectionId"];
            this.indicatorId = _data["indicatorId"];
            this.formColumnTypeId = _data["formColumnTypeId"];
            this.formColumnTemplateId = _data["formColumnTemplateId"];
            this.businessRuleId = _data["businessRuleId"];
            this.formColumnType = _data["formColumnType"] ? FormColumnTypeDto.fromJS(_data["formColumnType"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormColumnDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormColumnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header;
        data["order"] = this.order;
        data["isDefault"] = this.isDefault;
        data["bindingSource"] = this.bindingSource;
        data["sectionId"] = this.sectionId;
        data["indicatorId"] = this.indicatorId;
        data["formColumnTypeId"] = this.formColumnTypeId;
        data["formColumnTemplateId"] = this.formColumnTemplateId;
        data["businessRuleId"] = this.businessRuleId;
        data["formColumnType"] = this.formColumnType ? this.formColumnType.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormColumnDto {
        const json = this.toJSON();
        let result = new FormColumnDto();
        result.init(json);
        return result;
    }
}

export interface IFormColumnDto {
    header: string | undefined;
    order: number;
    isDefault: boolean;
    bindingSource: string | undefined;
    sectionId: number;
    indicatorId: number | undefined;
    formColumnTypeId: number;
    formColumnTemplateId: number | undefined;
    businessRuleId: number | undefined;
    formColumnType: FormColumnTypeDto;
    id: number;
}

export class IndicatorTypeDto implements IIndicatorTypeDto {
    title: string | undefined;
    displayName: string | undefined;
    kpiCode: string | undefined;
    id: number;

    constructor(data?: IIndicatorTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.displayName = _data["displayName"];
            this.kpiCode = _data["kpiCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IndicatorTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndicatorTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["displayName"] = this.displayName;
        data["kpiCode"] = this.kpiCode;
        data["id"] = this.id;
        return data; 
    }

    clone(): IndicatorTypeDto {
        const json = this.toJSON();
        let result = new IndicatorTypeDto();
        result.init(json);
        return result;
    }
}

export interface IIndicatorTypeDto {
    title: string | undefined;
    displayName: string | undefined;
    kpiCode: string | undefined;
    id: number;
}

export class FormCellDto implements IFormCellDto {
    formRowId: number;
    formColumnId: number;
    formCellTypeId: number;
    formColumnBindingSource: string | undefined;
    id: number;

    constructor(data?: IFormCellDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formRowId = _data["formRowId"];
            this.formColumnId = _data["formColumnId"];
            this.formCellTypeId = _data["formCellTypeId"];
            this.formColumnBindingSource = _data["formColumnBindingSource"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormCellDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormCellDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formRowId"] = this.formRowId;
        data["formColumnId"] = this.formColumnId;
        data["formCellTypeId"] = this.formCellTypeId;
        data["formColumnBindingSource"] = this.formColumnBindingSource;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormCellDto {
        const json = this.toJSON();
        let result = new FormCellDto();
        result.init(json);
        return result;
    }
}

export interface IFormCellDto {
    formRowId: number;
    formColumnId: number;
    formCellTypeId: number;
    formColumnBindingSource: string | undefined;
    id: number;
}

export class FormRowDto implements IFormRowDto {
    header: string | undefined;
    order: number;
    formRowTypeId: number;
    dimentionId: number | undefined;
    indicatorId: number | undefined;
    rowCells: FormCellDto[] | undefined;
    id: number;

    constructor(data?: IFormRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"];
            this.order = _data["order"];
            this.formRowTypeId = _data["formRowTypeId"];
            this.dimentionId = _data["dimentionId"];
            this.indicatorId = _data["indicatorId"];
            if (Array.isArray(_data["rowCells"])) {
                this.rowCells = [] as any;
                for (let item of _data["rowCells"])
                    this.rowCells.push(FormCellDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormRowDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header;
        data["order"] = this.order;
        data["formRowTypeId"] = this.formRowTypeId;
        data["dimentionId"] = this.dimentionId;
        data["indicatorId"] = this.indicatorId;
        if (Array.isArray(this.rowCells)) {
            data["rowCells"] = [];
            for (let item of this.rowCells)
                data["rowCells"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): FormRowDto {
        const json = this.toJSON();
        let result = new FormRowDto();
        result.init(json);
        return result;
    }
}

export interface IFormRowDto {
    header: string | undefined;
    order: number;
    formRowTypeId: number;
    dimentionId: number | undefined;
    indicatorId: number | undefined;
    rowCells: FormCellDto[] | undefined;
    id: number;
}

export class TBL_BusinessRule implements ITBL_BusinessRule {
    ruleDescription: string | undefined;
    ruleId: string;
    ruleName: string | undefined;
    order: number;
    tbL_FormStructureColumns: TBL_FormStructureColumn[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_BusinessRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleDescription = _data["ruleDescription"];
            this.ruleId = _data["ruleId"];
            this.ruleName = _data["ruleName"];
            this.order = _data["order"];
            if (Array.isArray(_data["tbL_FormStructureColumns"])) {
                this.tbL_FormStructureColumns = [] as any;
                for (let item of _data["tbL_FormStructureColumns"])
                    this.tbL_FormStructureColumns.push(TBL_FormStructureColumn.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_BusinessRule {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_BusinessRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleDescription"] = this.ruleDescription;
        data["ruleId"] = this.ruleId;
        data["ruleName"] = this.ruleName;
        data["order"] = this.order;
        if (Array.isArray(this.tbL_FormStructureColumns)) {
            data["tbL_FormStructureColumns"] = [];
            for (let item of this.tbL_FormStructureColumns)
                data["tbL_FormStructureColumns"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_BusinessRule {
        const json = this.toJSON();
        let result = new TBL_BusinessRule();
        result.init(json);
        return result;
    }
}

export interface ITBL_BusinessRule {
    ruleDescription: string | undefined;
    ruleId: string;
    ruleName: string | undefined;
    order: number;
    tbL_FormStructureColumns: TBL_FormStructureColumn[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class LKP_StructureColumn implements ILKP_StructureColumn {
    title: string;
    bindSource: string;
    isDefault: boolean;
    tbL_FormStructureColumns: TBL_FormStructureColumn[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ILKP_StructureColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.bindSource = _data["bindSource"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["tbL_FormStructureColumns"])) {
                this.tbL_FormStructureColumns = [] as any;
                for (let item of _data["tbL_FormStructureColumns"])
                    this.tbL_FormStructureColumns.push(TBL_FormStructureColumn.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LKP_StructureColumn {
        data = typeof data === 'object' ? data : {};
        let result = new LKP_StructureColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["bindSource"] = this.bindSource;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.tbL_FormStructureColumns)) {
            data["tbL_FormStructureColumns"] = [];
            for (let item of this.tbL_FormStructureColumns)
                data["tbL_FormStructureColumns"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LKP_StructureColumn {
        const json = this.toJSON();
        let result = new LKP_StructureColumn();
        result.init(json);
        return result;
    }
}

export interface ILKP_StructureColumn {
    title: string;
    bindSource: string;
    isDefault: boolean;
    tbL_FormStructureColumns: TBL_FormStructureColumn[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum FormDisplayType {
    _1 = 1,
    _2 = 2,
}

export class LKP_BusinessRole implements ILKP_BusinessRole {
    title: string;
    tbL_Forms: TBL_Form[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ILKP_BusinessRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["tbL_Forms"])) {
                this.tbL_Forms = [] as any;
                for (let item of _data["tbL_Forms"])
                    this.tbL_Forms.push(TBL_Form.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LKP_BusinessRole {
        data = typeof data === 'object' ? data : {};
        let result = new LKP_BusinessRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.tbL_Forms)) {
            data["tbL_Forms"] = [];
            for (let item of this.tbL_Forms)
                data["tbL_Forms"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LKP_BusinessRole {
        const json = this.toJSON();
        let result = new LKP_BusinessRole();
        result.init(json);
        return result;
    }
}

export interface ILKP_BusinessRole {
    title: string;
    tbL_Forms: TBL_Form[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class LKP_FormStatus implements ILKP_FormStatus {
    status: string;
    tbL_Forms: TBL_Form[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ILKP_FormStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            if (Array.isArray(_data["tbL_Forms"])) {
                this.tbL_Forms = [] as any;
                for (let item of _data["tbL_Forms"])
                    this.tbL_Forms.push(TBL_Form.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LKP_FormStatus {
        data = typeof data === 'object' ? data : {};
        let result = new LKP_FormStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        if (Array.isArray(this.tbL_Forms)) {
            data["tbL_Forms"] = [];
            for (let item of this.tbL_Forms)
                data["tbL_Forms"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LKP_FormStatus {
        const json = this.toJSON();
        let result = new LKP_FormStatus();
        result.init(json);
        return result;
    }
}

export interface ILKP_FormStatus {
    status: string;
    tbL_Forms: TBL_Form[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class LKP_FormPeriodType implements ILKP_FormPeriodType {
    title: string;
    tbL_Forms: TBL_Form[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ILKP_FormPeriodType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["tbL_Forms"])) {
                this.tbL_Forms = [] as any;
                for (let item of _data["tbL_Forms"])
                    this.tbL_Forms.push(TBL_Form.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LKP_FormPeriodType {
        data = typeof data === 'object' ? data : {};
        let result = new LKP_FormPeriodType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.tbL_Forms)) {
            data["tbL_Forms"] = [];
            for (let item of this.tbL_Forms)
                data["tbL_Forms"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LKP_FormPeriodType {
        const json = this.toJSON();
        let result = new LKP_FormPeriodType();
        result.init(json);
        return result;
    }
}

export interface ILKP_FormPeriodType {
    title: string;
    tbL_Forms: TBL_Form[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class LKP_StructureType implements ILKP_StructureType {
    type: string;
    tbL_Structures: TBL_Structure[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ILKP_StructureType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            if (Array.isArray(_data["tbL_Structures"])) {
                this.tbL_Structures = [] as any;
                for (let item of _data["tbL_Structures"])
                    this.tbL_Structures.push(TBL_Structure.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LKP_StructureType {
        data = typeof data === 'object' ? data : {};
        let result = new LKP_StructureType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (Array.isArray(this.tbL_Structures)) {
            data["tbL_Structures"] = [];
            for (let item of this.tbL_Structures)
                data["tbL_Structures"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LKP_StructureType {
        const json = this.toJSON();
        let result = new LKP_StructureType();
        result.init(json);
        return result;
    }
}

export interface ILKP_StructureType {
    type: string;
    tbL_Structures: TBL_Structure[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TBL_Structure implements ITBL_Structure {
    typeId: number;
    title: string | undefined;
    code: string | undefined;
    displayName: string | undefined;
    parentId: number | undefined;
    businessUnitId: number | undefined;
    oldId_BI: number | undefined;
    type: LKP_StructureType;
    structure: TBL_Structure;
    businessUnit: LKP_BusinessUnit;
    tbL_FormStructureRows: TBL_FormStructureRow[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_Structure) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            this.title = _data["title"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.parentId = _data["parentId"];
            this.businessUnitId = _data["businessUnitId"];
            this.oldId_BI = _data["oldId_BI"];
            this.type = _data["type"] ? LKP_StructureType.fromJS(_data["type"]) : <any>undefined;
            this.structure = _data["structure"] ? TBL_Structure.fromJS(_data["structure"]) : <any>undefined;
            this.businessUnit = _data["businessUnit"] ? LKP_BusinessUnit.fromJS(_data["businessUnit"]) : <any>undefined;
            if (Array.isArray(_data["tbL_FormStructureRows"])) {
                this.tbL_FormStructureRows = [] as any;
                for (let item of _data["tbL_FormStructureRows"])
                    this.tbL_FormStructureRows.push(TBL_FormStructureRow.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_Structure {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_Structure();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["title"] = this.title;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["parentId"] = this.parentId;
        data["businessUnitId"] = this.businessUnitId;
        data["oldId_BI"] = this.oldId_BI;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["structure"] = this.structure ? this.structure.toJSON() : <any>undefined;
        data["businessUnit"] = this.businessUnit ? this.businessUnit.toJSON() : <any>undefined;
        if (Array.isArray(this.tbL_FormStructureRows)) {
            data["tbL_FormStructureRows"] = [];
            for (let item of this.tbL_FormStructureRows)
                data["tbL_FormStructureRows"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_Structure {
        const json = this.toJSON();
        let result = new TBL_Structure();
        result.init(json);
        return result;
    }
}

export interface ITBL_Structure {
    typeId: number;
    title: string | undefined;
    code: string | undefined;
    displayName: string | undefined;
    parentId: number | undefined;
    businessUnitId: number | undefined;
    oldId_BI: number | undefined;
    type: LKP_StructureType;
    structure: TBL_Structure;
    businessUnit: LKP_BusinessUnit;
    tbL_FormStructureRows: TBL_FormStructureRow[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class LKP_BusinessUnit implements ILKP_BusinessUnit {
    title: string;
    shortTitle: string | undefined;
    tbL_FormBusinessUnits: TBL_FormBusinessUnit[] | undefined;
    tbL_Structure: TBL_Structure[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ILKP_BusinessUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.shortTitle = _data["shortTitle"];
            if (Array.isArray(_data["tbL_FormBusinessUnits"])) {
                this.tbL_FormBusinessUnits = [] as any;
                for (let item of _data["tbL_FormBusinessUnits"])
                    this.tbL_FormBusinessUnits.push(TBL_FormBusinessUnit.fromJS(item));
            }
            if (Array.isArray(_data["tbL_Structure"])) {
                this.tbL_Structure = [] as any;
                for (let item of _data["tbL_Structure"])
                    this.tbL_Structure.push(TBL_Structure.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LKP_BusinessUnit {
        data = typeof data === 'object' ? data : {};
        let result = new LKP_BusinessUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["shortTitle"] = this.shortTitle;
        if (Array.isArray(this.tbL_FormBusinessUnits)) {
            data["tbL_FormBusinessUnits"] = [];
            for (let item of this.tbL_FormBusinessUnits)
                data["tbL_FormBusinessUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.tbL_Structure)) {
            data["tbL_Structure"] = [];
            for (let item of this.tbL_Structure)
                data["tbL_Structure"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LKP_BusinessUnit {
        const json = this.toJSON();
        let result = new LKP_BusinessUnit();
        result.init(json);
        return result;
    }
}

export interface ILKP_BusinessUnit {
    title: string;
    shortTitle: string | undefined;
    tbL_FormBusinessUnits: TBL_FormBusinessUnit[] | undefined;
    tbL_Structure: TBL_Structure[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserToken implements IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;
}

export class UserLogin implements IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
    id: number;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
    id: number;
}

export class UserRole implements IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserClaim implements IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Setting implements ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class User implements IUser {
    name: string | undefined;
    adFullName: string | undefined;
    userForms: TBL_UserForm[] | undefined;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    surname: string;
    readonly fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.adFullName = _data["adFullName"];
            if (Array.isArray(_data["userForms"])) {
                this.userForms = [] as any;
                for (let item of _data["userForms"])
                    this.userForms.push(TBL_UserForm.fromJS(item));
            }
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? moment(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["adFullName"] = this.adFullName;
        if (Array.isArray(this.userForms)) {
            data["userForms"] = [];
            for (let item of this.userForms)
                data["userForms"].push(item.toJSON());
        }
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    name: string | undefined;
    adFullName: string | undefined;
    userForms: TBL_UserForm[] | undefined;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TBL_UserForm implements ITBL_UserForm {
    firstEditDate: moment.Moment | undefined;
    lastEditDate: moment.Moment | undefined;
    isCompleted: boolean | undefined;
    userId: number;
    formBusinessUnitId: number;
    user: User;
    formBusinessUnit: TBL_FormBusinessUnit;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_UserForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstEditDate = _data["firstEditDate"] ? moment(_data["firstEditDate"].toString()) : <any>undefined;
            this.lastEditDate = _data["lastEditDate"] ? moment(_data["lastEditDate"].toString()) : <any>undefined;
            this.isCompleted = _data["isCompleted"];
            this.userId = _data["userId"];
            this.formBusinessUnitId = _data["formBusinessUnitId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.formBusinessUnit = _data["formBusinessUnit"] ? TBL_FormBusinessUnit.fromJS(_data["formBusinessUnit"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_UserForm {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_UserForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstEditDate"] = this.firstEditDate ? this.firstEditDate.toISOString() : <any>undefined;
        data["lastEditDate"] = this.lastEditDate ? this.lastEditDate.toISOString() : <any>undefined;
        data["isCompleted"] = this.isCompleted;
        data["userId"] = this.userId;
        data["formBusinessUnitId"] = this.formBusinessUnitId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["formBusinessUnit"] = this.formBusinessUnit ? this.formBusinessUnit.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_UserForm {
        const json = this.toJSON();
        let result = new TBL_UserForm();
        result.init(json);
        return result;
    }
}

export interface ITBL_UserForm {
    firstEditDate: moment.Moment | undefined;
    lastEditDate: moment.Moment | undefined;
    isCompleted: boolean | undefined;
    userId: number;
    formBusinessUnitId: number;
    user: User;
    formBusinessUnit: TBL_FormBusinessUnit;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TBL_FormBusinessUnit implements ITBL_FormBusinessUnit {
    businessUnitId: number;
    formId: number;
    businessUnit: LKP_BusinessUnit;
    form: TBL_Form;
    tbL_UserForms: TBL_UserForm[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_FormBusinessUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessUnitId = _data["businessUnitId"];
            this.formId = _data["formId"];
            this.businessUnit = _data["businessUnit"] ? LKP_BusinessUnit.fromJS(_data["businessUnit"]) : <any>undefined;
            this.form = _data["form"] ? TBL_Form.fromJS(_data["form"]) : <any>undefined;
            if (Array.isArray(_data["tbL_UserForms"])) {
                this.tbL_UserForms = [] as any;
                for (let item of _data["tbL_UserForms"])
                    this.tbL_UserForms.push(TBL_UserForm.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_FormBusinessUnit {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_FormBusinessUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessUnitId"] = this.businessUnitId;
        data["formId"] = this.formId;
        data["businessUnit"] = this.businessUnit ? this.businessUnit.toJSON() : <any>undefined;
        data["form"] = this.form ? this.form.toJSON() : <any>undefined;
        if (Array.isArray(this.tbL_UserForms)) {
            data["tbL_UserForms"] = [];
            for (let item of this.tbL_UserForms)
                data["tbL_UserForms"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_FormBusinessUnit {
        const json = this.toJSON();
        let result = new TBL_FormBusinessUnit();
        result.init(json);
        return result;
    }
}

export interface ITBL_FormBusinessUnit {
    businessUnitId: number;
    formId: number;
    businessUnit: LKP_BusinessUnit;
    form: TBL_Form;
    tbL_UserForms: TBL_UserForm[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TBL_PivotQuery implements ITBL_PivotQuery {
    formStructureRowId: number;
    formId: number;
    jsonObject: string | undefined;
    dimensionsHierarchy: string | undefined;
    scriptOriginal: string | undefined;
    scriptWithParam: string | undefined;
    form: TBL_Form;
    formStructureRow: TBL_FormStructureRow;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_PivotQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructureRowId = _data["formStructureRowId"];
            this.formId = _data["formId"];
            this.jsonObject = _data["jsonObject"];
            this.dimensionsHierarchy = _data["dimensionsHierarchy"];
            this.scriptOriginal = _data["scriptOriginal"];
            this.scriptWithParam = _data["scriptWithParam"];
            this.form = _data["form"] ? TBL_Form.fromJS(_data["form"]) : <any>undefined;
            this.formStructureRow = _data["formStructureRow"] ? TBL_FormStructureRow.fromJS(_data["formStructureRow"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_PivotQuery {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_PivotQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructureRowId"] = this.formStructureRowId;
        data["formId"] = this.formId;
        data["jsonObject"] = this.jsonObject;
        data["dimensionsHierarchy"] = this.dimensionsHierarchy;
        data["scriptOriginal"] = this.scriptOriginal;
        data["scriptWithParam"] = this.scriptWithParam;
        data["form"] = this.form ? this.form.toJSON() : <any>undefined;
        data["formStructureRow"] = this.formStructureRow ? this.formStructureRow.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_PivotQuery {
        const json = this.toJSON();
        let result = new TBL_PivotQuery();
        result.init(json);
        return result;
    }
}

export interface ITBL_PivotQuery {
    formStructureRowId: number;
    formId: number;
    jsonObject: string | undefined;
    dimensionsHierarchy: string | undefined;
    scriptOriginal: string | undefined;
    scriptWithParam: string | undefined;
    form: TBL_Form;
    formStructureRow: TBL_FormStructureRow;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TBL_Form implements ITBL_Form {
    code: string | undefined;
    isActive: boolean;
    isPublished: boolean;
    publishDate: moment.Moment | undefined;
    periodTypeId: number;
    displayType: FormDisplayType;
    statusId: number;
    businessRoleId: number;
    businessRole: LKP_BusinessRole;
    status: LKP_FormStatus;
    periodType: LKP_FormPeriodType;
    tbL_FormBusinessUnits: TBL_FormBusinessUnit[] | undefined;
    tbL_FormStructureRows: TBL_FormStructureRow[] | undefined;
    tbL_PivotQueries: TBL_PivotQuery[] | undefined;
    readonly formName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_Form) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.isActive = _data["isActive"];
            this.isPublished = _data["isPublished"];
            this.publishDate = _data["publishDate"] ? moment(_data["publishDate"].toString()) : <any>undefined;
            this.periodTypeId = _data["periodTypeId"];
            this.displayType = _data["displayType"];
            this.statusId = _data["statusId"];
            this.businessRoleId = _data["businessRoleId"];
            this.businessRole = _data["businessRole"] ? LKP_BusinessRole.fromJS(_data["businessRole"]) : <any>undefined;
            this.status = _data["status"] ? LKP_FormStatus.fromJS(_data["status"]) : <any>undefined;
            this.periodType = _data["periodType"] ? LKP_FormPeriodType.fromJS(_data["periodType"]) : <any>undefined;
            if (Array.isArray(_data["tbL_FormBusinessUnits"])) {
                this.tbL_FormBusinessUnits = [] as any;
                for (let item of _data["tbL_FormBusinessUnits"])
                    this.tbL_FormBusinessUnits.push(TBL_FormBusinessUnit.fromJS(item));
            }
            if (Array.isArray(_data["tbL_FormStructureRows"])) {
                this.tbL_FormStructureRows = [] as any;
                for (let item of _data["tbL_FormStructureRows"])
                    this.tbL_FormStructureRows.push(TBL_FormStructureRow.fromJS(item));
            }
            if (Array.isArray(_data["tbL_PivotQueries"])) {
                this.tbL_PivotQueries = [] as any;
                for (let item of _data["tbL_PivotQueries"])
                    this.tbL_PivotQueries.push(TBL_PivotQuery.fromJS(item));
            }
            (<any>this).formName = _data["formName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_Form {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_Form();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["isActive"] = this.isActive;
        data["isPublished"] = this.isPublished;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
        data["periodTypeId"] = this.periodTypeId;
        data["displayType"] = this.displayType;
        data["statusId"] = this.statusId;
        data["businessRoleId"] = this.businessRoleId;
        data["businessRole"] = this.businessRole ? this.businessRole.toJSON() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["periodType"] = this.periodType ? this.periodType.toJSON() : <any>undefined;
        if (Array.isArray(this.tbL_FormBusinessUnits)) {
            data["tbL_FormBusinessUnits"] = [];
            for (let item of this.tbL_FormBusinessUnits)
                data["tbL_FormBusinessUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.tbL_FormStructureRows)) {
            data["tbL_FormStructureRows"] = [];
            for (let item of this.tbL_FormStructureRows)
                data["tbL_FormStructureRows"].push(item.toJSON());
        }
        if (Array.isArray(this.tbL_PivotQueries)) {
            data["tbL_PivotQueries"] = [];
            for (let item of this.tbL_PivotQueries)
                data["tbL_PivotQueries"].push(item.toJSON());
        }
        data["formName"] = this.formName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_Form {
        const json = this.toJSON();
        let result = new TBL_Form();
        result.init(json);
        return result;
    }
}

export interface ITBL_Form {
    code: string | undefined;
    isActive: boolean;
    isPublished: boolean;
    publishDate: moment.Moment | undefined;
    periodTypeId: number;
    displayType: FormDisplayType;
    statusId: number;
    businessRoleId: number;
    businessRole: LKP_BusinessRole;
    status: LKP_FormStatus;
    periodType: LKP_FormPeriodType;
    tbL_FormBusinessUnits: TBL_FormBusinessUnit[] | undefined;
    tbL_FormStructureRows: TBL_FormStructureRow[] | undefined;
    tbL_PivotQueries: TBL_PivotQuery[] | undefined;
    formName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class LKP_RowType implements ILKP_RowType {
    title: string;
    tbL_FormStructureRows: TBL_FormStructureRow[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ILKP_RowType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["tbL_FormStructureRows"])) {
                this.tbL_FormStructureRows = [] as any;
                for (let item of _data["tbL_FormStructureRows"])
                    this.tbL_FormStructureRows.push(TBL_FormStructureRow.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LKP_RowType {
        data = typeof data === 'object' ? data : {};
        let result = new LKP_RowType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.tbL_FormStructureRows)) {
            data["tbL_FormStructureRows"] = [];
            for (let item of this.tbL_FormStructureRows)
                data["tbL_FormStructureRows"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LKP_RowType {
        const json = this.toJSON();
        let result = new LKP_RowType();
        result.init(json);
        return result;
    }
}

export interface ILKP_RowType {
    title: string;
    tbL_FormStructureRows: TBL_FormStructureRow[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TBL_CubeQueryMapping implements ITBL_CubeQueryMapping {
    formStructureColumnId: number | undefined;
    formStructureRowId: number;
    schemaSelector: string | undefined;
    dataSelector: string | undefined;
    isMeasure: boolean;
    formStructureRow: TBL_FormStructureRow;
    formStructureColumn: TBL_FormStructureColumn;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_CubeQueryMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructureColumnId = _data["formStructureColumnId"];
            this.formStructureRowId = _data["formStructureRowId"];
            this.schemaSelector = _data["schemaSelector"];
            this.dataSelector = _data["dataSelector"];
            this.isMeasure = _data["isMeasure"];
            this.formStructureRow = _data["formStructureRow"] ? TBL_FormStructureRow.fromJS(_data["formStructureRow"]) : <any>undefined;
            this.formStructureColumn = _data["formStructureColumn"] ? TBL_FormStructureColumn.fromJS(_data["formStructureColumn"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_CubeQueryMapping {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_CubeQueryMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructureColumnId"] = this.formStructureColumnId;
        data["formStructureRowId"] = this.formStructureRowId;
        data["schemaSelector"] = this.schemaSelector;
        data["dataSelector"] = this.dataSelector;
        data["isMeasure"] = this.isMeasure;
        data["formStructureRow"] = this.formStructureRow ? this.formStructureRow.toJSON() : <any>undefined;
        data["formStructureColumn"] = this.formStructureColumn ? this.formStructureColumn.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_CubeQueryMapping {
        const json = this.toJSON();
        let result = new TBL_CubeQueryMapping();
        result.init(json);
        return result;
    }
}

export interface ITBL_CubeQueryMapping {
    formStructureColumnId: number | undefined;
    formStructureRowId: number;
    schemaSelector: string | undefined;
    dataSelector: string | undefined;
    isMeasure: boolean;
    formStructureRow: TBL_FormStructureRow;
    formStructureColumn: TBL_FormStructureColumn;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TBL_FormStructurePercentage implements ITBL_FormStructurePercentage {
    formStructureRowId: number;
    formStructureColumnId: number;
    isPercentage: boolean;
    formStructureRow: TBL_FormStructureRow;
    formStructureColumn: TBL_FormStructureColumn;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_FormStructurePercentage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructureRowId = _data["formStructureRowId"];
            this.formStructureColumnId = _data["formStructureColumnId"];
            this.isPercentage = _data["isPercentage"];
            this.formStructureRow = _data["formStructureRow"] ? TBL_FormStructureRow.fromJS(_data["formStructureRow"]) : <any>undefined;
            this.formStructureColumn = _data["formStructureColumn"] ? TBL_FormStructureColumn.fromJS(_data["formStructureColumn"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_FormStructurePercentage {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_FormStructurePercentage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructureRowId"] = this.formStructureRowId;
        data["formStructureColumnId"] = this.formStructureColumnId;
        data["isPercentage"] = this.isPercentage;
        data["formStructureRow"] = this.formStructureRow ? this.formStructureRow.toJSON() : <any>undefined;
        data["formStructureColumn"] = this.formStructureColumn ? this.formStructureColumn.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_FormStructurePercentage {
        const json = this.toJSON();
        let result = new TBL_FormStructurePercentage();
        result.init(json);
        return result;
    }
}

export interface ITBL_FormStructurePercentage {
    formStructureRowId: number;
    formStructureColumnId: number;
    isPercentage: boolean;
    formStructureRow: TBL_FormStructureRow;
    formStructureColumn: TBL_FormStructureColumn;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TBL_FormStructureRow implements ITBL_FormStructureRow {
    structureId: number;
    formId: number;
    parentId: number | undefined;
    rowTypeId: number | undefined;
    isLeaf: boolean;
    order: number;
    oldId_BI: number | undefined;
    showValues: boolean;
    referenceData: string | undefined;
    form: TBL_Form;
    formStructureRow: TBL_FormStructureRow;
    structure: TBL_Structure;
    rowType: LKP_RowType;
    tbL_FormStructureRows: TBL_FormStructureRow[] | undefined;
    tbL_FormStructureCells: TBL_FormStructureCell[] | undefined;
    tbL_FormStructureColumns: TBL_FormStructureColumn[] | undefined;
    tbL_PivotQueries: TBL_PivotQuery[] | undefined;
    tbL_CubeQueryMappings: TBL_CubeQueryMapping[] | undefined;
    tbL_FormStructurePercentages: TBL_FormStructurePercentage[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_FormStructureRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.structureId = _data["structureId"];
            this.formId = _data["formId"];
            this.parentId = _data["parentId"];
            this.rowTypeId = _data["rowTypeId"];
            this.isLeaf = _data["isLeaf"];
            this.order = _data["order"];
            this.oldId_BI = _data["oldId_BI"];
            this.showValues = _data["showValues"];
            this.referenceData = _data["referenceData"];
            this.form = _data["form"] ? TBL_Form.fromJS(_data["form"]) : <any>undefined;
            this.formStructureRow = _data["formStructureRow"] ? TBL_FormStructureRow.fromJS(_data["formStructureRow"]) : <any>undefined;
            this.structure = _data["structure"] ? TBL_Structure.fromJS(_data["structure"]) : <any>undefined;
            this.rowType = _data["rowType"] ? LKP_RowType.fromJS(_data["rowType"]) : <any>undefined;
            if (Array.isArray(_data["tbL_FormStructureRows"])) {
                this.tbL_FormStructureRows = [] as any;
                for (let item of _data["tbL_FormStructureRows"])
                    this.tbL_FormStructureRows.push(TBL_FormStructureRow.fromJS(item));
            }
            if (Array.isArray(_data["tbL_FormStructureCells"])) {
                this.tbL_FormStructureCells = [] as any;
                for (let item of _data["tbL_FormStructureCells"])
                    this.tbL_FormStructureCells.push(TBL_FormStructureCell.fromJS(item));
            }
            if (Array.isArray(_data["tbL_FormStructureColumns"])) {
                this.tbL_FormStructureColumns = [] as any;
                for (let item of _data["tbL_FormStructureColumns"])
                    this.tbL_FormStructureColumns.push(TBL_FormStructureColumn.fromJS(item));
            }
            if (Array.isArray(_data["tbL_PivotQueries"])) {
                this.tbL_PivotQueries = [] as any;
                for (let item of _data["tbL_PivotQueries"])
                    this.tbL_PivotQueries.push(TBL_PivotQuery.fromJS(item));
            }
            if (Array.isArray(_data["tbL_CubeQueryMappings"])) {
                this.tbL_CubeQueryMappings = [] as any;
                for (let item of _data["tbL_CubeQueryMappings"])
                    this.tbL_CubeQueryMappings.push(TBL_CubeQueryMapping.fromJS(item));
            }
            if (Array.isArray(_data["tbL_FormStructurePercentages"])) {
                this.tbL_FormStructurePercentages = [] as any;
                for (let item of _data["tbL_FormStructurePercentages"])
                    this.tbL_FormStructurePercentages.push(TBL_FormStructurePercentage.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_FormStructureRow {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_FormStructureRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["structureId"] = this.structureId;
        data["formId"] = this.formId;
        data["parentId"] = this.parentId;
        data["rowTypeId"] = this.rowTypeId;
        data["isLeaf"] = this.isLeaf;
        data["order"] = this.order;
        data["oldId_BI"] = this.oldId_BI;
        data["showValues"] = this.showValues;
        data["referenceData"] = this.referenceData;
        data["form"] = this.form ? this.form.toJSON() : <any>undefined;
        data["formStructureRow"] = this.formStructureRow ? this.formStructureRow.toJSON() : <any>undefined;
        data["structure"] = this.structure ? this.structure.toJSON() : <any>undefined;
        data["rowType"] = this.rowType ? this.rowType.toJSON() : <any>undefined;
        if (Array.isArray(this.tbL_FormStructureRows)) {
            data["tbL_FormStructureRows"] = [];
            for (let item of this.tbL_FormStructureRows)
                data["tbL_FormStructureRows"].push(item.toJSON());
        }
        if (Array.isArray(this.tbL_FormStructureCells)) {
            data["tbL_FormStructureCells"] = [];
            for (let item of this.tbL_FormStructureCells)
                data["tbL_FormStructureCells"].push(item.toJSON());
        }
        if (Array.isArray(this.tbL_FormStructureColumns)) {
            data["tbL_FormStructureColumns"] = [];
            for (let item of this.tbL_FormStructureColumns)
                data["tbL_FormStructureColumns"].push(item.toJSON());
        }
        if (Array.isArray(this.tbL_PivotQueries)) {
            data["tbL_PivotQueries"] = [];
            for (let item of this.tbL_PivotQueries)
                data["tbL_PivotQueries"].push(item.toJSON());
        }
        if (Array.isArray(this.tbL_CubeQueryMappings)) {
            data["tbL_CubeQueryMappings"] = [];
            for (let item of this.tbL_CubeQueryMappings)
                data["tbL_CubeQueryMappings"].push(item.toJSON());
        }
        if (Array.isArray(this.tbL_FormStructurePercentages)) {
            data["tbL_FormStructurePercentages"] = [];
            for (let item of this.tbL_FormStructurePercentages)
                data["tbL_FormStructurePercentages"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_FormStructureRow {
        const json = this.toJSON();
        let result = new TBL_FormStructureRow();
        result.init(json);
        return result;
    }
}

export interface ITBL_FormStructureRow {
    structureId: number;
    formId: number;
    parentId: number | undefined;
    rowTypeId: number | undefined;
    isLeaf: boolean;
    order: number;
    oldId_BI: number | undefined;
    showValues: boolean;
    referenceData: string | undefined;
    form: TBL_Form;
    formStructureRow: TBL_FormStructureRow;
    structure: TBL_Structure;
    rowType: LKP_RowType;
    tbL_FormStructureRows: TBL_FormStructureRow[] | undefined;
    tbL_FormStructureCells: TBL_FormStructureCell[] | undefined;
    tbL_FormStructureColumns: TBL_FormStructureColumn[] | undefined;
    tbL_PivotQueries: TBL_PivotQuery[] | undefined;
    tbL_CubeQueryMappings: TBL_CubeQueryMapping[] | undefined;
    tbL_FormStructurePercentages: TBL_FormStructurePercentage[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TBL_FormStructureColumn implements ITBL_FormStructureColumn {
    formStructureRowId: number;
    columnStructureId: number;
    order: number;
    header: string | undefined;
    businessRuleId: number | undefined;
    oldId_BI: number | undefined;
    isPercentage: boolean;
    businessRule: TBL_BusinessRule;
    columnStructure: LKP_StructureColumn;
    formStructureRow: TBL_FormStructureRow;
    tbL_FormStructureCells: TBL_FormStructureCell[] | undefined;
    tbL_CubeQueryMappings: TBL_CubeQueryMapping[] | undefined;
    tbL_FormStructurePercentages: TBL_FormStructurePercentage[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_FormStructureColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructureRowId = _data["formStructureRowId"];
            this.columnStructureId = _data["columnStructureId"];
            this.order = _data["order"];
            this.header = _data["header"];
            this.businessRuleId = _data["businessRuleId"];
            this.oldId_BI = _data["oldId_BI"];
            this.isPercentage = _data["isPercentage"];
            this.businessRule = _data["businessRule"] ? TBL_BusinessRule.fromJS(_data["businessRule"]) : <any>undefined;
            this.columnStructure = _data["columnStructure"] ? LKP_StructureColumn.fromJS(_data["columnStructure"]) : <any>undefined;
            this.formStructureRow = _data["formStructureRow"] ? TBL_FormStructureRow.fromJS(_data["formStructureRow"]) : <any>undefined;
            if (Array.isArray(_data["tbL_FormStructureCells"])) {
                this.tbL_FormStructureCells = [] as any;
                for (let item of _data["tbL_FormStructureCells"])
                    this.tbL_FormStructureCells.push(TBL_FormStructureCell.fromJS(item));
            }
            if (Array.isArray(_data["tbL_CubeQueryMappings"])) {
                this.tbL_CubeQueryMappings = [] as any;
                for (let item of _data["tbL_CubeQueryMappings"])
                    this.tbL_CubeQueryMappings.push(TBL_CubeQueryMapping.fromJS(item));
            }
            if (Array.isArray(_data["tbL_FormStructurePercentages"])) {
                this.tbL_FormStructurePercentages = [] as any;
                for (let item of _data["tbL_FormStructurePercentages"])
                    this.tbL_FormStructurePercentages.push(TBL_FormStructurePercentage.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_FormStructureColumn {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_FormStructureColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructureRowId"] = this.formStructureRowId;
        data["columnStructureId"] = this.columnStructureId;
        data["order"] = this.order;
        data["header"] = this.header;
        data["businessRuleId"] = this.businessRuleId;
        data["oldId_BI"] = this.oldId_BI;
        data["isPercentage"] = this.isPercentage;
        data["businessRule"] = this.businessRule ? this.businessRule.toJSON() : <any>undefined;
        data["columnStructure"] = this.columnStructure ? this.columnStructure.toJSON() : <any>undefined;
        data["formStructureRow"] = this.formStructureRow ? this.formStructureRow.toJSON() : <any>undefined;
        if (Array.isArray(this.tbL_FormStructureCells)) {
            data["tbL_FormStructureCells"] = [];
            for (let item of this.tbL_FormStructureCells)
                data["tbL_FormStructureCells"].push(item.toJSON());
        }
        if (Array.isArray(this.tbL_CubeQueryMappings)) {
            data["tbL_CubeQueryMappings"] = [];
            for (let item of this.tbL_CubeQueryMappings)
                data["tbL_CubeQueryMappings"].push(item.toJSON());
        }
        if (Array.isArray(this.tbL_FormStructurePercentages)) {
            data["tbL_FormStructurePercentages"] = [];
            for (let item of this.tbL_FormStructurePercentages)
                data["tbL_FormStructurePercentages"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_FormStructureColumn {
        const json = this.toJSON();
        let result = new TBL_FormStructureColumn();
        result.init(json);
        return result;
    }
}

export interface ITBL_FormStructureColumn {
    formStructureRowId: number;
    columnStructureId: number;
    order: number;
    header: string | undefined;
    businessRuleId: number | undefined;
    oldId_BI: number | undefined;
    isPercentage: boolean;
    businessRule: TBL_BusinessRule;
    columnStructure: LKP_StructureColumn;
    formStructureRow: TBL_FormStructureRow;
    tbL_FormStructureCells: TBL_FormStructureCell[] | undefined;
    tbL_CubeQueryMappings: TBL_CubeQueryMapping[] | undefined;
    tbL_FormStructurePercentages: TBL_FormStructurePercentage[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class LKP_StructureCellType implements ILKP_StructureCellType {
    type: string;
    tbL_FormStructureCells: TBL_FormStructureCell[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ILKP_StructureCellType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            if (Array.isArray(_data["tbL_FormStructureCells"])) {
                this.tbL_FormStructureCells = [] as any;
                for (let item of _data["tbL_FormStructureCells"])
                    this.tbL_FormStructureCells.push(TBL_FormStructureCell.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LKP_StructureCellType {
        data = typeof data === 'object' ? data : {};
        let result = new LKP_StructureCellType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (Array.isArray(this.tbL_FormStructureCells)) {
            data["tbL_FormStructureCells"] = [];
            for (let item of this.tbL_FormStructureCells)
                data["tbL_FormStructureCells"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LKP_StructureCellType {
        const json = this.toJSON();
        let result = new LKP_StructureCellType();
        result.init(json);
        return result;
    }
}

export interface ILKP_StructureCellType {
    type: string;
    tbL_FormStructureCells: TBL_FormStructureCell[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TBL_ActivitiesFormData implements ITBL_ActivitiesFormData {
    activityId: number | undefined;
    activityType: ActivityType;
    cellValue: number | undefined;
    parentActivityId: number | undefined;
    rowId: number | undefined;
    customData: string | undefined;
    formStructureCellId: number | undefined;
    formStructureCell: TBL_FormStructureCell;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_ActivitiesFormData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.activityType = _data["activityType"];
            this.cellValue = _data["cellValue"];
            this.parentActivityId = _data["parentActivityId"];
            this.rowId = _data["rowId"];
            this.customData = _data["customData"];
            this.formStructureCellId = _data["formStructureCellId"];
            this.formStructureCell = _data["formStructureCell"] ? TBL_FormStructureCell.fromJS(_data["formStructureCell"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_ActivitiesFormData {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_ActivitiesFormData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["activityType"] = this.activityType;
        data["cellValue"] = this.cellValue;
        data["parentActivityId"] = this.parentActivityId;
        data["rowId"] = this.rowId;
        data["customData"] = this.customData;
        data["formStructureCellId"] = this.formStructureCellId;
        data["formStructureCell"] = this.formStructureCell ? this.formStructureCell.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_ActivitiesFormData {
        const json = this.toJSON();
        let result = new TBL_ActivitiesFormData();
        result.init(json);
        return result;
    }
}

export interface ITBL_ActivitiesFormData {
    activityId: number | undefined;
    activityType: ActivityType;
    cellValue: number | undefined;
    parentActivityId: number | undefined;
    rowId: number | undefined;
    customData: string | undefined;
    formStructureCellId: number | undefined;
    formStructureCell: TBL_FormStructureCell;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TBL_FormStructureCell implements ITBL_FormStructureCell {
    typeId: number;
    formStructureRowId: number;
    formStructureColumnId: number;
    oldId_BI: number | undefined;
    formStructureColumn: TBL_FormStructureColumn;
    formStructureRow: TBL_FormStructureRow;
    type: LKP_StructureCellType;
    tbL_FormData: TBL_FormData[] | undefined;
    tbL_ActivitiesFormData: TBL_ActivitiesFormData[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_FormStructureCell) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            this.formStructureRowId = _data["formStructureRowId"];
            this.formStructureColumnId = _data["formStructureColumnId"];
            this.oldId_BI = _data["oldId_BI"];
            this.formStructureColumn = _data["formStructureColumn"] ? TBL_FormStructureColumn.fromJS(_data["formStructureColumn"]) : <any>undefined;
            this.formStructureRow = _data["formStructureRow"] ? TBL_FormStructureRow.fromJS(_data["formStructureRow"]) : <any>undefined;
            this.type = _data["type"] ? LKP_StructureCellType.fromJS(_data["type"]) : <any>undefined;
            if (Array.isArray(_data["tbL_FormData"])) {
                this.tbL_FormData = [] as any;
                for (let item of _data["tbL_FormData"])
                    this.tbL_FormData.push(TBL_FormData.fromJS(item));
            }
            if (Array.isArray(_data["tbL_ActivitiesFormData"])) {
                this.tbL_ActivitiesFormData = [] as any;
                for (let item of _data["tbL_ActivitiesFormData"])
                    this.tbL_ActivitiesFormData.push(TBL_ActivitiesFormData.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_FormStructureCell {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_FormStructureCell();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["formStructureRowId"] = this.formStructureRowId;
        data["formStructureColumnId"] = this.formStructureColumnId;
        data["oldId_BI"] = this.oldId_BI;
        data["formStructureColumn"] = this.formStructureColumn ? this.formStructureColumn.toJSON() : <any>undefined;
        data["formStructureRow"] = this.formStructureRow ? this.formStructureRow.toJSON() : <any>undefined;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        if (Array.isArray(this.tbL_FormData)) {
            data["tbL_FormData"] = [];
            for (let item of this.tbL_FormData)
                data["tbL_FormData"].push(item.toJSON());
        }
        if (Array.isArray(this.tbL_ActivitiesFormData)) {
            data["tbL_ActivitiesFormData"] = [];
            for (let item of this.tbL_ActivitiesFormData)
                data["tbL_ActivitiesFormData"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_FormStructureCell {
        const json = this.toJSON();
        let result = new TBL_FormStructureCell();
        result.init(json);
        return result;
    }
}

export interface ITBL_FormStructureCell {
    typeId: number;
    formStructureRowId: number;
    formStructureColumnId: number;
    oldId_BI: number | undefined;
    formStructureColumn: TBL_FormStructureColumn;
    formStructureRow: TBL_FormStructureRow;
    type: LKP_StructureCellType;
    tbL_FormData: TBL_FormData[] | undefined;
    tbL_ActivitiesFormData: TBL_ActivitiesFormData[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TBL_FormData implements ITBL_FormData {
    formStructureCellId: number;
    value: number | undefined;
    week: number | undefined;
    month: number | undefined;
    year: number | undefined;
    formStructureCell: TBL_FormStructureCell;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITBL_FormData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructureCellId = _data["formStructureCellId"];
            this.value = _data["value"];
            this.week = _data["week"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.formStructureCell = _data["formStructureCell"] ? TBL_FormStructureCell.fromJS(_data["formStructureCell"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TBL_FormData {
        data = typeof data === 'object' ? data : {};
        let result = new TBL_FormData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructureCellId"] = this.formStructureCellId;
        data["value"] = this.value;
        data["week"] = this.week;
        data["month"] = this.month;
        data["year"] = this.year;
        data["formStructureCell"] = this.formStructureCell ? this.formStructureCell.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TBL_FormData {
        const json = this.toJSON();
        let result = new TBL_FormData();
        result.init(json);
        return result;
    }
}

export interface ITBL_FormData {
    formStructureCellId: number;
    value: number | undefined;
    week: number | undefined;
    month: number | undefined;
    year: number | undefined;
    formStructureCell: TBL_FormStructureCell;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class IndicatorDto implements IIndicatorDto {
    order: number;
    isLeaf: boolean;
    subSectionId: number | undefined;
    indicatorTypeId: number;
    indicatorType: IndicatorTypeDto;
    formColumns: FormColumnDto[] | undefined;
    formRows: FormRowDto[] | undefined;
    allFormData: TBL_FormData[] | undefined;
    indicatorTemplates: LKP_StructureColumn[] | undefined;
    id: number;

    constructor(data?: IIndicatorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.order = _data["order"];
            this.isLeaf = _data["isLeaf"];
            this.subSectionId = _data["subSectionId"];
            this.indicatorTypeId = _data["indicatorTypeId"];
            this.indicatorType = _data["indicatorType"] ? IndicatorTypeDto.fromJS(_data["indicatorType"]) : <any>undefined;
            if (Array.isArray(_data["formColumns"])) {
                this.formColumns = [] as any;
                for (let item of _data["formColumns"])
                    this.formColumns.push(FormColumnDto.fromJS(item));
            }
            if (Array.isArray(_data["formRows"])) {
                this.formRows = [] as any;
                for (let item of _data["formRows"])
                    this.formRows.push(FormRowDto.fromJS(item));
            }
            if (Array.isArray(_data["allFormData"])) {
                this.allFormData = [] as any;
                for (let item of _data["allFormData"])
                    this.allFormData.push(TBL_FormData.fromJS(item));
            }
            if (Array.isArray(_data["indicatorTemplates"])) {
                this.indicatorTemplates = [] as any;
                for (let item of _data["indicatorTemplates"])
                    this.indicatorTemplates.push(LKP_StructureColumn.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IndicatorDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndicatorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order"] = this.order;
        data["isLeaf"] = this.isLeaf;
        data["subSectionId"] = this.subSectionId;
        data["indicatorTypeId"] = this.indicatorTypeId;
        data["indicatorType"] = this.indicatorType ? this.indicatorType.toJSON() : <any>undefined;
        if (Array.isArray(this.formColumns)) {
            data["formColumns"] = [];
            for (let item of this.formColumns)
                data["formColumns"].push(item.toJSON());
        }
        if (Array.isArray(this.formRows)) {
            data["formRows"] = [];
            for (let item of this.formRows)
                data["formRows"].push(item.toJSON());
        }
        if (Array.isArray(this.allFormData)) {
            data["allFormData"] = [];
            for (let item of this.allFormData)
                data["allFormData"].push(item.toJSON());
        }
        if (Array.isArray(this.indicatorTemplates)) {
            data["indicatorTemplates"] = [];
            for (let item of this.indicatorTemplates)
                data["indicatorTemplates"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): IndicatorDto {
        const json = this.toJSON();
        let result = new IndicatorDto();
        result.init(json);
        return result;
    }
}

export interface IIndicatorDto {
    order: number;
    isLeaf: boolean;
    subSectionId: number | undefined;
    indicatorTypeId: number;
    indicatorType: IndicatorTypeDto;
    formColumns: FormColumnDto[] | undefined;
    formRows: FormRowDto[] | undefined;
    allFormData: TBL_FormData[] | undefined;
    indicatorTemplates: LKP_StructureColumn[] | undefined;
    id: number;
}

export class SectionDto implements ISectionDto {
    order: number;
    isLeaf: boolean;
    formId: number;
    sectionTypeId: number;
    parentSectionId: number | undefined;
    sectionType: SectionTypeDto;
    children: SectionDto[] | undefined;
    formColumns: FormColumnDto[] | undefined;
    indicators: IndicatorDto[] | undefined;
    id: number;

    constructor(data?: ISectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.order = _data["order"];
            this.isLeaf = _data["isLeaf"];
            this.formId = _data["formId"];
            this.sectionTypeId = _data["sectionTypeId"];
            this.parentSectionId = _data["parentSectionId"];
            this.sectionType = _data["sectionType"] ? SectionTypeDto.fromJS(_data["sectionType"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(SectionDto.fromJS(item));
            }
            if (Array.isArray(_data["formColumns"])) {
                this.formColumns = [] as any;
                for (let item of _data["formColumns"])
                    this.formColumns.push(FormColumnDto.fromJS(item));
            }
            if (Array.isArray(_data["indicators"])) {
                this.indicators = [] as any;
                for (let item of _data["indicators"])
                    this.indicators.push(IndicatorDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order"] = this.order;
        data["isLeaf"] = this.isLeaf;
        data["formId"] = this.formId;
        data["sectionTypeId"] = this.sectionTypeId;
        data["parentSectionId"] = this.parentSectionId;
        data["sectionType"] = this.sectionType ? this.sectionType.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        if (Array.isArray(this.formColumns)) {
            data["formColumns"] = [];
            for (let item of this.formColumns)
                data["formColumns"].push(item.toJSON());
        }
        if (Array.isArray(this.indicators)) {
            data["indicators"] = [];
            for (let item of this.indicators)
                data["indicators"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): SectionDto {
        const json = this.toJSON();
        let result = new SectionDto();
        result.init(json);
        return result;
    }
}

export interface ISectionDto {
    order: number;
    isLeaf: boolean;
    formId: number;
    sectionTypeId: number;
    parentSectionId: number | undefined;
    sectionType: SectionTypeDto;
    children: SectionDto[] | undefined;
    formColumns: FormColumnDto[] | undefined;
    indicators: IndicatorDto[] | undefined;
    id: number;
}

export class FormDto implements IFormDto {
    formCode: string | undefined;
    isActive: boolean;
    isPublished: boolean;
    publishDate: moment.Moment;
    businessRoleId: number;
    formTypeId: number;
    businessRole: BusinessRoleDto[] | undefined;
    businessForms: BusinessFormDto[] | undefined;
    sections: SectionDto[] | undefined;
    id: number;

    constructor(data?: IFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formCode = _data["formCode"];
            this.isActive = _data["isActive"];
            this.isPublished = _data["isPublished"];
            this.publishDate = _data["publishDate"] ? moment(_data["publishDate"].toString()) : <any>undefined;
            this.businessRoleId = _data["businessRoleId"];
            this.formTypeId = _data["formTypeId"];
            if (Array.isArray(_data["businessRole"])) {
                this.businessRole = [] as any;
                for (let item of _data["businessRole"])
                    this.businessRole.push(BusinessRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["businessForms"])) {
                this.businessForms = [] as any;
                for (let item of _data["businessForms"])
                    this.businessForms.push(BusinessFormDto.fromJS(item));
            }
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections.push(SectionDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formCode"] = this.formCode;
        data["isActive"] = this.isActive;
        data["isPublished"] = this.isPublished;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
        data["businessRoleId"] = this.businessRoleId;
        data["formTypeId"] = this.formTypeId;
        if (Array.isArray(this.businessRole)) {
            data["businessRole"] = [];
            for (let item of this.businessRole)
                data["businessRole"].push(item.toJSON());
        }
        if (Array.isArray(this.businessForms)) {
            data["businessForms"] = [];
            for (let item of this.businessForms)
                data["businessForms"].push(item.toJSON());
        }
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): FormDto {
        const json = this.toJSON();
        let result = new FormDto();
        result.init(json);
        return result;
    }
}

export interface IFormDto {
    formCode: string | undefined;
    isActive: boolean;
    isPublished: boolean;
    publishDate: moment.Moment;
    businessRoleId: number;
    formTypeId: number;
    businessRole: BusinessRoleDto[] | undefined;
    businessForms: BusinessFormDto[] | undefined;
    sections: SectionDto[] | undefined;
    id: number;
}

export class FormEditDto implements IFormEditDto {
    id: number | undefined;
    formCode: string | undefined;
    isActive: boolean;
    isPublished: boolean;
    publishDate: moment.Moment;
    businessRoleId: number;
    formTypeId: number;
    formStatusId: number;
    businessUnitsNewIds: number[] | undefined;
    businessUnitsUpdatedIds: number[] | undefined;

    constructor(data?: IFormEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formCode = _data["formCode"];
            this.isActive = _data["isActive"];
            this.isPublished = _data["isPublished"];
            this.publishDate = _data["publishDate"] ? moment(_data["publishDate"].toString()) : <any>undefined;
            this.businessRoleId = _data["businessRoleId"];
            this.formTypeId = _data["formTypeId"];
            this.formStatusId = _data["formStatusId"];
            if (Array.isArray(_data["businessUnitsNewIds"])) {
                this.businessUnitsNewIds = [] as any;
                for (let item of _data["businessUnitsNewIds"])
                    this.businessUnitsNewIds.push(item);
            }
            if (Array.isArray(_data["businessUnitsUpdatedIds"])) {
                this.businessUnitsUpdatedIds = [] as any;
                for (let item of _data["businessUnitsUpdatedIds"])
                    this.businessUnitsUpdatedIds.push(item);
            }
        }
    }

    static fromJS(data: any): FormEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formCode"] = this.formCode;
        data["isActive"] = this.isActive;
        data["isPublished"] = this.isPublished;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
        data["businessRoleId"] = this.businessRoleId;
        data["formTypeId"] = this.formTypeId;
        data["formStatusId"] = this.formStatusId;
        if (Array.isArray(this.businessUnitsNewIds)) {
            data["businessUnitsNewIds"] = [];
            for (let item of this.businessUnitsNewIds)
                data["businessUnitsNewIds"].push(item);
        }
        if (Array.isArray(this.businessUnitsUpdatedIds)) {
            data["businessUnitsUpdatedIds"] = [];
            for (let item of this.businessUnitsUpdatedIds)
                data["businessUnitsUpdatedIds"].push(item);
        }
        return data; 
    }

    clone(): FormEditDto {
        const json = this.toJSON();
        let result = new FormEditDto();
        result.init(json);
        return result;
    }
}

export interface IFormEditDto {
    id: number | undefined;
    formCode: string | undefined;
    isActive: boolean;
    isPublished: boolean;
    publishDate: moment.Moment;
    businessRoleId: number;
    formTypeId: number;
    formStatusId: number;
    businessUnitsNewIds: number[] | undefined;
    businessUnitsUpdatedIds: number[] | undefined;
}

export class GetFormEditOutput implements IGetFormEditOutput {
    form: FormEditDto;

    constructor(data?: IGetFormEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.form = _data["form"] ? FormEditDto.fromJS(_data["form"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetFormEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFormEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["form"] = this.form ? this.form.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetFormEditOutput {
        const json = this.toJSON();
        let result = new GetFormEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetFormEditOutput {
    form: FormEditDto;
}

export class FormAddDto implements IFormAddDto {
    id: number | undefined;
    formCode: string | undefined;
    isActive: boolean;
    isPublished: boolean;
    publishDate: moment.Moment;
    businessRoleId: number;
    formTypeId: number;
    formStatusId: number;
    businessUnitsIds: number[] | undefined;
    displayTypeId: number;

    constructor(data?: IFormAddDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formCode = _data["formCode"];
            this.isActive = _data["isActive"];
            this.isPublished = _data["isPublished"];
            this.publishDate = _data["publishDate"] ? moment(_data["publishDate"].toString()) : <any>undefined;
            this.businessRoleId = _data["businessRoleId"];
            this.formTypeId = _data["formTypeId"];
            this.formStatusId = _data["formStatusId"];
            if (Array.isArray(_data["businessUnitsIds"])) {
                this.businessUnitsIds = [] as any;
                for (let item of _data["businessUnitsIds"])
                    this.businessUnitsIds.push(item);
            }
            this.displayTypeId = _data["displayTypeId"];
        }
    }

    static fromJS(data: any): FormAddDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormAddDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formCode"] = this.formCode;
        data["isActive"] = this.isActive;
        data["isPublished"] = this.isPublished;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
        data["businessRoleId"] = this.businessRoleId;
        data["formTypeId"] = this.formTypeId;
        data["formStatusId"] = this.formStatusId;
        if (Array.isArray(this.businessUnitsIds)) {
            data["businessUnitsIds"] = [];
            for (let item of this.businessUnitsIds)
                data["businessUnitsIds"].push(item);
        }
        data["displayTypeId"] = this.displayTypeId;
        return data; 
    }

    clone(): FormAddDto {
        const json = this.toJSON();
        let result = new FormAddDto();
        result.init(json);
        return result;
    }
}

export interface IFormAddDto {
    id: number | undefined;
    formCode: string | undefined;
    isActive: boolean;
    isPublished: boolean;
    publishDate: moment.Moment;
    businessRoleId: number;
    formTypeId: number;
    formStatusId: number;
    businessUnitsIds: number[] | undefined;
    displayTypeId: number;
}

export class CreateFormDto implements ICreateFormDto {
    form: FormAddDto;

    constructor(data?: ICreateFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.form = _data["form"] ? FormAddDto.fromJS(_data["form"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["form"] = this.form ? this.form.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateFormDto {
        const json = this.toJSON();
        let result = new CreateFormDto();
        result.init(json);
        return result;
    }
}

export interface ICreateFormDto {
    form: FormAddDto;
}

export class UpdateFormDto implements IUpdateFormDto {
    form: FormEditDto;

    constructor(data?: IUpdateFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.form = _data["form"] ? FormEditDto.fromJS(_data["form"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["form"] = this.form ? this.form.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UpdateFormDto {
        const json = this.toJSON();
        let result = new UpdateFormDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateFormDto {
    form: FormEditDto;
}

export class UpdateFormStatusDto implements IUpdateFormStatusDto {
    formId: number;
    formStatusId: number;

    constructor(data?: IUpdateFormStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.formStatusId = _data["formStatusId"];
        }
    }

    static fromJS(data: any): UpdateFormStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFormStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["formStatusId"] = this.formStatusId;
        return data; 
    }

    clone(): UpdateFormStatusDto {
        const json = this.toJSON();
        let result = new UpdateFormStatusDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateFormStatusDto {
    formId: number;
    formStatusId: number;
}

export class FormStructureColumnDto implements IFormStructureColumnDto {
    parentId: number;
    bindSource: string | undefined;
    header: string | undefined;
    order: number | undefined;
    formStructureRowId: number;
    columnStructureId: number | undefined;
    isPercentage: boolean;
    isDeleted: boolean;
    id: number | undefined;

    constructor(data?: IFormStructureColumnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.bindSource = _data["bindSource"];
            this.header = _data["header"];
            this.order = _data["order"];
            this.formStructureRowId = _data["formStructureRowId"];
            this.columnStructureId = _data["columnStructureId"];
            this.isPercentage = _data["isPercentage"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormStructureColumnDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStructureColumnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["bindSource"] = this.bindSource;
        data["header"] = this.header;
        data["order"] = this.order;
        data["formStructureRowId"] = this.formStructureRowId;
        data["columnStructureId"] = this.columnStructureId;
        data["isPercentage"] = this.isPercentage;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormStructureColumnDto {
        const json = this.toJSON();
        let result = new FormStructureColumnDto();
        result.init(json);
        return result;
    }
}

export interface IFormStructureColumnDto {
    parentId: number;
    bindSource: string | undefined;
    header: string | undefined;
    order: number | undefined;
    formStructureRowId: number;
    columnStructureId: number | undefined;
    isPercentage: boolean;
    isDeleted: boolean;
    id: number | undefined;
}

export class ActivityCountDto implements IActivityCountDto {
    taskCount: number;
    issueCount: number;
    meetingCount: number;

    constructor(data?: IActivityCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskCount = _data["taskCount"];
            this.issueCount = _data["issueCount"];
            this.meetingCount = _data["meetingCount"];
        }
    }

    static fromJS(data: any): ActivityCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskCount"] = this.taskCount;
        data["issueCount"] = this.issueCount;
        data["meetingCount"] = this.meetingCount;
        return data; 
    }

    clone(): ActivityCountDto {
        const json = this.toJSON();
        let result = new ActivityCountDto();
        result.init(json);
        return result;
    }
}

export interface IActivityCountDto {
    taskCount: number;
    issueCount: number;
    meetingCount: number;
}

export class FormStructureRowDto implements IFormStructureRowDto {
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;

    constructor(data?: IFormStructureRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.code = _data["code"];
            this.order = _data["order"];
            this.parentId = _data["parentId"];
            this.isLeaf = _data["isLeaf"];
            this.rowTypeId = _data["rowTypeId"];
            this.structureTypeId = _data["structureTypeId"];
            this.structureId = _data["structureId"];
            this.activityCountDto = _data["activityCountDto"] ? ActivityCountDto.fromJS(_data["activityCountDto"]) : <any>undefined;
            this.referenceData = _data["referenceData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormStructureRowDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStructureRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["code"] = this.code;
        data["order"] = this.order;
        data["parentId"] = this.parentId;
        data["isLeaf"] = this.isLeaf;
        data["rowTypeId"] = this.rowTypeId;
        data["structureTypeId"] = this.structureTypeId;
        data["structureId"] = this.structureId;
        data["activityCountDto"] = this.activityCountDto ? this.activityCountDto.toJSON() : <any>undefined;
        data["referenceData"] = this.referenceData;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormStructureRowDto {
        const json = this.toJSON();
        let result = new FormStructureRowDto();
        result.init(json);
        return result;
    }
}

export interface IFormStructureRowDto {
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;
}

export class FormStructurePercentageDto implements IFormStructurePercentageDto {
    formStructureRowId: number;
    formStructureColumnId: number;
    isPercentage: boolean;
    formStructureRowDto: FormStructureRowDto;
    formStructureColumnDto: FormStructureColumnDto;
    id: number;

    constructor(data?: IFormStructurePercentageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructureRowId = _data["formStructureRowId"];
            this.formStructureColumnId = _data["formStructureColumnId"];
            this.isPercentage = _data["isPercentage"];
            this.formStructureRowDto = _data["formStructureRowDto"] ? FormStructureRowDto.fromJS(_data["formStructureRowDto"]) : <any>undefined;
            this.formStructureColumnDto = _data["formStructureColumnDto"] ? FormStructureColumnDto.fromJS(_data["formStructureColumnDto"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormStructurePercentageDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStructurePercentageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructureRowId"] = this.formStructureRowId;
        data["formStructureColumnId"] = this.formStructureColumnId;
        data["isPercentage"] = this.isPercentage;
        data["formStructureRowDto"] = this.formStructureRowDto ? this.formStructureRowDto.toJSON() : <any>undefined;
        data["formStructureColumnDto"] = this.formStructureColumnDto ? this.formStructureColumnDto.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormStructurePercentageDto {
        const json = this.toJSON();
        let result = new FormStructurePercentageDto();
        result.init(json);
        return result;
    }
}

export interface IFormStructurePercentageDto {
    formStructureRowId: number;
    formStructureColumnId: number;
    isPercentage: boolean;
    formStructureRowDto: FormStructureRowDto;
    formStructureColumnDto: FormStructureColumnDto;
    id: number;
}

export class FormStructerDataCellDto implements IFormStructerDataCellDto {
    structureId: number;
    dataId: number | undefined;
    typeId: number;
    value: number | undefined;
    formRowId: number;
    formColumnId: number;
    columnOrder: number;
    columnBindSource: string | undefined;
    columnHeader: string | undefined;
    columnIsPercentage: boolean;
    activityCountDto: ActivityCountDto;
    isDeleted: boolean;

    constructor(data?: IFormStructerDataCellDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.structureId = _data["structureId"];
            this.dataId = _data["dataId"];
            this.typeId = _data["typeId"];
            this.value = _data["value"];
            this.formRowId = _data["formRowId"];
            this.formColumnId = _data["formColumnId"];
            this.columnOrder = _data["columnOrder"];
            this.columnBindSource = _data["columnBindSource"];
            this.columnHeader = _data["columnHeader"];
            this.columnIsPercentage = _data["columnIsPercentage"];
            this.activityCountDto = _data["activityCountDto"] ? ActivityCountDto.fromJS(_data["activityCountDto"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): FormStructerDataCellDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStructerDataCellDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["structureId"] = this.structureId;
        data["dataId"] = this.dataId;
        data["typeId"] = this.typeId;
        data["value"] = this.value;
        data["formRowId"] = this.formRowId;
        data["formColumnId"] = this.formColumnId;
        data["columnOrder"] = this.columnOrder;
        data["columnBindSource"] = this.columnBindSource;
        data["columnHeader"] = this.columnHeader;
        data["columnIsPercentage"] = this.columnIsPercentage;
        data["activityCountDto"] = this.activityCountDto ? this.activityCountDto.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        return data; 
    }

    clone(): FormStructerDataCellDto {
        const json = this.toJSON();
        let result = new FormStructerDataCellDto();
        result.init(json);
        return result;
    }
}

export interface IFormStructerDataCellDto {
    structureId: number;
    dataId: number | undefined;
    typeId: number;
    value: number | undefined;
    formRowId: number;
    formColumnId: number;
    columnOrder: number;
    columnBindSource: string | undefined;
    columnHeader: string | undefined;
    columnIsPercentage: boolean;
    activityCountDto: ActivityCountDto;
    isDeleted: boolean;
}

export class FormDimensionWeekDto implements IFormDimensionWeekDto {
    week: number | undefined;
    month: number | undefined;
    year: number | undefined;
    isDistrbuted: boolean;
    isDeleted: boolean;
    cells: FormStructerDataCellDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;

    constructor(data?: IFormDimensionWeekDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.week = _data["week"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.isDistrbuted = _data["isDistrbuted"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["cells"])) {
                this.cells = [] as any;
                for (let item of _data["cells"])
                    this.cells.push(FormStructerDataCellDto.fromJS(item));
            }
            this.title = _data["title"];
            this.code = _data["code"];
            this.order = _data["order"];
            this.parentId = _data["parentId"];
            this.isLeaf = _data["isLeaf"];
            this.rowTypeId = _data["rowTypeId"];
            this.structureTypeId = _data["structureTypeId"];
            this.structureId = _data["structureId"];
            this.activityCountDto = _data["activityCountDto"] ? ActivityCountDto.fromJS(_data["activityCountDto"]) : <any>undefined;
            this.referenceData = _data["referenceData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormDimensionWeekDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDimensionWeekDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["week"] = this.week;
        data["month"] = this.month;
        data["year"] = this.year;
        data["isDistrbuted"] = this.isDistrbuted;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.cells)) {
            data["cells"] = [];
            for (let item of this.cells)
                data["cells"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["code"] = this.code;
        data["order"] = this.order;
        data["parentId"] = this.parentId;
        data["isLeaf"] = this.isLeaf;
        data["rowTypeId"] = this.rowTypeId;
        data["structureTypeId"] = this.structureTypeId;
        data["structureId"] = this.structureId;
        data["activityCountDto"] = this.activityCountDto ? this.activityCountDto.toJSON() : <any>undefined;
        data["referenceData"] = this.referenceData;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormDimensionWeekDto {
        const json = this.toJSON();
        let result = new FormDimensionWeekDto();
        result.init(json);
        return result;
    }
}

export interface IFormDimensionWeekDto {
    week: number | undefined;
    month: number | undefined;
    year: number | undefined;
    isDistrbuted: boolean;
    isDeleted: boolean;
    cells: FormStructerDataCellDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;
}

export enum ReferenceType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class DimensionWeekDto implements IDimensionWeekDto {
    referenceWeekCells: number[] | undefined;
    id: number;

    constructor(data?: IDimensionWeekDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["referenceWeekCells"])) {
                this.referenceWeekCells = [] as any;
                for (let item of _data["referenceWeekCells"])
                    this.referenceWeekCells.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DimensionWeekDto {
        data = typeof data === 'object' ? data : {};
        let result = new DimensionWeekDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.referenceWeekCells)) {
            data["referenceWeekCells"] = [];
            for (let item of this.referenceWeekCells)
                data["referenceWeekCells"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): DimensionWeekDto {
        const json = this.toJSON();
        let result = new DimensionWeekDto();
        result.init(json);
        return result;
    }
}

export interface IDimensionWeekDto {
    referenceWeekCells: number[] | undefined;
    id: number;
}

export class ReferenceDimensionSumDto implements IReferenceDimensionSumDto {
    referenceType: ReferenceType;
    dimensionTitle: string | undefined;
    referenceDimensionCells: number[] | undefined;
    referenceDimensionWeeks: DimensionWeekDto[] | undefined;
    id: number;

    constructor(data?: IReferenceDimensionSumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.referenceType = _data["referenceType"];
            this.dimensionTitle = _data["dimensionTitle"];
            if (Array.isArray(_data["referenceDimensionCells"])) {
                this.referenceDimensionCells = [] as any;
                for (let item of _data["referenceDimensionCells"])
                    this.referenceDimensionCells.push(item);
            }
            if (Array.isArray(_data["referenceDimensionWeeks"])) {
                this.referenceDimensionWeeks = [] as any;
                for (let item of _data["referenceDimensionWeeks"])
                    this.referenceDimensionWeeks.push(DimensionWeekDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ReferenceDimensionSumDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceDimensionSumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceType"] = this.referenceType;
        data["dimensionTitle"] = this.dimensionTitle;
        if (Array.isArray(this.referenceDimensionCells)) {
            data["referenceDimensionCells"] = [];
            for (let item of this.referenceDimensionCells)
                data["referenceDimensionCells"].push(item);
        }
        if (Array.isArray(this.referenceDimensionWeeks)) {
            data["referenceDimensionWeeks"] = [];
            for (let item of this.referenceDimensionWeeks)
                data["referenceDimensionWeeks"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): ReferenceDimensionSumDto {
        const json = this.toJSON();
        let result = new ReferenceDimensionSumDto();
        result.init(json);
        return result;
    }
}

export interface IReferenceDimensionSumDto {
    referenceType: ReferenceType;
    dimensionTitle: string | undefined;
    referenceDimensionCells: number[] | undefined;
    referenceDimensionWeeks: DimensionWeekDto[] | undefined;
    id: number;
}

export class FormDimensionDataDto implements IFormDimensionDataDto {
    showValues: boolean;
    dimensionWeeks: FormDimensionWeekDto[] | undefined;
    referenceId: number;
    referenceType: ReferenceType;
    refDimensionSum: ReferenceDimensionSumDto[] | undefined;
    isDeleted: boolean;
    cells: FormStructerDataCellDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;

    constructor(data?: IFormDimensionDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showValues = _data["showValues"];
            if (Array.isArray(_data["dimensionWeeks"])) {
                this.dimensionWeeks = [] as any;
                for (let item of _data["dimensionWeeks"])
                    this.dimensionWeeks.push(FormDimensionWeekDto.fromJS(item));
            }
            this.referenceId = _data["referenceId"];
            this.referenceType = _data["referenceType"];
            if (Array.isArray(_data["refDimensionSum"])) {
                this.refDimensionSum = [] as any;
                for (let item of _data["refDimensionSum"])
                    this.refDimensionSum.push(ReferenceDimensionSumDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["cells"])) {
                this.cells = [] as any;
                for (let item of _data["cells"])
                    this.cells.push(FormStructerDataCellDto.fromJS(item));
            }
            this.title = _data["title"];
            this.code = _data["code"];
            this.order = _data["order"];
            this.parentId = _data["parentId"];
            this.isLeaf = _data["isLeaf"];
            this.rowTypeId = _data["rowTypeId"];
            this.structureTypeId = _data["structureTypeId"];
            this.structureId = _data["structureId"];
            this.activityCountDto = _data["activityCountDto"] ? ActivityCountDto.fromJS(_data["activityCountDto"]) : <any>undefined;
            this.referenceData = _data["referenceData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormDimensionDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDimensionDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showValues"] = this.showValues;
        if (Array.isArray(this.dimensionWeeks)) {
            data["dimensionWeeks"] = [];
            for (let item of this.dimensionWeeks)
                data["dimensionWeeks"].push(item.toJSON());
        }
        data["referenceId"] = this.referenceId;
        data["referenceType"] = this.referenceType;
        if (Array.isArray(this.refDimensionSum)) {
            data["refDimensionSum"] = [];
            for (let item of this.refDimensionSum)
                data["refDimensionSum"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.cells)) {
            data["cells"] = [];
            for (let item of this.cells)
                data["cells"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["code"] = this.code;
        data["order"] = this.order;
        data["parentId"] = this.parentId;
        data["isLeaf"] = this.isLeaf;
        data["rowTypeId"] = this.rowTypeId;
        data["structureTypeId"] = this.structureTypeId;
        data["structureId"] = this.structureId;
        data["activityCountDto"] = this.activityCountDto ? this.activityCountDto.toJSON() : <any>undefined;
        data["referenceData"] = this.referenceData;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormDimensionDataDto {
        const json = this.toJSON();
        let result = new FormDimensionDataDto();
        result.init(json);
        return result;
    }
}

export interface IFormDimensionDataDto {
    showValues: boolean;
    dimensionWeeks: FormDimensionWeekDto[] | undefined;
    referenceId: number;
    referenceType: ReferenceType;
    refDimensionSum: ReferenceDimensionSumDto[] | undefined;
    isDeleted: boolean;
    cells: FormStructerDataCellDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;
}

export class FormKPIDto implements IFormKPIDto {
    showValues: boolean;
    formStructurePercentages: FormStructurePercentageDto[] | undefined;
    dimensionWeeks: FormDimensionWeekDto[] | undefined;
    dimensions: FormDimensionDataDto[] | undefined;
    columns: FormStructureColumnDto[] | undefined;
    referenceId: number;
    referenceType: ReferenceType;
    isDeleted: boolean;
    cells: FormStructerDataCellDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;

    constructor(data?: IFormKPIDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showValues = _data["showValues"];
            if (Array.isArray(_data["formStructurePercentages"])) {
                this.formStructurePercentages = [] as any;
                for (let item of _data["formStructurePercentages"])
                    this.formStructurePercentages.push(FormStructurePercentageDto.fromJS(item));
            }
            if (Array.isArray(_data["dimensionWeeks"])) {
                this.dimensionWeeks = [] as any;
                for (let item of _data["dimensionWeeks"])
                    this.dimensionWeeks.push(FormDimensionWeekDto.fromJS(item));
            }
            if (Array.isArray(_data["dimensions"])) {
                this.dimensions = [] as any;
                for (let item of _data["dimensions"])
                    this.dimensions.push(FormDimensionDataDto.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(FormStructureColumnDto.fromJS(item));
            }
            this.referenceId = _data["referenceId"];
            this.referenceType = _data["referenceType"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["cells"])) {
                this.cells = [] as any;
                for (let item of _data["cells"])
                    this.cells.push(FormStructerDataCellDto.fromJS(item));
            }
            this.title = _data["title"];
            this.code = _data["code"];
            this.order = _data["order"];
            this.parentId = _data["parentId"];
            this.isLeaf = _data["isLeaf"];
            this.rowTypeId = _data["rowTypeId"];
            this.structureTypeId = _data["structureTypeId"];
            this.structureId = _data["structureId"];
            this.activityCountDto = _data["activityCountDto"] ? ActivityCountDto.fromJS(_data["activityCountDto"]) : <any>undefined;
            this.referenceData = _data["referenceData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormKPIDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormKPIDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showValues"] = this.showValues;
        if (Array.isArray(this.formStructurePercentages)) {
            data["formStructurePercentages"] = [];
            for (let item of this.formStructurePercentages)
                data["formStructurePercentages"].push(item.toJSON());
        }
        if (Array.isArray(this.dimensionWeeks)) {
            data["dimensionWeeks"] = [];
            for (let item of this.dimensionWeeks)
                data["dimensionWeeks"].push(item.toJSON());
        }
        if (Array.isArray(this.dimensions)) {
            data["dimensions"] = [];
            for (let item of this.dimensions)
                data["dimensions"].push(item.toJSON());
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        data["referenceId"] = this.referenceId;
        data["referenceType"] = this.referenceType;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.cells)) {
            data["cells"] = [];
            for (let item of this.cells)
                data["cells"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["code"] = this.code;
        data["order"] = this.order;
        data["parentId"] = this.parentId;
        data["isLeaf"] = this.isLeaf;
        data["rowTypeId"] = this.rowTypeId;
        data["structureTypeId"] = this.structureTypeId;
        data["structureId"] = this.structureId;
        data["activityCountDto"] = this.activityCountDto ? this.activityCountDto.toJSON() : <any>undefined;
        data["referenceData"] = this.referenceData;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormKPIDto {
        const json = this.toJSON();
        let result = new FormKPIDto();
        result.init(json);
        return result;
    }
}

export interface IFormKPIDto {
    showValues: boolean;
    formStructurePercentages: FormStructurePercentageDto[] | undefined;
    dimensionWeeks: FormDimensionWeekDto[] | undefined;
    dimensions: FormDimensionDataDto[] | undefined;
    columns: FormStructureColumnDto[] | undefined;
    referenceId: number;
    referenceType: ReferenceType;
    isDeleted: boolean;
    cells: FormStructerDataCellDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;
}

export class FormSubsectionDto implements IFormSubsectionDto {
    columns: FormStructureColumnDto[] | undefined;
    kpis: FormKPIDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;

    constructor(data?: IFormSubsectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(FormStructureColumnDto.fromJS(item));
            }
            if (Array.isArray(_data["kpis"])) {
                this.kpis = [] as any;
                for (let item of _data["kpis"])
                    this.kpis.push(FormKPIDto.fromJS(item));
            }
            this.title = _data["title"];
            this.code = _data["code"];
            this.order = _data["order"];
            this.parentId = _data["parentId"];
            this.isLeaf = _data["isLeaf"];
            this.rowTypeId = _data["rowTypeId"];
            this.structureTypeId = _data["structureTypeId"];
            this.structureId = _data["structureId"];
            this.activityCountDto = _data["activityCountDto"] ? ActivityCountDto.fromJS(_data["activityCountDto"]) : <any>undefined;
            this.referenceData = _data["referenceData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormSubsectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormSubsectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.kpis)) {
            data["kpis"] = [];
            for (let item of this.kpis)
                data["kpis"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["code"] = this.code;
        data["order"] = this.order;
        data["parentId"] = this.parentId;
        data["isLeaf"] = this.isLeaf;
        data["rowTypeId"] = this.rowTypeId;
        data["structureTypeId"] = this.structureTypeId;
        data["structureId"] = this.structureId;
        data["activityCountDto"] = this.activityCountDto ? this.activityCountDto.toJSON() : <any>undefined;
        data["referenceData"] = this.referenceData;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormSubsectionDto {
        const json = this.toJSON();
        let result = new FormSubsectionDto();
        result.init(json);
        return result;
    }
}

export interface IFormSubsectionDto {
    columns: FormStructureColumnDto[] | undefined;
    kpis: FormKPIDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;
}

export class FormSectionDto implements IFormSectionDto {
    subsections: FormSubsectionDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;

    constructor(data?: IFormSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["subsections"])) {
                this.subsections = [] as any;
                for (let item of _data["subsections"])
                    this.subsections.push(FormSubsectionDto.fromJS(item));
            }
            this.title = _data["title"];
            this.code = _data["code"];
            this.order = _data["order"];
            this.parentId = _data["parentId"];
            this.isLeaf = _data["isLeaf"];
            this.rowTypeId = _data["rowTypeId"];
            this.structureTypeId = _data["structureTypeId"];
            this.structureId = _data["structureId"];
            this.activityCountDto = _data["activityCountDto"] ? ActivityCountDto.fromJS(_data["activityCountDto"]) : <any>undefined;
            this.referenceData = _data["referenceData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.subsections)) {
            data["subsections"] = [];
            for (let item of this.subsections)
                data["subsections"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["code"] = this.code;
        data["order"] = this.order;
        data["parentId"] = this.parentId;
        data["isLeaf"] = this.isLeaf;
        data["rowTypeId"] = this.rowTypeId;
        data["structureTypeId"] = this.structureTypeId;
        data["structureId"] = this.structureId;
        data["activityCountDto"] = this.activityCountDto ? this.activityCountDto.toJSON() : <any>undefined;
        data["referenceData"] = this.referenceData;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormSectionDto {
        const json = this.toJSON();
        let result = new FormSectionDto();
        result.init(json);
        return result;
    }
}

export interface IFormSectionDto {
    subsections: FormSubsectionDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;
}

export class FormStructureDataDto implements IFormStructureDataDto {
    formId: number;
    businessUnitId: number;
    sections: FormSectionDto[] | undefined;

    constructor(data?: IFormStructureDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.businessUnitId = _data["businessUnitId"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections.push(FormSectionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormStructureDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStructureDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["businessUnitId"] = this.businessUnitId;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FormStructureDataDto {
        const json = this.toJSON();
        let result = new FormStructureDataDto();
        result.init(json);
        return result;
    }
}

export interface IFormStructureDataDto {
    formId: number;
    businessUnitId: number;
    sections: FormSectionDto[] | undefined;
}

export class BusinessFormListDto implements IBusinessFormListDto {
    businessUnitId: number;
    businessUnitTitle: string | undefined;

    constructor(data?: IBusinessFormListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessUnitId = _data["businessUnitId"];
            this.businessUnitTitle = _data["businessUnitTitle"];
        }
    }

    static fromJS(data: any): BusinessFormListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessFormListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessUnitId"] = this.businessUnitId;
        data["businessUnitTitle"] = this.businessUnitTitle;
        return data; 
    }

    clone(): BusinessFormListDto {
        const json = this.toJSON();
        let result = new BusinessFormListDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessFormListDto {
    businessUnitId: number;
    businessUnitTitle: string | undefined;
}

export class BusinessFormEditDto implements IBusinessFormEditDto {
    id: number | undefined;
    businessUnitId: number;
    formId: number;

    constructor(data?: IBusinessFormEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessUnitId = _data["businessUnitId"];
            this.formId = _data["formId"];
        }
    }

    static fromJS(data: any): BusinessFormEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessFormEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessUnitId"] = this.businessUnitId;
        data["formId"] = this.formId;
        return data; 
    }

    clone(): BusinessFormEditDto {
        const json = this.toJSON();
        let result = new BusinessFormEditDto();
        result.init(json);
        return result;
    }
}

export interface IBusinessFormEditDto {
    id: number | undefined;
    businessUnitId: number;
    formId: number;
}

export class GetBusinessFormEditOutput implements IGetBusinessFormEditOutput {
    businessForm: BusinessFormEditDto;

    constructor(data?: IGetBusinessFormEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessForm = _data["businessForm"] ? BusinessFormEditDto.fromJS(_data["businessForm"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBusinessFormEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessFormEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessForm"] = this.businessForm ? this.businessForm.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetBusinessFormEditOutput {
        const json = this.toJSON();
        let result = new GetBusinessFormEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBusinessFormEditOutput {
    businessForm: BusinessFormEditDto;
}

export class CreateOrUpdateBusinessFormDto implements ICreateOrUpdateBusinessFormDto {
    businessForm: BusinessFormEditDto;

    constructor(data?: ICreateOrUpdateBusinessFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessForm = _data["businessForm"] ? BusinessFormEditDto.fromJS(_data["businessForm"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateBusinessFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBusinessFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessForm"] = this.businessForm ? this.businessForm.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateBusinessFormDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateBusinessFormDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateBusinessFormDto {
    businessForm: BusinessFormEditDto;
}

export class FormDataCellDto implements IFormDataCellDto {
    structureId: number;
    dataId: number;
    value: number;
    week: number;
    month: number;
    year: number;
    columnBindSource: string | undefined;

    constructor(data?: IFormDataCellDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.structureId = _data["structureId"];
            this.dataId = _data["dataId"];
            this.value = _data["value"];
            this.week = _data["week"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.columnBindSource = _data["columnBindSource"];
        }
    }

    static fromJS(data: any): FormDataCellDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDataCellDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["structureId"] = this.structureId;
        data["dataId"] = this.dataId;
        data["value"] = this.value;
        data["week"] = this.week;
        data["month"] = this.month;
        data["year"] = this.year;
        data["columnBindSource"] = this.columnBindSource;
        return data; 
    }

    clone(): FormDataCellDto {
        const json = this.toJSON();
        let result = new FormDataCellDto();
        result.init(json);
        return result;
    }
}

export interface IFormDataCellDto {
    structureId: number;
    dataId: number;
    value: number;
    week: number;
    month: number;
    year: number;
    columnBindSource: string | undefined;
}

export class UpdateFormDataDto implements IUpdateFormDataDto {
    userId: number;
    formId: number;
    businessUnitId: number;
    changedCellDataId: number;
    changedCellStructureId: number;
    formDataCells: FormDataCellDto[] | undefined;

    constructor(data?: IUpdateFormDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.formId = _data["formId"];
            this.businessUnitId = _data["businessUnitId"];
            this.changedCellDataId = _data["changedCellDataId"];
            this.changedCellStructureId = _data["changedCellStructureId"];
            if (Array.isArray(_data["formDataCells"])) {
                this.formDataCells = [] as any;
                for (let item of _data["formDataCells"])
                    this.formDataCells.push(FormDataCellDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateFormDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFormDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["formId"] = this.formId;
        data["businessUnitId"] = this.businessUnitId;
        data["changedCellDataId"] = this.changedCellDataId;
        data["changedCellStructureId"] = this.changedCellStructureId;
        if (Array.isArray(this.formDataCells)) {
            data["formDataCells"] = [];
            for (let item of this.formDataCells)
                data["formDataCells"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateFormDataDto {
        const json = this.toJSON();
        let result = new UpdateFormDataDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateFormDataDto {
    userId: number;
    formId: number;
    businessUnitId: number;
    changedCellDataId: number;
    changedCellStructureId: number;
    formDataCells: FormDataCellDto[] | undefined;
}

export class FormDesignerSubSectionDto implements IFormDesignerSubSectionDto {
    subSectionId: number;
    formSubSectionId: number;
    subSectionTitle: string | undefined;
    subSectionTypeId: number;
    parentSectionId: number | undefined;
    order: number;
    isLeaf: boolean;
    formId: number;
    isDeleted: boolean;

    constructor(data?: IFormDesignerSubSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subSectionId = _data["subSectionId"];
            this.formSubSectionId = _data["formSubSectionId"];
            this.subSectionTitle = _data["subSectionTitle"];
            this.subSectionTypeId = _data["subSectionTypeId"];
            this.parentSectionId = _data["parentSectionId"];
            this.order = _data["order"];
            this.isLeaf = _data["isLeaf"];
            this.formId = _data["formId"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): FormDesignerSubSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDesignerSubSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subSectionId"] = this.subSectionId;
        data["formSubSectionId"] = this.formSubSectionId;
        data["subSectionTitle"] = this.subSectionTitle;
        data["subSectionTypeId"] = this.subSectionTypeId;
        data["parentSectionId"] = this.parentSectionId;
        data["order"] = this.order;
        data["isLeaf"] = this.isLeaf;
        data["formId"] = this.formId;
        data["isDeleted"] = this.isDeleted;
        return data; 
    }

    clone(): FormDesignerSubSectionDto {
        const json = this.toJSON();
        let result = new FormDesignerSubSectionDto();
        result.init(json);
        return result;
    }
}

export interface IFormDesignerSubSectionDto {
    subSectionId: number;
    formSubSectionId: number;
    subSectionTitle: string | undefined;
    subSectionTypeId: number;
    parentSectionId: number | undefined;
    order: number;
    isLeaf: boolean;
    formId: number;
    isDeleted: boolean;
}

export class FormDesignerSectionDto implements IFormDesignerSectionDto {
    sectionId: number;
    formSectionId: number;
    sectionTitle: string | undefined;
    sectionTypeId: number;
    parentSectionId: number | undefined;
    order: number;
    isLeaf: boolean;
    formId: number;
    isDeleted: boolean;
    childern: FormDesignerSubSectionDto[] | undefined;

    constructor(data?: IFormDesignerSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sectionId = _data["sectionId"];
            this.formSectionId = _data["formSectionId"];
            this.sectionTitle = _data["sectionTitle"];
            this.sectionTypeId = _data["sectionTypeId"];
            this.parentSectionId = _data["parentSectionId"];
            this.order = _data["order"];
            this.isLeaf = _data["isLeaf"];
            this.formId = _data["formId"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["childern"])) {
                this.childern = [] as any;
                for (let item of _data["childern"])
                    this.childern.push(FormDesignerSubSectionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormDesignerSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDesignerSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectionId"] = this.sectionId;
        data["formSectionId"] = this.formSectionId;
        data["sectionTitle"] = this.sectionTitle;
        data["sectionTypeId"] = this.sectionTypeId;
        data["parentSectionId"] = this.parentSectionId;
        data["order"] = this.order;
        data["isLeaf"] = this.isLeaf;
        data["formId"] = this.formId;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.childern)) {
            data["childern"] = [];
            for (let item of this.childern)
                data["childern"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FormDesignerSectionDto {
        const json = this.toJSON();
        let result = new FormDesignerSectionDto();
        result.init(json);
        return result;
    }
}

export interface IFormDesignerSectionDto {
    sectionId: number;
    formSectionId: number;
    sectionTitle: string | undefined;
    sectionTypeId: number;
    parentSectionId: number | undefined;
    order: number;
    isLeaf: boolean;
    formId: number;
    isDeleted: boolean;
    childern: FormDesignerSubSectionDto[] | undefined;
}

export class FormDesignerAllSectionsDto implements IFormDesignerAllSectionsDto {
    formDesignerSectionDto: FormDesignerSectionDto[] | undefined;
    mainSections: FormDesignerSectionDto[] | undefined;

    constructor(data?: IFormDesignerAllSectionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["formDesignerSectionDto"])) {
                this.formDesignerSectionDto = [] as any;
                for (let item of _data["formDesignerSectionDto"])
                    this.formDesignerSectionDto.push(FormDesignerSectionDto.fromJS(item));
            }
            if (Array.isArray(_data["mainSections"])) {
                this.mainSections = [] as any;
                for (let item of _data["mainSections"])
                    this.mainSections.push(FormDesignerSectionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormDesignerAllSectionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDesignerAllSectionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.formDesignerSectionDto)) {
            data["formDesignerSectionDto"] = [];
            for (let item of this.formDesignerSectionDto)
                data["formDesignerSectionDto"].push(item.toJSON());
        }
        if (Array.isArray(this.mainSections)) {
            data["mainSections"] = [];
            for (let item of this.mainSections)
                data["mainSections"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FormDesignerAllSectionsDto {
        const json = this.toJSON();
        let result = new FormDesignerAllSectionsDto();
        result.init(json);
        return result;
    }
}

export interface IFormDesignerAllSectionsDto {
    formDesignerSectionDto: FormDesignerSectionDto[] | undefined;
    mainSections: FormDesignerSectionDto[] | undefined;
}

export class MainSubSectionsDto implements IMainSubSectionsDto {
    subSectionId: number;
    formSubSectionId: number;
    subSectionTitle: string | undefined;
    subSectionTypeId: number;
    parentSectionId: number | undefined;
    order: number;
    isLeaf: boolean;
    formId: number;
    isDeleted: boolean;

    constructor(data?: IMainSubSectionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subSectionId = _data["subSectionId"];
            this.formSubSectionId = _data["formSubSectionId"];
            this.subSectionTitle = _data["subSectionTitle"];
            this.subSectionTypeId = _data["subSectionTypeId"];
            this.parentSectionId = _data["parentSectionId"];
            this.order = _data["order"];
            this.isLeaf = _data["isLeaf"];
            this.formId = _data["formId"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): MainSubSectionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainSubSectionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subSectionId"] = this.subSectionId;
        data["formSubSectionId"] = this.formSubSectionId;
        data["subSectionTitle"] = this.subSectionTitle;
        data["subSectionTypeId"] = this.subSectionTypeId;
        data["parentSectionId"] = this.parentSectionId;
        data["order"] = this.order;
        data["isLeaf"] = this.isLeaf;
        data["formId"] = this.formId;
        data["isDeleted"] = this.isDeleted;
        return data; 
    }

    clone(): MainSubSectionsDto {
        const json = this.toJSON();
        let result = new MainSubSectionsDto();
        result.init(json);
        return result;
    }
}

export interface IMainSubSectionsDto {
    subSectionId: number;
    formSubSectionId: number;
    subSectionTitle: string | undefined;
    subSectionTypeId: number;
    parentSectionId: number | undefined;
    order: number;
    isLeaf: boolean;
    formId: number;
    isDeleted: boolean;
}

export class FormDesignerAllSubSectionsDto implements IFormDesignerAllSubSectionsDto {
    formDesignerSubSectionDto: FormDesignerSubSectionDto[] | undefined;
    mainSubSections: MainSubSectionsDto[] | undefined;

    constructor(data?: IFormDesignerAllSubSectionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["formDesignerSubSectionDto"])) {
                this.formDesignerSubSectionDto = [] as any;
                for (let item of _data["formDesignerSubSectionDto"])
                    this.formDesignerSubSectionDto.push(FormDesignerSubSectionDto.fromJS(item));
            }
            if (Array.isArray(_data["mainSubSections"])) {
                this.mainSubSections = [] as any;
                for (let item of _data["mainSubSections"])
                    this.mainSubSections.push(MainSubSectionsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormDesignerAllSubSectionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDesignerAllSubSectionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.formDesignerSubSectionDto)) {
            data["formDesignerSubSectionDto"] = [];
            for (let item of this.formDesignerSubSectionDto)
                data["formDesignerSubSectionDto"].push(item.toJSON());
        }
        if (Array.isArray(this.mainSubSections)) {
            data["mainSubSections"] = [];
            for (let item of this.mainSubSections)
                data["mainSubSections"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FormDesignerAllSubSectionsDto {
        const json = this.toJSON();
        let result = new FormDesignerAllSubSectionsDto();
        result.init(json);
        return result;
    }
}

export interface IFormDesignerAllSubSectionsDto {
    formDesignerSubSectionDto: FormDesignerSubSectionDto[] | undefined;
    mainSubSections: MainSubSectionsDto[] | undefined;
}

export class FormDimensionCubeMappingDto implements IFormDimensionCubeMappingDto {
    formStructureRowId: number;
    schemaSelector: string | undefined;
    dataSelector: string | undefined;
    isMeasure: boolean;
    isDeleted: boolean;
    id: number;

    constructor(data?: IFormDimensionCubeMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructureRowId = _data["formStructureRowId"];
            this.schemaSelector = _data["schemaSelector"];
            this.dataSelector = _data["dataSelector"];
            this.isMeasure = _data["isMeasure"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormDimensionCubeMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDimensionCubeMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructureRowId"] = this.formStructureRowId;
        data["schemaSelector"] = this.schemaSelector;
        data["dataSelector"] = this.dataSelector;
        data["isMeasure"] = this.isMeasure;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormDimensionCubeMappingDto {
        const json = this.toJSON();
        let result = new FormDimensionCubeMappingDto();
        result.init(json);
        return result;
    }
}

export interface IFormDimensionCubeMappingDto {
    formStructureRowId: number;
    schemaSelector: string | undefined;
    dataSelector: string | undefined;
    isMeasure: boolean;
    isDeleted: boolean;
    id: number;
}

export class FormDesignerDimensionDataDto implements IFormDesignerDimensionDataDto {
    showValues: boolean;
    dimensionCubMapping: FormDimensionCubeMappingDto;
    dimensionWeeks: FormDimensionWeekDto[] | undefined;
    referenceId: number;
    referenceType: ReferenceType;
    refDimensionSum: ReferenceDimensionSumDto[] | undefined;
    isDeleted: boolean;
    cells: FormStructerDataCellDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;

    constructor(data?: IFormDesignerDimensionDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showValues = _data["showValues"];
            this.dimensionCubMapping = _data["dimensionCubMapping"] ? FormDimensionCubeMappingDto.fromJS(_data["dimensionCubMapping"]) : <any>undefined;
            if (Array.isArray(_data["dimensionWeeks"])) {
                this.dimensionWeeks = [] as any;
                for (let item of _data["dimensionWeeks"])
                    this.dimensionWeeks.push(FormDimensionWeekDto.fromJS(item));
            }
            this.referenceId = _data["referenceId"];
            this.referenceType = _data["referenceType"];
            if (Array.isArray(_data["refDimensionSum"])) {
                this.refDimensionSum = [] as any;
                for (let item of _data["refDimensionSum"])
                    this.refDimensionSum.push(ReferenceDimensionSumDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["cells"])) {
                this.cells = [] as any;
                for (let item of _data["cells"])
                    this.cells.push(FormStructerDataCellDto.fromJS(item));
            }
            this.title = _data["title"];
            this.code = _data["code"];
            this.order = _data["order"];
            this.parentId = _data["parentId"];
            this.isLeaf = _data["isLeaf"];
            this.rowTypeId = _data["rowTypeId"];
            this.structureTypeId = _data["structureTypeId"];
            this.structureId = _data["structureId"];
            this.activityCountDto = _data["activityCountDto"] ? ActivityCountDto.fromJS(_data["activityCountDto"]) : <any>undefined;
            this.referenceData = _data["referenceData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormDesignerDimensionDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDesignerDimensionDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showValues"] = this.showValues;
        data["dimensionCubMapping"] = this.dimensionCubMapping ? this.dimensionCubMapping.toJSON() : <any>undefined;
        if (Array.isArray(this.dimensionWeeks)) {
            data["dimensionWeeks"] = [];
            for (let item of this.dimensionWeeks)
                data["dimensionWeeks"].push(item.toJSON());
        }
        data["referenceId"] = this.referenceId;
        data["referenceType"] = this.referenceType;
        if (Array.isArray(this.refDimensionSum)) {
            data["refDimensionSum"] = [];
            for (let item of this.refDimensionSum)
                data["refDimensionSum"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.cells)) {
            data["cells"] = [];
            for (let item of this.cells)
                data["cells"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["code"] = this.code;
        data["order"] = this.order;
        data["parentId"] = this.parentId;
        data["isLeaf"] = this.isLeaf;
        data["rowTypeId"] = this.rowTypeId;
        data["structureTypeId"] = this.structureTypeId;
        data["structureId"] = this.structureId;
        data["activityCountDto"] = this.activityCountDto ? this.activityCountDto.toJSON() : <any>undefined;
        data["referenceData"] = this.referenceData;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormDesignerDimensionDataDto {
        const json = this.toJSON();
        let result = new FormDesignerDimensionDataDto();
        result.init(json);
        return result;
    }
}

export interface IFormDesignerDimensionDataDto {
    showValues: boolean;
    dimensionCubMapping: FormDimensionCubeMappingDto;
    dimensionWeeks: FormDimensionWeekDto[] | undefined;
    referenceId: number;
    referenceType: ReferenceType;
    refDimensionSum: ReferenceDimensionSumDto[] | undefined;
    isDeleted: boolean;
    cells: FormStructerDataCellDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;
}

export class FormColumnCubeMappingDto implements IFormColumnCubeMappingDto {
    formStructureColumnId: number | undefined;
    formStructureRowId: number;
    selector: string | undefined;
    isMeasure: boolean;
    mainBindingSource: string | undefined;
    isDeleted: boolean;
    id: number;

    constructor(data?: IFormColumnCubeMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructureColumnId = _data["formStructureColumnId"];
            this.formStructureRowId = _data["formStructureRowId"];
            this.selector = _data["selector"];
            this.isMeasure = _data["isMeasure"];
            this.mainBindingSource = _data["mainBindingSource"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormColumnCubeMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormColumnCubeMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructureColumnId"] = this.formStructureColumnId;
        data["formStructureRowId"] = this.formStructureRowId;
        data["selector"] = this.selector;
        data["isMeasure"] = this.isMeasure;
        data["mainBindingSource"] = this.mainBindingSource;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormColumnCubeMappingDto {
        const json = this.toJSON();
        let result = new FormColumnCubeMappingDto();
        result.init(json);
        return result;
    }
}

export interface IFormColumnCubeMappingDto {
    formStructureColumnId: number | undefined;
    formStructureRowId: number;
    selector: string | undefined;
    isMeasure: boolean;
    mainBindingSource: string | undefined;
    isDeleted: boolean;
    id: number;
}

export enum PercentageMode {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum DifferenceMode {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum Direction {
    _0 = 0,
    _1 = 1,
}

export enum HeatmapMode {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class Measure implements IMeasure {
    name: string | undefined;
    percentage: PercentageMode;
    difference: DifferenceMode;
    runningTotal: Direction;
    differenceAsPercentage: boolean;
    heatmap: HeatmapMode;

    constructor(data?: IMeasure) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.percentage = _data["percentage"];
            this.difference = _data["difference"];
            this.runningTotal = _data["runningTotal"];
            this.differenceAsPercentage = _data["differenceAsPercentage"];
            this.heatmap = _data["heatmap"];
        }
    }

    static fromJS(data: any): Measure {
        data = typeof data === 'object' ? data : {};
        let result = new Measure();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["percentage"] = this.percentage;
        data["difference"] = this.difference;
        data["runningTotal"] = this.runningTotal;
        data["differenceAsPercentage"] = this.differenceAsPercentage;
        data["heatmap"] = this.heatmap;
        return data; 
    }

    clone(): Measure {
        const json = this.toJSON();
        let result = new Measure();
        result.init(json);
        return result;
    }
}

export interface IMeasure {
    name: string | undefined;
    percentage: PercentageMode;
    difference: DifferenceMode;
    runningTotal: Direction;
    differenceAsPercentage: boolean;
    heatmap: HeatmapMode;
}

export class FormDesignerKPIDto implements IFormDesignerKPIDto {
    showValues: boolean;
    dimensions: FormDesignerDimensionDataDto[] | undefined;
    weeks: FormDimensionWeekDto[] | undefined;
    colCubeMapping: FormColumnCubeMappingDto[] | undefined;
    columns: FormStructureColumnDto[] | undefined;
    cubeMeasureDataCol: Measure[] | undefined;
    struturePercentages: FormStructurePercentageDto[] | undefined;
    referenceId: number;
    referenceType: ReferenceType;
    isDeleted: boolean;
    cells: FormStructerDataCellDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;

    constructor(data?: IFormDesignerKPIDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showValues = _data["showValues"];
            if (Array.isArray(_data["dimensions"])) {
                this.dimensions = [] as any;
                for (let item of _data["dimensions"])
                    this.dimensions.push(FormDesignerDimensionDataDto.fromJS(item));
            }
            if (Array.isArray(_data["weeks"])) {
                this.weeks = [] as any;
                for (let item of _data["weeks"])
                    this.weeks.push(FormDimensionWeekDto.fromJS(item));
            }
            if (Array.isArray(_data["colCubeMapping"])) {
                this.colCubeMapping = [] as any;
                for (let item of _data["colCubeMapping"])
                    this.colCubeMapping.push(FormColumnCubeMappingDto.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(FormStructureColumnDto.fromJS(item));
            }
            if (Array.isArray(_data["cubeMeasureDataCol"])) {
                this.cubeMeasureDataCol = [] as any;
                for (let item of _data["cubeMeasureDataCol"])
                    this.cubeMeasureDataCol.push(Measure.fromJS(item));
            }
            if (Array.isArray(_data["struturePercentages"])) {
                this.struturePercentages = [] as any;
                for (let item of _data["struturePercentages"])
                    this.struturePercentages.push(FormStructurePercentageDto.fromJS(item));
            }
            this.referenceId = _data["referenceId"];
            this.referenceType = _data["referenceType"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["cells"])) {
                this.cells = [] as any;
                for (let item of _data["cells"])
                    this.cells.push(FormStructerDataCellDto.fromJS(item));
            }
            this.title = _data["title"];
            this.code = _data["code"];
            this.order = _data["order"];
            this.parentId = _data["parentId"];
            this.isLeaf = _data["isLeaf"];
            this.rowTypeId = _data["rowTypeId"];
            this.structureTypeId = _data["structureTypeId"];
            this.structureId = _data["structureId"];
            this.activityCountDto = _data["activityCountDto"] ? ActivityCountDto.fromJS(_data["activityCountDto"]) : <any>undefined;
            this.referenceData = _data["referenceData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormDesignerKPIDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDesignerKPIDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showValues"] = this.showValues;
        if (Array.isArray(this.dimensions)) {
            data["dimensions"] = [];
            for (let item of this.dimensions)
                data["dimensions"].push(item.toJSON());
        }
        if (Array.isArray(this.weeks)) {
            data["weeks"] = [];
            for (let item of this.weeks)
                data["weeks"].push(item.toJSON());
        }
        if (Array.isArray(this.colCubeMapping)) {
            data["colCubeMapping"] = [];
            for (let item of this.colCubeMapping)
                data["colCubeMapping"].push(item.toJSON());
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.cubeMeasureDataCol)) {
            data["cubeMeasureDataCol"] = [];
            for (let item of this.cubeMeasureDataCol)
                data["cubeMeasureDataCol"].push(item.toJSON());
        }
        if (Array.isArray(this.struturePercentages)) {
            data["struturePercentages"] = [];
            for (let item of this.struturePercentages)
                data["struturePercentages"].push(item.toJSON());
        }
        data["referenceId"] = this.referenceId;
        data["referenceType"] = this.referenceType;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.cells)) {
            data["cells"] = [];
            for (let item of this.cells)
                data["cells"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["code"] = this.code;
        data["order"] = this.order;
        data["parentId"] = this.parentId;
        data["isLeaf"] = this.isLeaf;
        data["rowTypeId"] = this.rowTypeId;
        data["structureTypeId"] = this.structureTypeId;
        data["structureId"] = this.structureId;
        data["activityCountDto"] = this.activityCountDto ? this.activityCountDto.toJSON() : <any>undefined;
        data["referenceData"] = this.referenceData;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormDesignerKPIDto {
        const json = this.toJSON();
        let result = new FormDesignerKPIDto();
        result.init(json);
        return result;
    }
}

export interface IFormDesignerKPIDto {
    showValues: boolean;
    dimensions: FormDesignerDimensionDataDto[] | undefined;
    weeks: FormDimensionWeekDto[] | undefined;
    colCubeMapping: FormColumnCubeMappingDto[] | undefined;
    columns: FormStructureColumnDto[] | undefined;
    cubeMeasureDataCol: Measure[] | undefined;
    struturePercentages: FormStructurePercentageDto[] | undefined;
    referenceId: number;
    referenceType: ReferenceType;
    isDeleted: boolean;
    cells: FormStructerDataCellDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;
}

export class FormDesignerSubSectionStructureDto implements IFormDesignerSubSectionStructureDto {
    formDisplayTypeId: FormDisplayType;
    columns: FormStructureColumnDto[] | undefined;
    kpis: FormDesignerKPIDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;

    constructor(data?: IFormDesignerSubSectionStructureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formDisplayTypeId = _data["formDisplayTypeId"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(FormStructureColumnDto.fromJS(item));
            }
            if (Array.isArray(_data["kpis"])) {
                this.kpis = [] as any;
                for (let item of _data["kpis"])
                    this.kpis.push(FormDesignerKPIDto.fromJS(item));
            }
            this.title = _data["title"];
            this.code = _data["code"];
            this.order = _data["order"];
            this.parentId = _data["parentId"];
            this.isLeaf = _data["isLeaf"];
            this.rowTypeId = _data["rowTypeId"];
            this.structureTypeId = _data["structureTypeId"];
            this.structureId = _data["structureId"];
            this.activityCountDto = _data["activityCountDto"] ? ActivityCountDto.fromJS(_data["activityCountDto"]) : <any>undefined;
            this.referenceData = _data["referenceData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormDesignerSubSectionStructureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDesignerSubSectionStructureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formDisplayTypeId"] = this.formDisplayTypeId;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.kpis)) {
            data["kpis"] = [];
            for (let item of this.kpis)
                data["kpis"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["code"] = this.code;
        data["order"] = this.order;
        data["parentId"] = this.parentId;
        data["isLeaf"] = this.isLeaf;
        data["rowTypeId"] = this.rowTypeId;
        data["structureTypeId"] = this.structureTypeId;
        data["structureId"] = this.structureId;
        data["activityCountDto"] = this.activityCountDto ? this.activityCountDto.toJSON() : <any>undefined;
        data["referenceData"] = this.referenceData;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormDesignerSubSectionStructureDto {
        const json = this.toJSON();
        let result = new FormDesignerSubSectionStructureDto();
        result.init(json);
        return result;
    }
}

export interface IFormDesignerSubSectionStructureDto {
    formDisplayTypeId: FormDisplayType;
    columns: FormStructureColumnDto[] | undefined;
    kpis: FormDesignerKPIDto[] | undefined;
    title: string | undefined;
    code: string | undefined;
    order: number;
    parentId: number | undefined;
    isLeaf: boolean;
    rowTypeId: number | undefined;
    structureTypeId: number | undefined;
    structureId: number | undefined;
    activityCountDto: ActivityCountDto;
    referenceData: string | undefined;
    id: number;
}

export class FormDesignerMetaData implements IFormDesignerMetaData {
    formId: number;
    formTitle: string | undefined;
    formTypeId: number;
    formCode: string | undefined;

    constructor(data?: IFormDesignerMetaData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.formTitle = _data["formTitle"];
            this.formTypeId = _data["formTypeId"];
            this.formCode = _data["formCode"];
        }
    }

    static fromJS(data: any): FormDesignerMetaData {
        data = typeof data === 'object' ? data : {};
        let result = new FormDesignerMetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["formTitle"] = this.formTitle;
        data["formTypeId"] = this.formTypeId;
        data["formCode"] = this.formCode;
        return data; 
    }

    clone(): FormDesignerMetaData {
        const json = this.toJSON();
        let result = new FormDesignerMetaData();
        result.init(json);
        return result;
    }
}

export interface IFormDesignerMetaData {
    formId: number;
    formTitle: string | undefined;
    formTypeId: number;
    formCode: string | undefined;
}

export class FormColumnOutputDto implements IFormColumnOutputDto {
    id: number;
    header: string | undefined;
    isDefault: boolean;
    bindingSource: string | undefined;

    constructor(data?: IFormColumnOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.header = _data["header"];
            this.isDefault = _data["isDefault"];
            this.bindingSource = _data["bindingSource"];
        }
    }

    static fromJS(data: any): FormColumnOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormColumnOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["header"] = this.header;
        data["isDefault"] = this.isDefault;
        data["bindingSource"] = this.bindingSource;
        return data; 
    }

    clone(): FormColumnOutputDto {
        const json = this.toJSON();
        let result = new FormColumnOutputDto();
        result.init(json);
        return result;
    }
}

export interface IFormColumnOutputDto {
    id: number;
    header: string | undefined;
    isDefault: boolean;
    bindingSource: string | undefined;
}

export class IndicatorTypeEditDto implements IIndicatorTypeEditDto {
    id: number | undefined;
    title: string | undefined;
    displayName: string | undefined;
    kpiCode: string | undefined;

    constructor(data?: IIndicatorTypeEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.displayName = _data["displayName"];
            this.kpiCode = _data["kpiCode"];
        }
    }

    static fromJS(data: any): IndicatorTypeEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndicatorTypeEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["displayName"] = this.displayName;
        data["kpiCode"] = this.kpiCode;
        return data; 
    }

    clone(): IndicatorTypeEditDto {
        const json = this.toJSON();
        let result = new IndicatorTypeEditDto();
        result.init(json);
        return result;
    }
}

export interface IIndicatorTypeEditDto {
    id: number | undefined;
    title: string | undefined;
    displayName: string | undefined;
    kpiCode: string | undefined;
}

export class DimensionFormDesignerListDto implements IDimensionFormDesignerListDto {
    title: string | undefined;
    id: number;

    constructor(data?: IDimensionFormDesignerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DimensionFormDesignerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DimensionFormDesignerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["id"] = this.id;
        return data; 
    }

    clone(): DimensionFormDesignerListDto {
        const json = this.toJSON();
        let result = new DimensionFormDesignerListDto();
        result.init(json);
        return result;
    }
}

export interface IDimensionFormDesignerListDto {
    title: string | undefined;
    id: number;
}

export class FormStructureRowDesignerDto implements IFormStructureRowDesignerDto {
    structureId: number;
    formId: number;
    parentId: number | undefined;
    rowTypeId: number | undefined;
    isLeaf: boolean;
    order: number;
    isDeleted: boolean;
    id: number;

    constructor(data?: IFormStructureRowDesignerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.structureId = _data["structureId"];
            this.formId = _data["formId"];
            this.parentId = _data["parentId"];
            this.rowTypeId = _data["rowTypeId"];
            this.isLeaf = _data["isLeaf"];
            this.order = _data["order"];
            this.isDeleted = _data["isDeleted"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormStructureRowDesignerDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStructureRowDesignerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["structureId"] = this.structureId;
        data["formId"] = this.formId;
        data["parentId"] = this.parentId;
        data["rowTypeId"] = this.rowTypeId;
        data["isLeaf"] = this.isLeaf;
        data["order"] = this.order;
        data["isDeleted"] = this.isDeleted;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormStructureRowDesignerDto {
        const json = this.toJSON();
        let result = new FormStructureRowDesignerDto();
        result.init(json);
        return result;
    }
}

export interface IFormStructureRowDesignerDto {
    structureId: number;
    formId: number;
    parentId: number | undefined;
    rowTypeId: number | undefined;
    isLeaf: boolean;
    order: number;
    isDeleted: boolean;
    id: number;
}

export class FormStructureCellDesignerDto implements IFormStructureCellDesignerDto {
    formStructureRowId: number;
    formStructureColumnId: number;
    typeId: number;
    id: number;

    constructor(data?: IFormStructureCellDesignerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructureRowId = _data["formStructureRowId"];
            this.formStructureColumnId = _data["formStructureColumnId"];
            this.typeId = _data["typeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormStructureCellDesignerDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStructureCellDesignerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructureRowId"] = this.formStructureRowId;
        data["formStructureColumnId"] = this.formStructureColumnId;
        data["typeId"] = this.typeId;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormStructureCellDesignerDto {
        const json = this.toJSON();
        let result = new FormStructureCellDesignerDto();
        result.init(json);
        return result;
    }
}

export interface IFormStructureCellDesignerDto {
    formStructureRowId: number;
    formStructureColumnId: number;
    typeId: number;
    id: number;
}

export class FormCellTypeDto implements IFormCellTypeDto {
    type: string | undefined;
    id: number;

    constructor(data?: IFormCellTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormCellTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormCellTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormCellTypeDto {
        const json = this.toJSON();
        let result = new FormCellTypeDto();
        result.init(json);
        return result;
    }
}

export interface IFormCellTypeDto {
    type: string | undefined;
    id: number;
}

export class BasicData implements IBasicData {
    name: string | undefined;

    constructor(data?: IBasicData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BasicData {
        data = typeof data === 'object' ? data : {};
        let result = new BasicData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): BasicData {
        const json = this.toJSON();
        let result = new BasicData();
        result.init(json);
        return result;
    }
}

export interface IBasicData {
    name: string | undefined;
}

export class PivotConfiguration implements IPivotConfiguration {
    measures: BasicData[] | undefined;
    columns: BasicData[] | undefined;
    rows: BasicData[] | undefined;

    constructor(data?: IPivotConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["measures"])) {
                this.measures = [] as any;
                for (let item of _data["measures"])
                    this.measures.push(BasicData.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(BasicData.fromJS(item));
            }
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows.push(BasicData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PivotConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new PivotConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.measures)) {
            data["measures"] = [];
            for (let item of this.measures)
                data["measures"].push(item.toJSON());
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PivotConfiguration {
        const json = this.toJSON();
        let result = new PivotConfiguration();
        result.init(json);
        return result;
    }
}

export interface IPivotConfiguration {
    measures: BasicData[] | undefined;
    columns: BasicData[] | undefined;
    rows: BasicData[] | undefined;
}

export class PivotHierarchyDto implements IPivotHierarchyDto {
    pivotConfiguration: PivotConfiguration;
    dimensionsHierarchy: { [key: string]: string[]; } | undefined;

    constructor(data?: IPivotHierarchyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pivotConfiguration = _data["pivotConfiguration"] ? PivotConfiguration.fromJS(_data["pivotConfiguration"]) : <any>undefined;
            if (_data["dimensionsHierarchy"]) {
                this.dimensionsHierarchy = {} as any;
                for (let key in _data["dimensionsHierarchy"]) {
                    if (_data["dimensionsHierarchy"].hasOwnProperty(key))
                        this.dimensionsHierarchy[key] = _data["dimensionsHierarchy"][key] !== undefined ? _data["dimensionsHierarchy"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): PivotHierarchyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PivotHierarchyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pivotConfiguration"] = this.pivotConfiguration ? this.pivotConfiguration.toJSON() : <any>undefined;
        if (this.dimensionsHierarchy) {
            data["dimensionsHierarchy"] = {};
            for (let key in this.dimensionsHierarchy) {
                if (this.dimensionsHierarchy.hasOwnProperty(key))
                    data["dimensionsHierarchy"][key] = this.dimensionsHierarchy[key];
            }
        }
        return data; 
    }

    clone(): PivotHierarchyDto {
        const json = this.toJSON();
        let result = new PivotHierarchyDto();
        result.init(json);
        return result;
    }
}

export interface IPivotHierarchyDto {
    pivotConfiguration: PivotConfiguration;
    dimensionsHierarchy: { [key: string]: string[]; } | undefined;
}

export class GetReferenceSubSectionInput implements IGetReferenceSubSectionInput {
    referenceType: number;
    formId: number;
    columns: FormStructureColumnDto[] | undefined;
    kpiColumnPercentages: FormStructurePercentageDto[] | undefined;

    constructor(data?: IGetReferenceSubSectionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.referenceType = _data["referenceType"];
            this.formId = _data["formId"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(FormStructureColumnDto.fromJS(item));
            }
            if (Array.isArray(_data["kpiColumnPercentages"])) {
                this.kpiColumnPercentages = [] as any;
                for (let item of _data["kpiColumnPercentages"])
                    this.kpiColumnPercentages.push(FormStructurePercentageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetReferenceSubSectionInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetReferenceSubSectionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceType"] = this.referenceType;
        data["formId"] = this.formId;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.kpiColumnPercentages)) {
            data["kpiColumnPercentages"] = [];
            for (let item of this.kpiColumnPercentages)
                data["kpiColumnPercentages"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetReferenceSubSectionInput {
        const json = this.toJSON();
        let result = new GetReferenceSubSectionInput();
        result.init(json);
        return result;
    }
}

export interface IGetReferenceSubSectionInput {
    referenceType: number;
    formId: number;
    columns: FormStructureColumnDto[] | undefined;
    kpiColumnPercentages: FormStructurePercentageDto[] | undefined;
}

export class KPIDto implements IKPIDto {
    kpiId: number;
    kpiTitle: string | undefined;
    structureId: number | undefined;

    constructor(data?: IKPIDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kpiId = _data["kpiId"];
            this.kpiTitle = _data["kpiTitle"];
            this.structureId = _data["structureId"];
        }
    }

    static fromJS(data: any): KPIDto {
        data = typeof data === 'object' ? data : {};
        let result = new KPIDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kpiId"] = this.kpiId;
        data["kpiTitle"] = this.kpiTitle;
        data["structureId"] = this.structureId;
        return data; 
    }

    clone(): KPIDto {
        const json = this.toJSON();
        let result = new KPIDto();
        result.init(json);
        return result;
    }
}

export interface IKPIDto {
    kpiId: number;
    kpiTitle: string | undefined;
    structureId: number | undefined;
}

export class SubSectionWithSectionNameDto implements ISubSectionWithSectionNameDto {
    formId: number;
    subSectionId: number;
    subSectionTitle: string | undefined;
    kpIs: KPIDto[] | undefined;

    constructor(data?: ISubSectionWithSectionNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.subSectionId = _data["subSectionId"];
            this.subSectionTitle = _data["subSectionTitle"];
            if (Array.isArray(_data["kpIs"])) {
                this.kpIs = [] as any;
                for (let item of _data["kpIs"])
                    this.kpIs.push(KPIDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubSectionWithSectionNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubSectionWithSectionNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["subSectionId"] = this.subSectionId;
        data["subSectionTitle"] = this.subSectionTitle;
        if (Array.isArray(this.kpIs)) {
            data["kpIs"] = [];
            for (let item of this.kpIs)
                data["kpIs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SubSectionWithSectionNameDto {
        const json = this.toJSON();
        let result = new SubSectionWithSectionNameDto();
        result.init(json);
        return result;
    }
}

export interface ISubSectionWithSectionNameDto {
    formId: number;
    subSectionId: number;
    subSectionTitle: string | undefined;
    kpIs: KPIDto[] | undefined;
}

export class FromStructureReferenceDto implements IFromStructureReferenceDto {
    formId: number;
    subSection: SubSectionWithSectionNameDto;

    constructor(data?: IFromStructureReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.subSection = _data["subSection"] ? SubSectionWithSectionNameDto.fromJS(_data["subSection"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FromStructureReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FromStructureReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["subSection"] = this.subSection ? this.subSection.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FromStructureReferenceDto {
        const json = this.toJSON();
        let result = new FromStructureReferenceDto();
        result.init(json);
        return result;
    }
}

export interface IFromStructureReferenceDto {
    formId: number;
    subSection: SubSectionWithSectionNameDto;
}

export class StructureReferenceDto implements IStructureReferenceDto {
    currentParentId: number;
    forms: FromStructureReferenceDto[] | undefined;

    constructor(data?: IStructureReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentParentId = _data["currentParentId"];
            if (Array.isArray(_data["forms"])) {
                this.forms = [] as any;
                for (let item of _data["forms"])
                    this.forms.push(FromStructureReferenceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StructureReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new StructureReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentParentId"] = this.currentParentId;
        if (Array.isArray(this.forms)) {
            data["forms"] = [];
            for (let item of this.forms)
                data["forms"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StructureReferenceDto {
        const json = this.toJSON();
        let result = new StructureReferenceDto();
        result.init(json);
        return result;
    }
}

export interface IStructureReferenceDto {
    currentParentId: number;
    forms: FromStructureReferenceDto[] | undefined;
}

export class GetReferenceSumInputDto implements IGetReferenceSumInputDto {
    formId: number;
    kpiColumnDto: FormStructureColumnDto[] | undefined;

    constructor(data?: IGetReferenceSumInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            if (Array.isArray(_data["kpiColumnDto"])) {
                this.kpiColumnDto = [] as any;
                for (let item of _data["kpiColumnDto"])
                    this.kpiColumnDto.push(FormStructureColumnDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetReferenceSumInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReferenceSumInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        if (Array.isArray(this.kpiColumnDto)) {
            data["kpiColumnDto"] = [];
            for (let item of this.kpiColumnDto)
                data["kpiColumnDto"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetReferenceSumInputDto {
        const json = this.toJSON();
        let result = new GetReferenceSumInputDto();
        result.init(json);
        return result;
    }
}

export interface IGetReferenceSumInputDto {
    formId: number;
    kpiColumnDto: FormStructureColumnDto[] | undefined;
}

export class GetReferenceDimensionSumInputDto implements IGetReferenceDimensionSumInputDto {
    kpiId: number;
    formId: number;
    dimensionDataDto: FormDesignerDimensionDataDto;

    constructor(data?: IGetReferenceDimensionSumInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kpiId = _data["kpiId"];
            this.formId = _data["formId"];
            this.dimensionDataDto = _data["dimensionDataDto"] ? FormDesignerDimensionDataDto.fromJS(_data["dimensionDataDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetReferenceDimensionSumInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReferenceDimensionSumInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kpiId"] = this.kpiId;
        data["formId"] = this.formId;
        data["dimensionDataDto"] = this.dimensionDataDto ? this.dimensionDataDto.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetReferenceDimensionSumInputDto {
        const json = this.toJSON();
        let result = new GetReferenceDimensionSumInputDto();
        result.init(json);
        return result;
    }
}

export interface IGetReferenceDimensionSumInputDto {
    kpiId: number;
    formId: number;
    dimensionDataDto: FormDesignerDimensionDataDto;
}

export class FormStructureDataModel implements IFormStructureDataModel {
    structureId: number;
    structureTitle: string | undefined;
    structureTypeId: number;
    structureTypeTitle: string | undefined;
    structureCode: string | undefined;
    structureParentId: number | undefined;
    showValues: boolean;
    formStructureRowId: number;
    formStructureOrder: number;
    formStructureIsLeaf: boolean;
    formStructureParentId: number | undefined;
    rowTypeId: number | undefined;
    formStructureColumnId: number;
    structureColumnTitle: string | undefined;
    structureColumnBindSource: string | undefined;
    formStructureColumnHeader: string | undefined;
    formStructureColumnOrder: number;
    formColumnBusinessRuleId: number | undefined;
    columnStructureId: number | undefined;
    columnIsPercentage: boolean;
    formStructureCellId: number;
    cellTypeId: number;
    formDataId: number;
    formCellValue: number | undefined;
    week: number | undefined;
    month: number | undefined;
    year: number | undefined;
    referenceData: string | undefined;

    constructor(data?: IFormStructureDataModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.structureId = _data["structureId"];
            this.structureTitle = _data["structureTitle"];
            this.structureTypeId = _data["structureTypeId"];
            this.structureTypeTitle = _data["structureTypeTitle"];
            this.structureCode = _data["structureCode"];
            this.structureParentId = _data["structureParentId"];
            this.showValues = _data["showValues"];
            this.formStructureRowId = _data["formStructureRowId"];
            this.formStructureOrder = _data["formStructureOrder"];
            this.formStructureIsLeaf = _data["formStructureIsLeaf"];
            this.formStructureParentId = _data["formStructureParentId"];
            this.rowTypeId = _data["rowTypeId"];
            this.formStructureColumnId = _data["formStructureColumnId"];
            this.structureColumnTitle = _data["structureColumnTitle"];
            this.structureColumnBindSource = _data["structureColumnBindSource"];
            this.formStructureColumnHeader = _data["formStructureColumnHeader"];
            this.formStructureColumnOrder = _data["formStructureColumnOrder"];
            this.formColumnBusinessRuleId = _data["formColumnBusinessRuleId"];
            this.columnStructureId = _data["columnStructureId"];
            this.columnIsPercentage = _data["columnIsPercentage"];
            this.formStructureCellId = _data["formStructureCellId"];
            this.cellTypeId = _data["cellTypeId"];
            this.formDataId = _data["formDataId"];
            this.formCellValue = _data["formCellValue"];
            this.week = _data["week"];
            this.month = _data["month"];
            this.year = _data["year"];
            this.referenceData = _data["referenceData"];
        }
    }

    static fromJS(data: any): FormStructureDataModel {
        data = typeof data === 'object' ? data : {};
        let result = new FormStructureDataModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["structureId"] = this.structureId;
        data["structureTitle"] = this.structureTitle;
        data["structureTypeId"] = this.structureTypeId;
        data["structureTypeTitle"] = this.structureTypeTitle;
        data["structureCode"] = this.structureCode;
        data["structureParentId"] = this.structureParentId;
        data["showValues"] = this.showValues;
        data["formStructureRowId"] = this.formStructureRowId;
        data["formStructureOrder"] = this.formStructureOrder;
        data["formStructureIsLeaf"] = this.formStructureIsLeaf;
        data["formStructureParentId"] = this.formStructureParentId;
        data["rowTypeId"] = this.rowTypeId;
        data["formStructureColumnId"] = this.formStructureColumnId;
        data["structureColumnTitle"] = this.structureColumnTitle;
        data["structureColumnBindSource"] = this.structureColumnBindSource;
        data["formStructureColumnHeader"] = this.formStructureColumnHeader;
        data["formStructureColumnOrder"] = this.formStructureColumnOrder;
        data["formColumnBusinessRuleId"] = this.formColumnBusinessRuleId;
        data["columnStructureId"] = this.columnStructureId;
        data["columnIsPercentage"] = this.columnIsPercentage;
        data["formStructureCellId"] = this.formStructureCellId;
        data["cellTypeId"] = this.cellTypeId;
        data["formDataId"] = this.formDataId;
        data["formCellValue"] = this.formCellValue;
        data["week"] = this.week;
        data["month"] = this.month;
        data["year"] = this.year;
        data["referenceData"] = this.referenceData;
        return data; 
    }

    clone(): FormStructureDataModel {
        const json = this.toJSON();
        let result = new FormStructureDataModel();
        result.init(json);
        return result;
    }
}

export interface IFormStructureDataModel {
    structureId: number;
    structureTitle: string | undefined;
    structureTypeId: number;
    structureTypeTitle: string | undefined;
    structureCode: string | undefined;
    structureParentId: number | undefined;
    showValues: boolean;
    formStructureRowId: number;
    formStructureOrder: number;
    formStructureIsLeaf: boolean;
    formStructureParentId: number | undefined;
    rowTypeId: number | undefined;
    formStructureColumnId: number;
    structureColumnTitle: string | undefined;
    structureColumnBindSource: string | undefined;
    formStructureColumnHeader: string | undefined;
    formStructureColumnOrder: number;
    formColumnBusinessRuleId: number | undefined;
    columnStructureId: number | undefined;
    columnIsPercentage: boolean;
    formStructureCellId: number;
    cellTypeId: number;
    formDataId: number;
    formCellValue: number | undefined;
    week: number | undefined;
    month: number | undefined;
    year: number | undefined;
    referenceData: string | undefined;
}

export class SubSectionDataModel implements ISubSectionDataModel {
    formStructureRowId: number;
    structureId: number;
    structureTitle: string | undefined;
    structureType: number;
    parentID: number | undefined;
    formColumnId: number;
    columnBindSource: string | undefined;
    columnStructureId: number;
    columnOrder: number;

    constructor(data?: ISubSectionDataModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructureRowId = _data["formStructureRowId"];
            this.structureId = _data["structureId"];
            this.structureTitle = _data["structureTitle"];
            this.structureType = _data["structureType"];
            this.parentID = _data["parentID"];
            this.formColumnId = _data["formColumnId"];
            this.columnBindSource = _data["columnBindSource"];
            this.columnStructureId = _data["columnStructureId"];
            this.columnOrder = _data["columnOrder"];
        }
    }

    static fromJS(data: any): SubSectionDataModel {
        data = typeof data === 'object' ? data : {};
        let result = new SubSectionDataModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructureRowId"] = this.formStructureRowId;
        data["structureId"] = this.structureId;
        data["structureTitle"] = this.structureTitle;
        data["structureType"] = this.structureType;
        data["parentID"] = this.parentID;
        data["formColumnId"] = this.formColumnId;
        data["columnBindSource"] = this.columnBindSource;
        data["columnStructureId"] = this.columnStructureId;
        data["columnOrder"] = this.columnOrder;
        return data; 
    }

    clone(): SubSectionDataModel {
        const json = this.toJSON();
        let result = new SubSectionDataModel();
        result.init(json);
        return result;
    }
}

export interface ISubSectionDataModel {
    formStructureRowId: number;
    structureId: number;
    structureTitle: string | undefined;
    structureType: number;
    parentID: number | undefined;
    formColumnId: number;
    columnBindSource: string | undefined;
    columnStructureId: number;
    columnOrder: number;
}

export class FormTypeListDto implements IFormTypeListDto {
    title: string | undefined;
    id: number;

    constructor(data?: IFormTypeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormTypeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormTypeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormTypeListDto {
        const json = this.toJSON();
        let result = new FormTypeListDto();
        result.init(json);
        return result;
    }
}

export interface IFormTypeListDto {
    title: string | undefined;
    id: number;
}

export class FormTypeListDtoPagedResultDto implements IFormTypeListDtoPagedResultDto {
    totalCount: number;
    items: FormTypeListDto[] | undefined;

    constructor(data?: IFormTypeListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FormTypeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormTypeListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormTypeListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FormTypeListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FormTypeListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFormTypeListDtoPagedResultDto {
    totalCount: number;
    items: FormTypeListDto[] | undefined;
}

export class FormTypeDto implements IFormTypeDto {
    title: string | undefined;
    id: number;

    constructor(data?: IFormTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormTypeDto {
        const json = this.toJSON();
        let result = new FormTypeDto();
        result.init(json);
        return result;
    }
}

export interface IFormTypeDto {
    title: string | undefined;
    id: number;
}

export class FormTypeEditDto implements IFormTypeEditDto {
    id: number | undefined;
    title: string | undefined;

    constructor(data?: IFormTypeEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): FormTypeEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormTypeEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }

    clone(): FormTypeEditDto {
        const json = this.toJSON();
        let result = new FormTypeEditDto();
        result.init(json);
        return result;
    }
}

export interface IFormTypeEditDto {
    id: number | undefined;
    title: string | undefined;
}

export class GetFormTypeEditOutput implements IGetFormTypeEditOutput {
    formType: FormTypeEditDto;

    constructor(data?: IGetFormTypeEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formType = _data["formType"] ? FormTypeEditDto.fromJS(_data["formType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetFormTypeEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFormTypeEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formType"] = this.formType ? this.formType.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetFormTypeEditOutput {
        const json = this.toJSON();
        let result = new GetFormTypeEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetFormTypeEditOutput {
    formType: FormTypeEditDto;
}

export class CreateOrUpdateFormTypeDto implements ICreateOrUpdateFormTypeDto {
    formType: FormTypeEditDto;

    constructor(data?: ICreateOrUpdateFormTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formType = _data["formType"] ? FormTypeEditDto.fromJS(_data["formType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateFormTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateFormTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formType"] = this.formType ? this.formType.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateFormTypeDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateFormTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateFormTypeDto {
    formType: FormTypeEditDto;
}

export class FormStatusListDto implements IFormStatusListDto {
    title: string | undefined;
    id: number;

    constructor(data?: IFormStatusListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormStatusListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStatusListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormStatusListDto {
        const json = this.toJSON();
        let result = new FormStatusListDto();
        result.init(json);
        return result;
    }
}

export interface IFormStatusListDto {
    title: string | undefined;
    id: number;
}

export class FormStatusDto implements IFormStatusDto {
    id: number;

    constructor(data?: IFormStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): FormStatusDto {
        const json = this.toJSON();
        let result = new FormStatusDto();
        result.init(json);
        return result;
    }
}

export interface IFormStatusDto {
    id: number;
}

export class FormStatusEditDto implements IFormStatusEditDto {
    id: number | undefined;

    constructor(data?: IFormStatusEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormStatusEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStatusEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): FormStatusEditDto {
        const json = this.toJSON();
        let result = new FormStatusEditDto();
        result.init(json);
        return result;
    }
}

export interface IFormStatusEditDto {
    id: number | undefined;
}

export class GetFormStatusEditOutput implements IGetFormStatusEditOutput {
    formStatus: FormStatusEditDto;

    constructor(data?: IGetFormStatusEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStatus = _data["formStatus"] ? FormStatusEditDto.fromJS(_data["formStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetFormStatusEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFormStatusEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStatus"] = this.formStatus ? this.formStatus.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetFormStatusEditOutput {
        const json = this.toJSON();
        let result = new GetFormStatusEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetFormStatusEditOutput {
    formStatus: FormStatusEditDto;
}

export class CreateOrUpdateFormStatusDto implements ICreateOrUpdateFormStatusDto {
    formStatus: FormStatusEditDto;

    constructor(data?: ICreateOrUpdateFormStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStatus = _data["formStatus"] ? FormStatusEditDto.fromJS(_data["formStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateFormStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateFormStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStatus"] = this.formStatus ? this.formStatus.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateFormStatusDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateFormStatusDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateFormStatusDto {
    formStatus: FormStatusEditDto;
}

export class FormStructurePercentageListDto implements IFormStructurePercentageListDto {
    formStructureRowId: number;
    formStructureColumnId: number;
    isPercentage: boolean;
    formStructureRowDto: FormStructureRowDto;
    formStructureColumnDto: FormStructureColumnDto;
    id: number;

    constructor(data?: IFormStructurePercentageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructureRowId = _data["formStructureRowId"];
            this.formStructureColumnId = _data["formStructureColumnId"];
            this.isPercentage = _data["isPercentage"];
            this.formStructureRowDto = _data["formStructureRowDto"] ? FormStructureRowDto.fromJS(_data["formStructureRowDto"]) : <any>undefined;
            this.formStructureColumnDto = _data["formStructureColumnDto"] ? FormStructureColumnDto.fromJS(_data["formStructureColumnDto"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormStructurePercentageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStructurePercentageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructureRowId"] = this.formStructureRowId;
        data["formStructureColumnId"] = this.formStructureColumnId;
        data["isPercentage"] = this.isPercentage;
        data["formStructureRowDto"] = this.formStructureRowDto ? this.formStructureRowDto.toJSON() : <any>undefined;
        data["formStructureColumnDto"] = this.formStructureColumnDto ? this.formStructureColumnDto.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): FormStructurePercentageListDto {
        const json = this.toJSON();
        let result = new FormStructurePercentageListDto();
        result.init(json);
        return result;
    }
}

export interface IFormStructurePercentageListDto {
    formStructureRowId: number;
    formStructureColumnId: number;
    isPercentage: boolean;
    formStructureRowDto: FormStructureRowDto;
    formStructureColumnDto: FormStructureColumnDto;
    id: number;
}

export class FormStructurePercentageListDtoPagedResultDto implements IFormStructurePercentageListDtoPagedResultDto {
    totalCount: number;
    items: FormStructurePercentageListDto[] | undefined;

    constructor(data?: IFormStructurePercentageListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FormStructurePercentageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormStructurePercentageListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStructurePercentageListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FormStructurePercentageListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FormStructurePercentageListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFormStructurePercentageListDtoPagedResultDto {
    totalCount: number;
    items: FormStructurePercentageListDto[] | undefined;
}

export class FormStructurePercentageEditDto implements IFormStructurePercentageEditDto {
    id: number | undefined;

    constructor(data?: IFormStructurePercentageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FormStructurePercentageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormStructurePercentageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): FormStructurePercentageEditDto {
        const json = this.toJSON();
        let result = new FormStructurePercentageEditDto();
        result.init(json);
        return result;
    }
}

export interface IFormStructurePercentageEditDto {
    id: number | undefined;
}

export class GetFormStructurePercentageEditOutput implements IGetFormStructurePercentageEditOutput {
    formStructurePercentage: FormStructurePercentageEditDto;

    constructor(data?: IGetFormStructurePercentageEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructurePercentage = _data["formStructurePercentage"] ? FormStructurePercentageEditDto.fromJS(_data["formStructurePercentage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetFormStructurePercentageEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFormStructurePercentageEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructurePercentage"] = this.formStructurePercentage ? this.formStructurePercentage.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetFormStructurePercentageEditOutput {
        const json = this.toJSON();
        let result = new GetFormStructurePercentageEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetFormStructurePercentageEditOutput {
    formStructurePercentage: FormStructurePercentageEditDto;
}

export class CreateOrUpdateFormStructurePercentageDto implements ICreateOrUpdateFormStructurePercentageDto {
    formStructurePercentage: FormStructurePercentageEditDto;

    constructor(data?: ICreateOrUpdateFormStructurePercentageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formStructurePercentage = _data["formStructurePercentage"] ? FormStructurePercentageEditDto.fromJS(_data["formStructurePercentage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateFormStructurePercentageDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateFormStructurePercentageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formStructurePercentage"] = this.formStructurePercentage ? this.formStructurePercentage.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateFormStructurePercentageDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateFormStructurePercentageDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateFormStructurePercentageDto {
    formStructurePercentage: FormStructurePercentageEditDto;
}

export enum SerializationFormat {
    _0 = 0,
    _1 = 1,
}

export enum SchemaSerializationMode {
    _1 = 1,
    _2 = 2,
}

export class SortVersion implements ISortVersion {
    readonly fullVersion: number;
    readonly sortId: string;

    constructor(data?: ISortVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).fullVersion = _data["fullVersion"];
            (<any>this).sortId = _data["sortId"];
        }
    }

    static fromJS(data: any): SortVersion {
        data = typeof data === 'object' ? data : {};
        let result = new SortVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullVersion"] = this.fullVersion;
        data["sortId"] = this.sortId;
        return data; 
    }

    clone(): SortVersion {
        const json = this.toJSON();
        let result = new SortVersion();
        result.init(json);
        return result;
    }
}

export interface ISortVersion {
    fullVersion: number;
    sortId: string;
}

export class CompareInfo implements ICompareInfo {
    readonly name: string | undefined;
    version: SortVersion;
    readonly lcid: number;

    constructor(data?: ICompareInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.version = _data["version"] ? SortVersion.fromJS(_data["version"]) : <any>undefined;
            (<any>this).lcid = _data["lcid"];
        }
    }

    static fromJS(data: any): CompareInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CompareInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        data["lcid"] = this.lcid;
        return data; 
    }

    clone(): CompareInfo {
        const json = this.toJSON();
        let result = new CompareInfo();
        result.init(json);
        return result;
    }
}

export interface ICompareInfo {
    name: string | undefined;
    version: SortVersion;
    lcid: number;
}

export class TextInfo implements ITextInfo {
    readonly ansiCodePage: number;
    readonly oemCodePage: number;
    readonly macCodePage: number;
    readonly ebcdicCodePage: number;
    readonly lcid: number;
    readonly cultureName: string | undefined;
    readonly isReadOnly: boolean;
    listSeparator: string | undefined;
    readonly isRightToLeft: boolean;

    constructor(data?: ITextInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).ansiCodePage = _data["ansiCodePage"];
            (<any>this).oemCodePage = _data["oemCodePage"];
            (<any>this).macCodePage = _data["macCodePage"];
            (<any>this).ebcdicCodePage = _data["ebcdicCodePage"];
            (<any>this).lcid = _data["lcid"];
            (<any>this).cultureName = _data["cultureName"];
            (<any>this).isReadOnly = _data["isReadOnly"];
            this.listSeparator = _data["listSeparator"];
            (<any>this).isRightToLeft = _data["isRightToLeft"];
        }
    }

    static fromJS(data: any): TextInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TextInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ansiCodePage"] = this.ansiCodePage;
        data["oemCodePage"] = this.oemCodePage;
        data["macCodePage"] = this.macCodePage;
        data["ebcdicCodePage"] = this.ebcdicCodePage;
        data["lcid"] = this.lcid;
        data["cultureName"] = this.cultureName;
        data["isReadOnly"] = this.isReadOnly;
        data["listSeparator"] = this.listSeparator;
        data["isRightToLeft"] = this.isRightToLeft;
        return data; 
    }

    clone(): TextInfo {
        const json = this.toJSON();
        let result = new TextInfo();
        result.init(json);
        return result;
    }
}

export interface ITextInfo {
    ansiCodePage: number;
    oemCodePage: number;
    macCodePage: number;
    ebcdicCodePage: number;
    lcid: number;
    cultureName: string | undefined;
    isReadOnly: boolean;
    listSeparator: string | undefined;
    isRightToLeft: boolean;
}

export enum CultureTypes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
}

export enum DigitShapes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class NumberFormatInfo implements INumberFormatInfo {
    currencyDecimalDigits: number;
    currencyDecimalSeparator: string | undefined;
    readonly isReadOnly: boolean;
    currencyGroupSizes: number[] | undefined;
    numberGroupSizes: number[] | undefined;
    percentGroupSizes: number[] | undefined;
    currencyGroupSeparator: string | undefined;
    currencySymbol: string | undefined;
    naNSymbol: string | undefined;
    currencyNegativePattern: number;
    numberNegativePattern: number;
    percentPositivePattern: number;
    percentNegativePattern: number;
    negativeInfinitySymbol: string | undefined;
    negativeSign: string | undefined;
    numberDecimalDigits: number;
    numberDecimalSeparator: string | undefined;
    numberGroupSeparator: string | undefined;
    currencyPositivePattern: number;
    positiveInfinitySymbol: string | undefined;
    positiveSign: string | undefined;
    percentDecimalDigits: number;
    percentDecimalSeparator: string | undefined;
    percentGroupSeparator: string | undefined;
    percentSymbol: string | undefined;
    perMilleSymbol: string | undefined;
    nativeDigits: string[] | undefined;
    digitSubstitution: DigitShapes;

    constructor(data?: INumberFormatInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyDecimalDigits = _data["currencyDecimalDigits"];
            this.currencyDecimalSeparator = _data["currencyDecimalSeparator"];
            (<any>this).isReadOnly = _data["isReadOnly"];
            if (Array.isArray(_data["currencyGroupSizes"])) {
                this.currencyGroupSizes = [] as any;
                for (let item of _data["currencyGroupSizes"])
                    this.currencyGroupSizes.push(item);
            }
            if (Array.isArray(_data["numberGroupSizes"])) {
                this.numberGroupSizes = [] as any;
                for (let item of _data["numberGroupSizes"])
                    this.numberGroupSizes.push(item);
            }
            if (Array.isArray(_data["percentGroupSizes"])) {
                this.percentGroupSizes = [] as any;
                for (let item of _data["percentGroupSizes"])
                    this.percentGroupSizes.push(item);
            }
            this.currencyGroupSeparator = _data["currencyGroupSeparator"];
            this.currencySymbol = _data["currencySymbol"];
            this.naNSymbol = _data["naNSymbol"];
            this.currencyNegativePattern = _data["currencyNegativePattern"];
            this.numberNegativePattern = _data["numberNegativePattern"];
            this.percentPositivePattern = _data["percentPositivePattern"];
            this.percentNegativePattern = _data["percentNegativePattern"];
            this.negativeInfinitySymbol = _data["negativeInfinitySymbol"];
            this.negativeSign = _data["negativeSign"];
            this.numberDecimalDigits = _data["numberDecimalDigits"];
            this.numberDecimalSeparator = _data["numberDecimalSeparator"];
            this.numberGroupSeparator = _data["numberGroupSeparator"];
            this.currencyPositivePattern = _data["currencyPositivePattern"];
            this.positiveInfinitySymbol = _data["positiveInfinitySymbol"];
            this.positiveSign = _data["positiveSign"];
            this.percentDecimalDigits = _data["percentDecimalDigits"];
            this.percentDecimalSeparator = _data["percentDecimalSeparator"];
            this.percentGroupSeparator = _data["percentGroupSeparator"];
            this.percentSymbol = _data["percentSymbol"];
            this.perMilleSymbol = _data["perMilleSymbol"];
            if (Array.isArray(_data["nativeDigits"])) {
                this.nativeDigits = [] as any;
                for (let item of _data["nativeDigits"])
                    this.nativeDigits.push(item);
            }
            this.digitSubstitution = _data["digitSubstitution"];
        }
    }

    static fromJS(data: any): NumberFormatInfo {
        data = typeof data === 'object' ? data : {};
        let result = new NumberFormatInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyDecimalDigits"] = this.currencyDecimalDigits;
        data["currencyDecimalSeparator"] = this.currencyDecimalSeparator;
        data["isReadOnly"] = this.isReadOnly;
        if (Array.isArray(this.currencyGroupSizes)) {
            data["currencyGroupSizes"] = [];
            for (let item of this.currencyGroupSizes)
                data["currencyGroupSizes"].push(item);
        }
        if (Array.isArray(this.numberGroupSizes)) {
            data["numberGroupSizes"] = [];
            for (let item of this.numberGroupSizes)
                data["numberGroupSizes"].push(item);
        }
        if (Array.isArray(this.percentGroupSizes)) {
            data["percentGroupSizes"] = [];
            for (let item of this.percentGroupSizes)
                data["percentGroupSizes"].push(item);
        }
        data["currencyGroupSeparator"] = this.currencyGroupSeparator;
        data["currencySymbol"] = this.currencySymbol;
        data["naNSymbol"] = this.naNSymbol;
        data["currencyNegativePattern"] = this.currencyNegativePattern;
        data["numberNegativePattern"] = this.numberNegativePattern;
        data["percentPositivePattern"] = this.percentPositivePattern;
        data["percentNegativePattern"] = this.percentNegativePattern;
        data["negativeInfinitySymbol"] = this.negativeInfinitySymbol;
        data["negativeSign"] = this.negativeSign;
        data["numberDecimalDigits"] = this.numberDecimalDigits;
        data["numberDecimalSeparator"] = this.numberDecimalSeparator;
        data["numberGroupSeparator"] = this.numberGroupSeparator;
        data["currencyPositivePattern"] = this.currencyPositivePattern;
        data["positiveInfinitySymbol"] = this.positiveInfinitySymbol;
        data["positiveSign"] = this.positiveSign;
        data["percentDecimalDigits"] = this.percentDecimalDigits;
        data["percentDecimalSeparator"] = this.percentDecimalSeparator;
        data["percentGroupSeparator"] = this.percentGroupSeparator;
        data["percentSymbol"] = this.percentSymbol;
        data["perMilleSymbol"] = this.perMilleSymbol;
        if (Array.isArray(this.nativeDigits)) {
            data["nativeDigits"] = [];
            for (let item of this.nativeDigits)
                data["nativeDigits"].push(item);
        }
        data["digitSubstitution"] = this.digitSubstitution;
        return data; 
    }

    clone(): NumberFormatInfo {
        const json = this.toJSON();
        let result = new NumberFormatInfo();
        result.init(json);
        return result;
    }
}

export interface INumberFormatInfo {
    currencyDecimalDigits: number;
    currencyDecimalSeparator: string | undefined;
    isReadOnly: boolean;
    currencyGroupSizes: number[] | undefined;
    numberGroupSizes: number[] | undefined;
    percentGroupSizes: number[] | undefined;
    currencyGroupSeparator: string | undefined;
    currencySymbol: string | undefined;
    naNSymbol: string | undefined;
    currencyNegativePattern: number;
    numberNegativePattern: number;
    percentPositivePattern: number;
    percentNegativePattern: number;
    negativeInfinitySymbol: string | undefined;
    negativeSign: string | undefined;
    numberDecimalDigits: number;
    numberDecimalSeparator: string | undefined;
    numberGroupSeparator: string | undefined;
    currencyPositivePattern: number;
    positiveInfinitySymbol: string | undefined;
    positiveSign: string | undefined;
    percentDecimalDigits: number;
    percentDecimalSeparator: string | undefined;
    percentGroupSeparator: string | undefined;
    percentSymbol: string | undefined;
    perMilleSymbol: string | undefined;
    nativeDigits: string[] | undefined;
    digitSubstitution: DigitShapes;
}

export enum CalendarAlgorithmType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class Calendar implements ICalendar {
    readonly minSupportedDateTime: moment.Moment;
    readonly maxSupportedDateTime: moment.Moment;
    algorithmType: CalendarAlgorithmType;
    readonly isReadOnly: boolean;
    readonly eras: number[] | undefined;
    twoDigitYearMax: number;

    constructor(data?: ICalendar) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).minSupportedDateTime = _data["minSupportedDateTime"] ? moment(_data["minSupportedDateTime"].toString()) : <any>undefined;
            (<any>this).maxSupportedDateTime = _data["maxSupportedDateTime"] ? moment(_data["maxSupportedDateTime"].toString()) : <any>undefined;
            this.algorithmType = _data["algorithmType"];
            (<any>this).isReadOnly = _data["isReadOnly"];
            if (Array.isArray(_data["eras"])) {
                (<any>this).eras = [] as any;
                for (let item of _data["eras"])
                    (<any>this).eras.push(item);
            }
            this.twoDigitYearMax = _data["twoDigitYearMax"];
        }
    }

    static fromJS(data: any): Calendar {
        data = typeof data === 'object' ? data : {};
        let result = new Calendar();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minSupportedDateTime"] = this.minSupportedDateTime ? this.minSupportedDateTime.toISOString() : <any>undefined;
        data["maxSupportedDateTime"] = this.maxSupportedDateTime ? this.maxSupportedDateTime.toISOString() : <any>undefined;
        data["algorithmType"] = this.algorithmType;
        data["isReadOnly"] = this.isReadOnly;
        if (Array.isArray(this.eras)) {
            data["eras"] = [];
            for (let item of this.eras)
                data["eras"].push(item);
        }
        data["twoDigitYearMax"] = this.twoDigitYearMax;
        return data; 
    }

    clone(): Calendar {
        const json = this.toJSON();
        let result = new Calendar();
        result.init(json);
        return result;
    }
}

export interface ICalendar {
    minSupportedDateTime: moment.Moment;
    maxSupportedDateTime: moment.Moment;
    algorithmType: CalendarAlgorithmType;
    isReadOnly: boolean;
    eras: number[] | undefined;
    twoDigitYearMax: number;
}

export enum DayOfWeek {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export enum CalendarWeekRule {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class DateTimeFormatInfo implements IDateTimeFormatInfo {
    amDesignator: string | undefined;
    calendar: Calendar;
    dateSeparator: string | undefined;
    firstDayOfWeek: DayOfWeek;
    calendarWeekRule: CalendarWeekRule;
    fullDateTimePattern: string | undefined;
    longDatePattern: string | undefined;
    longTimePattern: string | undefined;
    monthDayPattern: string | undefined;
    pmDesignator: string | undefined;
    readonly rfC1123Pattern: string | undefined;
    shortDatePattern: string | undefined;
    shortTimePattern: string | undefined;
    readonly sortableDateTimePattern: string | undefined;
    timeSeparator: string | undefined;
    readonly universalSortableDateTimePattern: string | undefined;
    yearMonthPattern: string | undefined;
    abbreviatedDayNames: string[] | undefined;
    shortestDayNames: string[] | undefined;
    dayNames: string[] | undefined;
    abbreviatedMonthNames: string[] | undefined;
    monthNames: string[] | undefined;
    readonly isReadOnly: boolean;
    readonly nativeCalendarName: string | undefined;
    abbreviatedMonthGenitiveNames: string[] | undefined;
    monthGenitiveNames: string[] | undefined;

    constructor(data?: IDateTimeFormatInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amDesignator = _data["amDesignator"];
            this.calendar = _data["calendar"] ? Calendar.fromJS(_data["calendar"]) : <any>undefined;
            this.dateSeparator = _data["dateSeparator"];
            this.firstDayOfWeek = _data["firstDayOfWeek"];
            this.calendarWeekRule = _data["calendarWeekRule"];
            this.fullDateTimePattern = _data["fullDateTimePattern"];
            this.longDatePattern = _data["longDatePattern"];
            this.longTimePattern = _data["longTimePattern"];
            this.monthDayPattern = _data["monthDayPattern"];
            this.pmDesignator = _data["pmDesignator"];
            (<any>this).rfC1123Pattern = _data["rfC1123Pattern"];
            this.shortDatePattern = _data["shortDatePattern"];
            this.shortTimePattern = _data["shortTimePattern"];
            (<any>this).sortableDateTimePattern = _data["sortableDateTimePattern"];
            this.timeSeparator = _data["timeSeparator"];
            (<any>this).universalSortableDateTimePattern = _data["universalSortableDateTimePattern"];
            this.yearMonthPattern = _data["yearMonthPattern"];
            if (Array.isArray(_data["abbreviatedDayNames"])) {
                this.abbreviatedDayNames = [] as any;
                for (let item of _data["abbreviatedDayNames"])
                    this.abbreviatedDayNames.push(item);
            }
            if (Array.isArray(_data["shortestDayNames"])) {
                this.shortestDayNames = [] as any;
                for (let item of _data["shortestDayNames"])
                    this.shortestDayNames.push(item);
            }
            if (Array.isArray(_data["dayNames"])) {
                this.dayNames = [] as any;
                for (let item of _data["dayNames"])
                    this.dayNames.push(item);
            }
            if (Array.isArray(_data["abbreviatedMonthNames"])) {
                this.abbreviatedMonthNames = [] as any;
                for (let item of _data["abbreviatedMonthNames"])
                    this.abbreviatedMonthNames.push(item);
            }
            if (Array.isArray(_data["monthNames"])) {
                this.monthNames = [] as any;
                for (let item of _data["monthNames"])
                    this.monthNames.push(item);
            }
            (<any>this).isReadOnly = _data["isReadOnly"];
            (<any>this).nativeCalendarName = _data["nativeCalendarName"];
            if (Array.isArray(_data["abbreviatedMonthGenitiveNames"])) {
                this.abbreviatedMonthGenitiveNames = [] as any;
                for (let item of _data["abbreviatedMonthGenitiveNames"])
                    this.abbreviatedMonthGenitiveNames.push(item);
            }
            if (Array.isArray(_data["monthGenitiveNames"])) {
                this.monthGenitiveNames = [] as any;
                for (let item of _data["monthGenitiveNames"])
                    this.monthGenitiveNames.push(item);
            }
        }
    }

    static fromJS(data: any): DateTimeFormatInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeFormatInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amDesignator"] = this.amDesignator;
        data["calendar"] = this.calendar ? this.calendar.toJSON() : <any>undefined;
        data["dateSeparator"] = this.dateSeparator;
        data["firstDayOfWeek"] = this.firstDayOfWeek;
        data["calendarWeekRule"] = this.calendarWeekRule;
        data["fullDateTimePattern"] = this.fullDateTimePattern;
        data["longDatePattern"] = this.longDatePattern;
        data["longTimePattern"] = this.longTimePattern;
        data["monthDayPattern"] = this.monthDayPattern;
        data["pmDesignator"] = this.pmDesignator;
        data["rfC1123Pattern"] = this.rfC1123Pattern;
        data["shortDatePattern"] = this.shortDatePattern;
        data["shortTimePattern"] = this.shortTimePattern;
        data["sortableDateTimePattern"] = this.sortableDateTimePattern;
        data["timeSeparator"] = this.timeSeparator;
        data["universalSortableDateTimePattern"] = this.universalSortableDateTimePattern;
        data["yearMonthPattern"] = this.yearMonthPattern;
        if (Array.isArray(this.abbreviatedDayNames)) {
            data["abbreviatedDayNames"] = [];
            for (let item of this.abbreviatedDayNames)
                data["abbreviatedDayNames"].push(item);
        }
        if (Array.isArray(this.shortestDayNames)) {
            data["shortestDayNames"] = [];
            for (let item of this.shortestDayNames)
                data["shortestDayNames"].push(item);
        }
        if (Array.isArray(this.dayNames)) {
            data["dayNames"] = [];
            for (let item of this.dayNames)
                data["dayNames"].push(item);
        }
        if (Array.isArray(this.abbreviatedMonthNames)) {
            data["abbreviatedMonthNames"] = [];
            for (let item of this.abbreviatedMonthNames)
                data["abbreviatedMonthNames"].push(item);
        }
        if (Array.isArray(this.monthNames)) {
            data["monthNames"] = [];
            for (let item of this.monthNames)
                data["monthNames"].push(item);
        }
        data["isReadOnly"] = this.isReadOnly;
        data["nativeCalendarName"] = this.nativeCalendarName;
        if (Array.isArray(this.abbreviatedMonthGenitiveNames)) {
            data["abbreviatedMonthGenitiveNames"] = [];
            for (let item of this.abbreviatedMonthGenitiveNames)
                data["abbreviatedMonthGenitiveNames"].push(item);
        }
        if (Array.isArray(this.monthGenitiveNames)) {
            data["monthGenitiveNames"] = [];
            for (let item of this.monthGenitiveNames)
                data["monthGenitiveNames"].push(item);
        }
        return data; 
    }

    clone(): DateTimeFormatInfo {
        const json = this.toJSON();
        let result = new DateTimeFormatInfo();
        result.init(json);
        return result;
    }
}

export interface IDateTimeFormatInfo {
    amDesignator: string | undefined;
    calendar: Calendar;
    dateSeparator: string | undefined;
    firstDayOfWeek: DayOfWeek;
    calendarWeekRule: CalendarWeekRule;
    fullDateTimePattern: string | undefined;
    longDatePattern: string | undefined;
    longTimePattern: string | undefined;
    monthDayPattern: string | undefined;
    pmDesignator: string | undefined;
    rfC1123Pattern: string | undefined;
    shortDatePattern: string | undefined;
    shortTimePattern: string | undefined;
    sortableDateTimePattern: string | undefined;
    timeSeparator: string | undefined;
    universalSortableDateTimePattern: string | undefined;
    yearMonthPattern: string | undefined;
    abbreviatedDayNames: string[] | undefined;
    shortestDayNames: string[] | undefined;
    dayNames: string[] | undefined;
    abbreviatedMonthNames: string[] | undefined;
    monthNames: string[] | undefined;
    isReadOnly: boolean;
    nativeCalendarName: string | undefined;
    abbreviatedMonthGenitiveNames: string[] | undefined;
    monthGenitiveNames: string[] | undefined;
}

export class CultureInfo implements ICultureInfo {
    parent: CultureInfo;
    readonly lcid: number;
    readonly keyboardLayoutId: number;
    readonly name: string | undefined;
    readonly ietfLanguageTag: string | undefined;
    readonly displayName: string | undefined;
    readonly nativeName: string | undefined;
    readonly englishName: string | undefined;
    readonly twoLetterISOLanguageName: string | undefined;
    readonly threeLetterISOLanguageName: string | undefined;
    readonly threeLetterWindowsLanguageName: string | undefined;
    compareInfo: CompareInfo;
    textInfo: TextInfo;
    readonly isNeutralCulture: boolean;
    cultureTypes: CultureTypes;
    numberFormat: NumberFormatInfo;
    dateTimeFormat: DateTimeFormatInfo;
    calendar: Calendar;
    readonly optionalCalendars: Calendar[] | undefined;
    readonly useUserOverride: boolean;
    readonly isReadOnly: boolean;

    constructor(data?: ICultureInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parent = _data["parent"] ? CultureInfo.fromJS(_data["parent"]) : <any>undefined;
            (<any>this).lcid = _data["lcid"];
            (<any>this).keyboardLayoutId = _data["keyboardLayoutId"];
            (<any>this).name = _data["name"];
            (<any>this).ietfLanguageTag = _data["ietfLanguageTag"];
            (<any>this).displayName = _data["displayName"];
            (<any>this).nativeName = _data["nativeName"];
            (<any>this).englishName = _data["englishName"];
            (<any>this).twoLetterISOLanguageName = _data["twoLetterISOLanguageName"];
            (<any>this).threeLetterISOLanguageName = _data["threeLetterISOLanguageName"];
            (<any>this).threeLetterWindowsLanguageName = _data["threeLetterWindowsLanguageName"];
            this.compareInfo = _data["compareInfo"] ? CompareInfo.fromJS(_data["compareInfo"]) : <any>undefined;
            this.textInfo = _data["textInfo"] ? TextInfo.fromJS(_data["textInfo"]) : <any>undefined;
            (<any>this).isNeutralCulture = _data["isNeutralCulture"];
            this.cultureTypes = _data["cultureTypes"];
            this.numberFormat = _data["numberFormat"] ? NumberFormatInfo.fromJS(_data["numberFormat"]) : <any>undefined;
            this.dateTimeFormat = _data["dateTimeFormat"] ? DateTimeFormatInfo.fromJS(_data["dateTimeFormat"]) : <any>undefined;
            this.calendar = _data["calendar"] ? Calendar.fromJS(_data["calendar"]) : <any>undefined;
            if (Array.isArray(_data["optionalCalendars"])) {
                (<any>this).optionalCalendars = [] as any;
                for (let item of _data["optionalCalendars"])
                    (<any>this).optionalCalendars.push(Calendar.fromJS(item));
            }
            (<any>this).useUserOverride = _data["useUserOverride"];
            (<any>this).isReadOnly = _data["isReadOnly"];
        }
    }

    static fromJS(data: any): CultureInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CultureInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["lcid"] = this.lcid;
        data["keyboardLayoutId"] = this.keyboardLayoutId;
        data["name"] = this.name;
        data["ietfLanguageTag"] = this.ietfLanguageTag;
        data["displayName"] = this.displayName;
        data["nativeName"] = this.nativeName;
        data["englishName"] = this.englishName;
        data["twoLetterISOLanguageName"] = this.twoLetterISOLanguageName;
        data["threeLetterISOLanguageName"] = this.threeLetterISOLanguageName;
        data["threeLetterWindowsLanguageName"] = this.threeLetterWindowsLanguageName;
        data["compareInfo"] = this.compareInfo ? this.compareInfo.toJSON() : <any>undefined;
        data["textInfo"] = this.textInfo ? this.textInfo.toJSON() : <any>undefined;
        data["isNeutralCulture"] = this.isNeutralCulture;
        data["cultureTypes"] = this.cultureTypes;
        data["numberFormat"] = this.numberFormat ? this.numberFormat.toJSON() : <any>undefined;
        data["dateTimeFormat"] = this.dateTimeFormat ? this.dateTimeFormat.toJSON() : <any>undefined;
        data["calendar"] = this.calendar ? this.calendar.toJSON() : <any>undefined;
        if (Array.isArray(this.optionalCalendars)) {
            data["optionalCalendars"] = [];
            for (let item of this.optionalCalendars)
                data["optionalCalendars"].push(item.toJSON());
        }
        data["useUserOverride"] = this.useUserOverride;
        data["isReadOnly"] = this.isReadOnly;
        return data; 
    }

    clone(): CultureInfo {
        const json = this.toJSON();
        let result = new CultureInfo();
        result.init(json);
        return result;
    }
}

export interface ICultureInfo {
    parent: CultureInfo;
    lcid: number;
    keyboardLayoutId: number;
    name: string | undefined;
    ietfLanguageTag: string | undefined;
    displayName: string | undefined;
    nativeName: string | undefined;
    englishName: string | undefined;
    twoLetterISOLanguageName: string | undefined;
    threeLetterISOLanguageName: string | undefined;
    threeLetterWindowsLanguageName: string | undefined;
    compareInfo: CompareInfo;
    textInfo: TextInfo;
    isNeutralCulture: boolean;
    cultureTypes: CultureTypes;
    numberFormat: NumberFormatInfo;
    dateTimeFormat: DateTimeFormatInfo;
    calendar: Calendar;
    optionalCalendars: Calendar[] | undefined;
    useUserOverride: boolean;
    isReadOnly: boolean;
}

export class IComponent implements IIComponent {
    site: ISite;

    constructor(data?: IIComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IComponent {
        data = typeof data === 'object' ? data : {};
        let result = new IComponent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        return data; 
    }

    clone(): IComponent {
        const json = this.toJSON();
        let result = new IComponent();
        result.init(json);
        return result;
    }
}

export interface IIComponent {
    site: ISite;
}

export class IContainer implements IIContainer {
    readonly components: any[] | undefined;

    constructor(data?: IIContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["components"])) {
                (<any>this).components = [] as any;
                for (let item of _data["components"])
                    (<any>this).components.push(item);
            }
        }
    }

    static fromJS(data: any): IContainer {
        data = typeof data === 'object' ? data : {};
        let result = new IContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item);
        }
        return data; 
    }

    clone(): IContainer {
        const json = this.toJSON();
        let result = new IContainer();
        result.init(json);
        return result;
    }
}

export interface IIContainer {
    components: any[] | undefined;
}

export class ISite implements IISite {
    component: IComponent;
    container: IContainer;
    readonly designMode: boolean;
    name: string | undefined;

    constructor(data?: IISite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.component = _data["component"] ? IComponent.fromJS(_data["component"]) : <any>undefined;
            this.container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ISite {
        data = typeof data === 'object' ? data : {};
        let result = new ISite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["component"] = this.component ? this.component.toJSON() : <any>undefined;
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        data["name"] = this.name;
        return data; 
    }

    clone(): ISite {
        const json = this.toJSON();
        let result = new ISite();
        result.init(json);
        return result;
    }
}

export interface IISite {
    component: IComponent;
    container: IContainer;
    designMode: boolean;
    name: string | undefined;
}

export class DataSet implements IDataSet {
    remotingFormat: SerializationFormat;
    schemaSerializationMode: SchemaSerializationMode;
    caseSensitive: boolean;
    readonly defaultViewManager: any[] | undefined;
    enforceConstraints: boolean;
    dataSetName: string | undefined;
    namespace: string | undefined;
    prefix: string | undefined;
    readonly extendedProperties: { [key: string]: any; } | undefined;
    readonly hasErrors: boolean;
    readonly isInitialized: boolean;
    locale: CultureInfo;
    site: ISite;
    readonly relations: any[] | undefined;
    readonly tables: any[] | undefined;
    container: IContainer;
    readonly designMode: boolean;

    constructor(data?: IDataSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.caseSensitive = false;
            this.enforceConstraints = true;
            this.dataSetName = "";
            this.namespace = "";
            this.prefix = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remotingFormat = _data["remotingFormat"];
            this.schemaSerializationMode = _data["schemaSerializationMode"];
            this.caseSensitive = _data["caseSensitive"] !== undefined ? _data["caseSensitive"] : false;
            if (Array.isArray(_data["defaultViewManager"])) {
                (<any>this).defaultViewManager = [] as any;
                for (let item of _data["defaultViewManager"])
                    (<any>this).defaultViewManager.push(item);
            }
            this.enforceConstraints = _data["enforceConstraints"] !== undefined ? _data["enforceConstraints"] : true;
            this.dataSetName = _data["dataSetName"] !== undefined ? _data["dataSetName"] : "";
            this.namespace = _data["namespace"] !== undefined ? _data["namespace"] : "";
            this.prefix = _data["prefix"] !== undefined ? _data["prefix"] : "";
            if (_data["extendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["extendedProperties"]) {
                    if (_data["extendedProperties"].hasOwnProperty(key))
                        (<any>this).extendedProperties[key] = _data["extendedProperties"][key];
                }
            }
            (<any>this).hasErrors = _data["hasErrors"];
            (<any>this).isInitialized = _data["isInitialized"];
            this.locale = _data["locale"] ? CultureInfo.fromJS(_data["locale"]) : <any>undefined;
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
            if (Array.isArray(_data["relations"])) {
                (<any>this).relations = [] as any;
                for (let item of _data["relations"])
                    (<any>this).relations.push(item);
            }
            if (Array.isArray(_data["tables"])) {
                (<any>this).tables = [] as any;
                for (let item of _data["tables"])
                    (<any>this).tables.push(item);
            }
            this.container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
        }
    }

    static fromJS(data: any): DataSet {
        data = typeof data === 'object' ? data : {};
        let result = new DataSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remotingFormat"] = this.remotingFormat;
        data["schemaSerializationMode"] = this.schemaSerializationMode;
        data["caseSensitive"] = this.caseSensitive;
        if (Array.isArray(this.defaultViewManager)) {
            data["defaultViewManager"] = [];
            for (let item of this.defaultViewManager)
                data["defaultViewManager"].push(item);
        }
        data["enforceConstraints"] = this.enforceConstraints;
        data["dataSetName"] = this.dataSetName;
        data["namespace"] = this.namespace;
        data["prefix"] = this.prefix;
        if (this.extendedProperties) {
            data["extendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    data["extendedProperties"][key] = this.extendedProperties[key];
            }
        }
        data["hasErrors"] = this.hasErrors;
        data["isInitialized"] = this.isInitialized;
        data["locale"] = this.locale ? this.locale.toJSON() : <any>undefined;
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        if (Array.isArray(this.relations)) {
            data["relations"] = [];
            for (let item of this.relations)
                data["relations"].push(item);
        }
        if (Array.isArray(this.tables)) {
            data["tables"] = [];
            for (let item of this.tables)
                data["tables"].push(item);
        }
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        return data; 
    }

    clone(): DataSet {
        const json = this.toJSON();
        let result = new DataSet();
        result.init(json);
        return result;
    }
}

export interface IDataSet {
    remotingFormat: SerializationFormat;
    schemaSerializationMode: SchemaSerializationMode;
    caseSensitive: boolean;
    defaultViewManager: any[] | undefined;
    enforceConstraints: boolean;
    dataSetName: string | undefined;
    namespace: string | undefined;
    prefix: string | undefined;
    extendedProperties: { [key: string]: any; } | undefined;
    hasErrors: boolean;
    isInitialized: boolean;
    locale: CultureInfo;
    site: ISite;
    relations: any[] | undefined;
    tables: any[] | undefined;
    container: IContainer;
    designMode: boolean;
}

export enum MemberTypes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum MethodAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _53248 = 53248,
}

export enum MethodImplAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _4096 = 4096,
    _65535 = 65535,
}

export enum CallingConventions {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _32 = 32,
    _64 = 64,
}

export class IntPtr implements IIntPtr {

    constructor(data?: IIntPtr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IntPtr {
        data = typeof data === 'object' ? data : {};
        let result = new IntPtr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): IntPtr {
        const json = this.toJSON();
        let result = new IntPtr();
        result.init(json);
        return result;
    }
}

export interface IIntPtr {
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
    value: IntPtr;

    constructor(data?: IRuntimeMethodHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeMethodHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeMethodHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RuntimeMethodHandle {
        const json = this.toJSON();
        let result = new RuntimeMethodHandle();
        result.init(json);
        return result;
    }
}

export interface IRuntimeMethodHandle {
    value: IntPtr;
}

export class ModuleHandle implements IModuleHandle {
    readonly mdStreamVersion: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mdStreamVersion"] = this.mdStreamVersion;
        return data; 
    }

    clone(): ModuleHandle {
        const json = this.toJSON();
        let result = new ModuleHandle();
        result.init(json);
        return result;
    }
}

export interface IModuleHandle {
    mdStreamVersion: number;
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType: Type;
    readonly value: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.argumentType = _data["argumentType"] ? Type.fromJS(_data["argumentType"]) : <any>undefined;
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentType"] = this.argumentType ? this.argumentType.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data; 
    }

    clone(): CustomAttributeTypedArgument {
        const json = this.toJSON();
        let result = new CustomAttributeTypedArgument();
        result.init(json);
        return result;
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType: Type;
    value: any | undefined;
}

export class MemberInfo implements IMemberInfo {
    memberType: MemberTypes;
    declaringType: Type;
    reflectedType: Type;
    readonly name: string | undefined;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }

    clone(): MemberInfo {
        const json = this.toJSON();
        let result = new MemberInfo();
        result.init(json);
        return result;
    }
}

export interface IMemberInfo {
    memberType: MemberTypes;
    declaringType: Type;
    reflectedType: Type;
    name: string | undefined;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo: MemberInfo;
    typedValue: CustomAttributeTypedArgument;
    readonly memberName: string | undefined;
    readonly isField: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberInfo = _data["memberInfo"] ? MemberInfo.fromJS(_data["memberInfo"]) : <any>undefined;
            this.typedValue = _data["typedValue"] ? CustomAttributeTypedArgument.fromJS(_data["typedValue"]) : <any>undefined;
            (<any>this).memberName = _data["memberName"];
            (<any>this).isField = _data["isField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["typedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["memberName"] = this.memberName;
        data["isField"] = this.isField;
        return data; 
    }

    clone(): CustomAttributeNamedArgument {
        const json = this.toJSON();
        let result = new CustomAttributeNamedArgument();
        result.init(json);
        return result;
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo: MemberInfo;
    typedValue: CustomAttributeTypedArgument;
    memberName: string | undefined;
    isField: boolean;
}

export class CustomAttributeData implements ICustomAttributeData {
    attributeType: Type;
    constructor_: ConstructorInfo;
    readonly constructorArguments: CustomAttributeTypedArgument[] | undefined;
    readonly namedArguments: CustomAttributeNamedArgument[] | undefined;

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeType = _data["attributeType"] ? Type.fromJS(_data["attributeType"]) : <any>undefined;
            this.constructor_ = _data["constructor"] ? ConstructorInfo.fromJS(_data["constructor"]) : <any>undefined;
            if (Array.isArray(_data["constructorArguments"])) {
                (<any>this).constructorArguments = [] as any;
                for (let item of _data["constructorArguments"])
                    (<any>this).constructorArguments.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (Array.isArray(_data["namedArguments"])) {
                (<any>this).namedArguments = [] as any;
                for (let item of _data["namedArguments"])
                    (<any>this).namedArguments.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeType"] = this.attributeType ? this.attributeType.toJSON() : <any>undefined;
        data["constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (Array.isArray(this.constructorArguments)) {
            data["constructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["constructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["namedArguments"] = [];
            for (let item of this.namedArguments)
                data["namedArguments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CustomAttributeData {
        const json = this.toJSON();
        let result = new CustomAttributeData();
        result.init(json);
        return result;
    }
}

export interface ICustomAttributeData {
    attributeType: Type;
    constructor_: ConstructorInfo;
    constructorArguments: CustomAttributeTypedArgument[] | undefined;
    namedArguments: CustomAttributeNamedArgument[] | undefined;
}

export class Module implements IModule {
    assembly: Assembly;
    readonly fullyQualifiedName: string | undefined;
    readonly name: string | undefined;
    readonly mdStreamVersion: number;
    readonly moduleVersionId: string;
    readonly scopeName: string | undefined;
    moduleHandle: ModuleHandle;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly metadataToken: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            (<any>this).fullyQualifiedName = _data["fullyQualifiedName"];
            (<any>this).name = _data["name"];
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
            (<any>this).moduleVersionId = _data["moduleVersionId"];
            (<any>this).scopeName = _data["scopeName"];
            this.moduleHandle = _data["moduleHandle"] ? ModuleHandle.fromJS(_data["moduleHandle"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["fullyQualifiedName"] = this.fullyQualifiedName;
        data["name"] = this.name;
        data["mdStreamVersion"] = this.mdStreamVersion;
        data["moduleVersionId"] = this.moduleVersionId;
        data["scopeName"] = this.scopeName;
        data["moduleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data; 
    }

    clone(): Module {
        const json = this.toJSON();
        let result = new Module();
        result.init(json);
        return result;
    }
}

export interface IModule {
    assembly: Assembly;
    fullyQualifiedName: string | undefined;
    name: string | undefined;
    mdStreamVersion: number;
    moduleVersionId: string;
    scopeName: string | undefined;
    moduleHandle: ModuleHandle;
    customAttributes: CustomAttributeData[] | undefined;
    metadataToken: number;
}

export class ConstructorInfo implements IConstructorInfo {
    memberType: MemberTypes;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    readonly isAbstract: boolean;
    readonly isConstructor: boolean;
    readonly isFinal: boolean;
    readonly isHideBySig: boolean;
    readonly isSpecialName: boolean;
    readonly isStatic: boolean;
    readonly isVirtual: boolean;
    readonly isAssembly: boolean;
    readonly isFamily: boolean;
    readonly isFamilyAndAssembly: boolean;
    readonly isFamilyOrAssembly: boolean;
    readonly isPrivate: boolean;
    readonly isPublic: boolean;
    readonly isConstructedGenericMethod: boolean;
    readonly isGenericMethod: boolean;
    readonly isGenericMethodDefinition: boolean;
    readonly containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    readonly name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IConstructorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }

    clone(): ConstructorInfo {
        const json = this.toJSON();
        let result = new ConstructorInfo();
        result.init(json);
        return result;
    }
}

export interface IConstructorInfo {
    memberType: MemberTypes;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum EventAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
}

export enum ParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _61440 = 61440,
}

export class ParameterInfo implements IParameterInfo {
    attributes: ParameterAttributes;
    member: MemberInfo;
    readonly name: string | undefined;
    parameterType: Type;
    readonly position: number;
    readonly isIn: boolean;
    readonly isLcid: boolean;
    readonly isOptional: boolean;
    readonly isOut: boolean;
    readonly isRetval: boolean;
    readonly defaultValue: any | undefined;
    readonly rawDefaultValue: any | undefined;
    readonly hasDefaultValue: boolean;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly metadataToken: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["attributes"];
            this.member = _data["member"] ? MemberInfo.fromJS(_data["member"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.parameterType = _data["parameterType"] ? Type.fromJS(_data["parameterType"]) : <any>undefined;
            (<any>this).position = _data["position"];
            (<any>this).isIn = _data["isIn"];
            (<any>this).isLcid = _data["isLcid"];
            (<any>this).isOptional = _data["isOptional"];
            (<any>this).isOut = _data["isOut"];
            (<any>this).isRetval = _data["isRetval"];
            (<any>this).defaultValue = _data["defaultValue"];
            (<any>this).rawDefaultValue = _data["rawDefaultValue"];
            (<any>this).hasDefaultValue = _data["hasDefaultValue"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["parameterType"] = this.parameterType ? this.parameterType.toJSON() : <any>undefined;
        data["position"] = this.position;
        data["isIn"] = this.isIn;
        data["isLcid"] = this.isLcid;
        data["isOptional"] = this.isOptional;
        data["isOut"] = this.isOut;
        data["isRetval"] = this.isRetval;
        data["defaultValue"] = this.defaultValue;
        data["rawDefaultValue"] = this.rawDefaultValue;
        data["hasDefaultValue"] = this.hasDefaultValue;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data; 
    }

    clone(): ParameterInfo {
        const json = this.toJSON();
        let result = new ParameterInfo();
        result.init(json);
        return result;
    }
}

export interface IParameterInfo {
    attributes: ParameterAttributes;
    member: MemberInfo;
    name: string | undefined;
    parameterType: Type;
    position: number;
    isIn: boolean;
    isLcid: boolean;
    isOptional: boolean;
    isOut: boolean;
    isRetval: boolean;
    defaultValue: any | undefined;
    rawDefaultValue: any | undefined;
    hasDefaultValue: boolean;
    customAttributes: CustomAttributeData[] | undefined;
    metadataToken: number;
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {

    constructor(data?: IICustomAttributeProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICustomAttributeProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ICustomAttributeProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): ICustomAttributeProvider {
        const json = this.toJSON();
        let result = new ICustomAttributeProvider();
        result.init(json);
        return result;
    }
}

export interface IICustomAttributeProvider {
}

export class MethodInfo implements IMethodInfo {
    memberType: MemberTypes;
    returnParameter: ParameterInfo;
    returnType: Type;
    returnTypeCustomAttributes: ICustomAttributeProvider;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    readonly isAbstract: boolean;
    readonly isConstructor: boolean;
    readonly isFinal: boolean;
    readonly isHideBySig: boolean;
    readonly isSpecialName: boolean;
    readonly isStatic: boolean;
    readonly isVirtual: boolean;
    readonly isAssembly: boolean;
    readonly isFamily: boolean;
    readonly isFamilyAndAssembly: boolean;
    readonly isFamilyOrAssembly: boolean;
    readonly isPrivate: boolean;
    readonly isPublic: boolean;
    readonly isConstructedGenericMethod: boolean;
    readonly isGenericMethod: boolean;
    readonly isGenericMethodDefinition: boolean;
    readonly containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    readonly name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.returnParameter = _data["returnParameter"] ? ParameterInfo.fromJS(_data["returnParameter"]) : <any>undefined;
            this.returnType = _data["returnType"] ? Type.fromJS(_data["returnType"]) : <any>undefined;
            this.returnTypeCustomAttributes = _data["returnTypeCustomAttributes"] ? ICustomAttributeProvider.fromJS(_data["returnTypeCustomAttributes"]) : <any>undefined;
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["returnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["returnType"] = this.returnType ? this.returnType.toJSON() : <any>undefined;
        data["returnTypeCustomAttributes"] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }

    clone(): MethodInfo {
        const json = this.toJSON();
        let result = new MethodInfo();
        result.init(json);
        return result;
    }
}

export interface IMethodInfo {
    memberType: MemberTypes;
    returnParameter: ParameterInfo;
    returnType: Type;
    returnTypeCustomAttributes: ICustomAttributeProvider;
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export class EventInfo implements IEventInfo {
    memberType: MemberTypes;
    attributes: EventAttributes;
    readonly isSpecialName: boolean;
    addMethod: MethodInfo;
    removeMethod: MethodInfo;
    raiseMethod: MethodInfo;
    readonly isMulticast: boolean;
    eventHandlerType: Type;
    readonly name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IEventInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            this.addMethod = _data["addMethod"] ? MethodInfo.fromJS(_data["addMethod"]) : <any>undefined;
            this.removeMethod = _data["removeMethod"] ? MethodInfo.fromJS(_data["removeMethod"]) : <any>undefined;
            this.raiseMethod = _data["raiseMethod"] ? MethodInfo.fromJS(_data["raiseMethod"]) : <any>undefined;
            (<any>this).isMulticast = _data["isMulticast"];
            this.eventHandlerType = _data["eventHandlerType"] ? Type.fromJS(_data["eventHandlerType"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): EventInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EventInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["addMethod"] = this.addMethod ? this.addMethod.toJSON() : <any>undefined;
        data["removeMethod"] = this.removeMethod ? this.removeMethod.toJSON() : <any>undefined;
        data["raiseMethod"] = this.raiseMethod ? this.raiseMethod.toJSON() : <any>undefined;
        data["isMulticast"] = this.isMulticast;
        data["eventHandlerType"] = this.eventHandlerType ? this.eventHandlerType.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }

    clone(): EventInfo {
        const json = this.toJSON();
        let result = new EventInfo();
        result.init(json);
        return result;
    }
}

export interface IEventInfo {
    memberType: MemberTypes;
    attributes: EventAttributes;
    isSpecialName: boolean;
    addMethod: MethodInfo;
    removeMethod: MethodInfo;
    raiseMethod: MethodInfo;
    isMulticast: boolean;
    eventHandlerType: Type;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum FieldAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _32768 = 32768,
    _38144 = 38144,
}

export class RuntimeFieldHandle implements IRuntimeFieldHandle {
    value: IntPtr;

    constructor(data?: IRuntimeFieldHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeFieldHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeFieldHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RuntimeFieldHandle {
        const json = this.toJSON();
        let result = new RuntimeFieldHandle();
        result.init(json);
        return result;
    }
}

export interface IRuntimeFieldHandle {
    value: IntPtr;
}

export class FieldInfo implements IFieldInfo {
    memberType: MemberTypes;
    attributes: FieldAttributes;
    fieldType: Type;
    readonly isInitOnly: boolean;
    readonly isLiteral: boolean;
    readonly isNotSerialized: boolean;
    readonly isPinvokeImpl: boolean;
    readonly isSpecialName: boolean;
    readonly isStatic: boolean;
    readonly isAssembly: boolean;
    readonly isFamily: boolean;
    readonly isFamilyAndAssembly: boolean;
    readonly isFamilyOrAssembly: boolean;
    readonly isPrivate: boolean;
    readonly isPublic: boolean;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    fieldHandle: RuntimeFieldHandle;
    readonly name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            this.fieldType = _data["fieldType"] ? Type.fromJS(_data["fieldType"]) : <any>undefined;
            (<any>this).isInitOnly = _data["isInitOnly"];
            (<any>this).isLiteral = _data["isLiteral"];
            (<any>this).isNotSerialized = _data["isNotSerialized"];
            (<any>this).isPinvokeImpl = _data["isPinvokeImpl"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.fieldHandle = _data["fieldHandle"] ? RuntimeFieldHandle.fromJS(_data["fieldHandle"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): FieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["fieldType"] = this.fieldType ? this.fieldType.toJSON() : <any>undefined;
        data["isInitOnly"] = this.isInitOnly;
        data["isLiteral"] = this.isLiteral;
        data["isNotSerialized"] = this.isNotSerialized;
        data["isPinvokeImpl"] = this.isPinvokeImpl;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["fieldHandle"] = this.fieldHandle ? this.fieldHandle.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }

    clone(): FieldInfo {
        const json = this.toJSON();
        let result = new FieldInfo();
        result.init(json);
        return result;
    }
}

export interface IFieldInfo {
    memberType: MemberTypes;
    attributes: FieldAttributes;
    fieldType: Type;
    isInitOnly: boolean;
    isLiteral: boolean;
    isNotSerialized: boolean;
    isPinvokeImpl: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    fieldHandle: RuntimeFieldHandle;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum PropertyAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _62464 = 62464,
}

export class PropertyInfo implements IPropertyInfo {
    memberType: MemberTypes;
    propertyType: Type;
    attributes: PropertyAttributes;
    readonly isSpecialName: boolean;
    readonly canRead: boolean;
    readonly canWrite: boolean;
    getMethod: MethodInfo;
    setMethod: MethodInfo;
    readonly name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IPropertyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.propertyType = _data["propertyType"] ? Type.fromJS(_data["propertyType"]) : <any>undefined;
            this.attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).canRead = _data["canRead"];
            (<any>this).canWrite = _data["canWrite"];
            this.getMethod = _data["getMethod"] ? MethodInfo.fromJS(_data["getMethod"]) : <any>undefined;
            this.setMethod = _data["setMethod"] ? MethodInfo.fromJS(_data["setMethod"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): PropertyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["propertyType"] = this.propertyType ? this.propertyType.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["canRead"] = this.canRead;
        data["canWrite"] = this.canWrite;
        data["getMethod"] = this.getMethod ? this.getMethod.toJSON() : <any>undefined;
        data["setMethod"] = this.setMethod ? this.setMethod.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }

    clone(): PropertyInfo {
        const json = this.toJSON();
        let result = new PropertyInfo();
        result.init(json);
        return result;
    }
}

export interface IPropertyInfo {
    memberType: MemberTypes;
    propertyType: Type;
    attributes: PropertyAttributes;
    isSpecialName: boolean;
    canRead: boolean;
    canWrite: boolean;
    getMethod: MethodInfo;
    setMethod: MethodInfo;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export class MethodBase implements IMethodBase {
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    readonly isAbstract: boolean;
    readonly isConstructor: boolean;
    readonly isFinal: boolean;
    readonly isHideBySig: boolean;
    readonly isSpecialName: boolean;
    readonly isStatic: boolean;
    readonly isVirtual: boolean;
    readonly isAssembly: boolean;
    readonly isFamily: boolean;
    readonly isFamilyAndAssembly: boolean;
    readonly isFamilyOrAssembly: boolean;
    readonly isPrivate: boolean;
    readonly isPublic: boolean;
    readonly isConstructedGenericMethod: boolean;
    readonly isGenericMethod: boolean;
    readonly isGenericMethodDefinition: boolean;
    readonly containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    memberType: MemberTypes;
    readonly name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IMethodBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.memberType = _data["memberType"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MethodBase {
        data = typeof data === 'object' ? data : {};
        let result = new MethodBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["memberType"] = this.memberType;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }

    clone(): MethodBase {
        const json = this.toJSON();
        let result = new MethodBase();
        result.init(json);
        return result;
    }
}

export interface IMethodBase {
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    memberType: MemberTypes;
    name: string | undefined;
    declaringType: Type;
    reflectedType: Type;
    module: Module;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum GenericParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _28 = 28,
}

export enum TypeAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _24 = 24,
    _32 = 32,
    _128 = 128,
    _256 = 256,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _65536 = 65536,
    _131072 = 131072,
    _196608 = 196608,
    _262144 = 262144,
    _264192 = 264192,
    _1048576 = 1048576,
    _12582912 = 12582912,
}

export enum LayoutKind {
    _0 = 0,
    _2 = 2,
    _3 = 3,
}

export class StructLayoutAttribute implements IStructLayoutAttribute {
    value: LayoutKind;
    readonly typeId: any | undefined;

    constructor(data?: IStructLayoutAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            (<any>this).typeId = _data["typeId"];
        }
    }

    static fromJS(data: any): StructLayoutAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new StructLayoutAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["typeId"] = this.typeId;
        return data; 
    }

    clone(): StructLayoutAttribute {
        const json = this.toJSON();
        let result = new StructLayoutAttribute();
        result.init(json);
        return result;
    }
}

export interface IStructLayoutAttribute {
    value: LayoutKind;
    typeId: any | undefined;
}

export class RuntimeTypeHandle implements IRuntimeTypeHandle {
    value: IntPtr;

    constructor(data?: IRuntimeTypeHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeTypeHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeTypeHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RuntimeTypeHandle {
        const json = this.toJSON();
        let result = new RuntimeTypeHandle();
        result.init(json);
        return result;
    }
}

export interface IRuntimeTypeHandle {
    value: IntPtr;
}

export class TypeInfo implements ITypeInfo {
    readonly genericTypeParameters: Type[] | undefined;
    readonly declaredConstructors: ConstructorInfo[] | undefined;
    readonly declaredEvents: EventInfo[] | undefined;
    readonly declaredFields: FieldInfo[] | undefined;
    readonly declaredMembers: MemberInfo[] | undefined;
    readonly declaredMethods: MethodInfo[] | undefined;
    readonly declaredNestedTypes: TypeInfo[] | undefined;
    readonly declaredProperties: PropertyInfo[] | undefined;
    readonly implementedInterfaces: Type[] | undefined;
    readonly isInterface: boolean;
    memberType: MemberTypes;
    readonly namespace: string | undefined;
    readonly assemblyQualifiedName: string | undefined;
    readonly fullName: string | undefined;
    assembly: Assembly;
    module: Module;
    readonly isNested: boolean;
    declaringType: Type;
    declaringMethod: MethodBase;
    reflectedType: Type;
    underlyingSystemType: Type;
    readonly isTypeDefinition: boolean;
    readonly isArray: boolean;
    readonly isByRef: boolean;
    readonly isPointer: boolean;
    readonly isConstructedGenericType: boolean;
    readonly isGenericParameter: boolean;
    readonly isGenericTypeParameter: boolean;
    readonly isGenericMethodParameter: boolean;
    readonly isGenericType: boolean;
    readonly isGenericTypeDefinition: boolean;
    readonly isSZArray: boolean;
    readonly isVariableBoundArray: boolean;
    readonly isByRefLike: boolean;
    readonly hasElementType: boolean;
    readonly genericTypeArguments: Type[] | undefined;
    readonly genericParameterPosition: number;
    genericParameterAttributes: GenericParameterAttributes;
    attributes: TypeAttributes;
    readonly isAbstract: boolean;
    readonly isImport: boolean;
    readonly isSealed: boolean;
    readonly isSpecialName: boolean;
    readonly isClass: boolean;
    readonly isNestedAssembly: boolean;
    readonly isNestedFamANDAssem: boolean;
    readonly isNestedFamily: boolean;
    readonly isNestedFamORAssem: boolean;
    readonly isNestedPrivate: boolean;
    readonly isNestedPublic: boolean;
    readonly isNotPublic: boolean;
    readonly isPublic: boolean;
    readonly isAutoLayout: boolean;
    readonly isExplicitLayout: boolean;
    readonly isLayoutSequential: boolean;
    readonly isAnsiClass: boolean;
    readonly isAutoClass: boolean;
    readonly isUnicodeClass: boolean;
    readonly isCOMObject: boolean;
    readonly isContextful: boolean;
    readonly isEnum: boolean;
    readonly isMarshalByRef: boolean;
    readonly isPrimitive: boolean;
    readonly isValueType: boolean;
    readonly isSignatureType: boolean;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    structLayoutAttribute: StructLayoutAttribute;
    typeInitializer: ConstructorInfo;
    typeHandle: RuntimeTypeHandle;
    readonly guid: string;
    baseType: Type;
    readonly isSerializable: boolean;
    readonly containsGenericParameters: boolean;
    readonly isVisible: boolean;
    readonly name: string | undefined;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: ITypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["genericTypeParameters"])) {
                (<any>this).genericTypeParameters = [] as any;
                for (let item of _data["genericTypeParameters"])
                    (<any>this).genericTypeParameters.push(Type.fromJS(item));
            }
            if (Array.isArray(_data["declaredConstructors"])) {
                (<any>this).declaredConstructors = [] as any;
                for (let item of _data["declaredConstructors"])
                    (<any>this).declaredConstructors.push(ConstructorInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredEvents"])) {
                (<any>this).declaredEvents = [] as any;
                for (let item of _data["declaredEvents"])
                    (<any>this).declaredEvents.push(EventInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredFields"])) {
                (<any>this).declaredFields = [] as any;
                for (let item of _data["declaredFields"])
                    (<any>this).declaredFields.push(FieldInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredMembers"])) {
                (<any>this).declaredMembers = [] as any;
                for (let item of _data["declaredMembers"])
                    (<any>this).declaredMembers.push(MemberInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredMethods"])) {
                (<any>this).declaredMethods = [] as any;
                for (let item of _data["declaredMethods"])
                    (<any>this).declaredMethods.push(MethodInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredNestedTypes"])) {
                (<any>this).declaredNestedTypes = [] as any;
                for (let item of _data["declaredNestedTypes"])
                    (<any>this).declaredNestedTypes.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredProperties"])) {
                (<any>this).declaredProperties = [] as any;
                for (let item of _data["declaredProperties"])
                    (<any>this).declaredProperties.push(PropertyInfo.fromJS(item));
            }
            if (Array.isArray(_data["implementedInterfaces"])) {
                (<any>this).implementedInterfaces = [] as any;
                for (let item of _data["implementedInterfaces"])
                    (<any>this).implementedInterfaces.push(Type.fromJS(item));
            }
            (<any>this).isInterface = _data["isInterface"];
            this.memberType = _data["memberType"];
            (<any>this).namespace = _data["namespace"];
            (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
            (<any>this).fullName = _data["fullName"];
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            (<any>this).isNested = _data["isNested"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.declaringMethod = _data["declaringMethod"] ? MethodBase.fromJS(_data["declaringMethod"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["underlyingSystemType"] ? Type.fromJS(_data["underlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["isTypeDefinition"];
            (<any>this).isArray = _data["isArray"];
            (<any>this).isByRef = _data["isByRef"];
            (<any>this).isPointer = _data["isPointer"];
            (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
            (<any>this).isGenericParameter = _data["isGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
            (<any>this).isGenericType = _data["isGenericType"];
            (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
            (<any>this).isSZArray = _data["isSZArray"];
            (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
            (<any>this).isByRefLike = _data["isByRefLike"];
            (<any>this).hasElementType = _data["hasElementType"];
            if (Array.isArray(_data["genericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["genericTypeArguments"])
                    (<any>this).genericTypeArguments.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["genericParameterPosition"];
            this.genericParameterAttributes = _data["genericParameterAttributes"];
            this.attributes = _data["attributes"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isImport = _data["isImport"];
            (<any>this).isSealed = _data["isSealed"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isClass = _data["isClass"];
            (<any>this).isNestedAssembly = _data["isNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["isNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["isNestedPrivate"];
            (<any>this).isNestedPublic = _data["isNestedPublic"];
            (<any>this).isNotPublic = _data["isNotPublic"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isAutoLayout = _data["isAutoLayout"];
            (<any>this).isExplicitLayout = _data["isExplicitLayout"];
            (<any>this).isLayoutSequential = _data["isLayoutSequential"];
            (<any>this).isAnsiClass = _data["isAnsiClass"];
            (<any>this).isAutoClass = _data["isAutoClass"];
            (<any>this).isUnicodeClass = _data["isUnicodeClass"];
            (<any>this).isCOMObject = _data["isCOMObject"];
            (<any>this).isContextful = _data["isContextful"];
            (<any>this).isEnum = _data["isEnum"];
            (<any>this).isMarshalByRef = _data["isMarshalByRef"];
            (<any>this).isPrimitive = _data["isPrimitive"];
            (<any>this).isValueType = _data["isValueType"];
            (<any>this).isSignatureType = _data["isSignatureType"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.structLayoutAttribute = _data["structLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["typeInitializer"] ? ConstructorInfo.fromJS(_data["typeInitializer"]) : <any>undefined;
            this.typeHandle = _data["typeHandle"] ? RuntimeTypeHandle.fromJS(_data["typeHandle"]) : <any>undefined;
            (<any>this).guid = _data["guid"];
            this.baseType = _data["baseType"] ? Type.fromJS(_data["baseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["isSerializable"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).isVisible = _data["isVisible"];
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): TypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.genericTypeParameters)) {
            data["genericTypeParameters"] = [];
            for (let item of this.genericTypeParameters)
                data["genericTypeParameters"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredConstructors)) {
            data["declaredConstructors"] = [];
            for (let item of this.declaredConstructors)
                data["declaredConstructors"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredEvents)) {
            data["declaredEvents"] = [];
            for (let item of this.declaredEvents)
                data["declaredEvents"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredFields)) {
            data["declaredFields"] = [];
            for (let item of this.declaredFields)
                data["declaredFields"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMembers)) {
            data["declaredMembers"] = [];
            for (let item of this.declaredMembers)
                data["declaredMembers"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMethods)) {
            data["declaredMethods"] = [];
            for (let item of this.declaredMethods)
                data["declaredMethods"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredNestedTypes)) {
            data["declaredNestedTypes"] = [];
            for (let item of this.declaredNestedTypes)
                data["declaredNestedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredProperties)) {
            data["declaredProperties"] = [];
            for (let item of this.declaredProperties)
                data["declaredProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.implementedInterfaces)) {
            data["implementedInterfaces"] = [];
            for (let item of this.implementedInterfaces)
                data["implementedInterfaces"].push(item.toJSON());
        }
        data["isInterface"] = this.isInterface;
        data["memberType"] = this.memberType;
        data["namespace"] = this.namespace;
        data["assemblyQualifiedName"] = this.assemblyQualifiedName;
        data["fullName"] = this.fullName;
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["isNested"] = this.isNested;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["declaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["underlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["isTypeDefinition"] = this.isTypeDefinition;
        data["isArray"] = this.isArray;
        data["isByRef"] = this.isByRef;
        data["isPointer"] = this.isPointer;
        data["isConstructedGenericType"] = this.isConstructedGenericType;
        data["isGenericParameter"] = this.isGenericParameter;
        data["isGenericTypeParameter"] = this.isGenericTypeParameter;
        data["isGenericMethodParameter"] = this.isGenericMethodParameter;
        data["isGenericType"] = this.isGenericType;
        data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["isSZArray"] = this.isSZArray;
        data["isVariableBoundArray"] = this.isVariableBoundArray;
        data["isByRefLike"] = this.isByRefLike;
        data["hasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["genericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["genericTypeArguments"].push(item.toJSON());
        }
        data["genericParameterPosition"] = this.genericParameterPosition;
        data["genericParameterAttributes"] = this.genericParameterAttributes;
        data["attributes"] = this.attributes;
        data["isAbstract"] = this.isAbstract;
        data["isImport"] = this.isImport;
        data["isSealed"] = this.isSealed;
        data["isSpecialName"] = this.isSpecialName;
        data["isClass"] = this.isClass;
        data["isNestedAssembly"] = this.isNestedAssembly;
        data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["isNestedFamily"] = this.isNestedFamily;
        data["isNestedFamORAssem"] = this.isNestedFamORAssem;
        data["isNestedPrivate"] = this.isNestedPrivate;
        data["isNestedPublic"] = this.isNestedPublic;
        data["isNotPublic"] = this.isNotPublic;
        data["isPublic"] = this.isPublic;
        data["isAutoLayout"] = this.isAutoLayout;
        data["isExplicitLayout"] = this.isExplicitLayout;
        data["isLayoutSequential"] = this.isLayoutSequential;
        data["isAnsiClass"] = this.isAnsiClass;
        data["isAutoClass"] = this.isAutoClass;
        data["isUnicodeClass"] = this.isUnicodeClass;
        data["isCOMObject"] = this.isCOMObject;
        data["isContextful"] = this.isContextful;
        data["isEnum"] = this.isEnum;
        data["isMarshalByRef"] = this.isMarshalByRef;
        data["isPrimitive"] = this.isPrimitive;
        data["isValueType"] = this.isValueType;
        data["isSignatureType"] = this.isSignatureType;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["structLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["typeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["typeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["guid"] = this.guid;
        data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["isSerializable"] = this.isSerializable;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["isVisible"] = this.isVisible;
        data["name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }

    clone(): TypeInfo {
        const json = this.toJSON();
        let result = new TypeInfo();
        result.init(json);
        return result;
    }
}

export interface ITypeInfo {
    genericTypeParameters: Type[] | undefined;
    declaredConstructors: ConstructorInfo[] | undefined;
    declaredEvents: EventInfo[] | undefined;
    declaredFields: FieldInfo[] | undefined;
    declaredMembers: MemberInfo[] | undefined;
    declaredMethods: MethodInfo[] | undefined;
    declaredNestedTypes: TypeInfo[] | undefined;
    declaredProperties: PropertyInfo[] | undefined;
    implementedInterfaces: Type[] | undefined;
    isInterface: boolean;
    memberType: MemberTypes;
    namespace: string | undefined;
    assemblyQualifiedName: string | undefined;
    fullName: string | undefined;
    assembly: Assembly;
    module: Module;
    isNested: boolean;
    declaringType: Type;
    declaringMethod: MethodBase;
    reflectedType: Type;
    underlyingSystemType: Type;
    isTypeDefinition: boolean;
    isArray: boolean;
    isByRef: boolean;
    isPointer: boolean;
    isConstructedGenericType: boolean;
    isGenericParameter: boolean;
    isGenericTypeParameter: boolean;
    isGenericMethodParameter: boolean;
    isGenericType: boolean;
    isGenericTypeDefinition: boolean;
    isSZArray: boolean;
    isVariableBoundArray: boolean;
    isByRefLike: boolean;
    hasElementType: boolean;
    genericTypeArguments: Type[] | undefined;
    genericParameterPosition: number;
    genericParameterAttributes: GenericParameterAttributes;
    attributes: TypeAttributes;
    isAbstract: boolean;
    isImport: boolean;
    isSealed: boolean;
    isSpecialName: boolean;
    isClass: boolean;
    isNestedAssembly: boolean;
    isNestedFamANDAssem: boolean;
    isNestedFamily: boolean;
    isNestedFamORAssem: boolean;
    isNestedPrivate: boolean;
    isNestedPublic: boolean;
    isNotPublic: boolean;
    isPublic: boolean;
    isAutoLayout: boolean;
    isExplicitLayout: boolean;
    isLayoutSequential: boolean;
    isAnsiClass: boolean;
    isAutoClass: boolean;
    isUnicodeClass: boolean;
    isCOMObject: boolean;
    isContextful: boolean;
    isEnum: boolean;
    isMarshalByRef: boolean;
    isPrimitive: boolean;
    isValueType: boolean;
    isSignatureType: boolean;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    structLayoutAttribute: StructLayoutAttribute;
    typeInitializer: ConstructorInfo;
    typeHandle: RuntimeTypeHandle;
    guid: string;
    baseType: Type;
    isSerializable: boolean;
    containsGenericParameters: boolean;
    isVisible: boolean;
    name: string | undefined;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum SecurityRuleSet {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Assembly implements IAssembly {
    readonly definedTypes: TypeInfo[] | undefined;
    readonly exportedTypes: Type[] | undefined;
    readonly codeBase: string | undefined;
    entryPoint: MethodInfo;
    readonly fullName: string | undefined;
    readonly imageRuntimeVersion: string | undefined;
    readonly isDynamic: boolean;
    readonly location: string | undefined;
    readonly reflectionOnly: boolean;
    readonly isCollectible: boolean;
    readonly isFullyTrusted: boolean;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly escapedCodeBase: string | undefined;
    manifestModule: Module;
    readonly modules: Module[] | undefined;
    readonly globalAssemblyCache: boolean;
    readonly hostContext: number;
    securityRuleSet: SecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["definedTypes"])) {
                (<any>this).definedTypes = [] as any;
                for (let item of _data["definedTypes"])
                    (<any>this).definedTypes.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["exportedTypes"])) {
                (<any>this).exportedTypes = [] as any;
                for (let item of _data["exportedTypes"])
                    (<any>this).exportedTypes.push(Type.fromJS(item));
            }
            (<any>this).codeBase = _data["codeBase"];
            this.entryPoint = _data["entryPoint"] ? MethodInfo.fromJS(_data["entryPoint"]) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            (<any>this).imageRuntimeVersion = _data["imageRuntimeVersion"];
            (<any>this).isDynamic = _data["isDynamic"];
            (<any>this).location = _data["location"];
            (<any>this).reflectionOnly = _data["reflectionOnly"];
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).isFullyTrusted = _data["isFullyTrusted"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).escapedCodeBase = _data["escapedCodeBase"];
            this.manifestModule = _data["manifestModule"] ? Module.fromJS(_data["manifestModule"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                (<any>this).modules = [] as any;
                for (let item of _data["modules"])
                    (<any>this).modules.push(Module.fromJS(item));
            }
            (<any>this).globalAssemblyCache = _data["globalAssemblyCache"];
            (<any>this).hostContext = _data["hostContext"];
            this.securityRuleSet = _data["securityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        let result = new Assembly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["definedTypes"] = [];
            for (let item of this.definedTypes)
                data["definedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.exportedTypes)) {
            data["exportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["exportedTypes"].push(item.toJSON());
        }
        data["codeBase"] = this.codeBase;
        data["entryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["fullName"] = this.fullName;
        data["imageRuntimeVersion"] = this.imageRuntimeVersion;
        data["isDynamic"] = this.isDynamic;
        data["location"] = this.location;
        data["reflectionOnly"] = this.reflectionOnly;
        data["isCollectible"] = this.isCollectible;
        data["isFullyTrusted"] = this.isFullyTrusted;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["escapedCodeBase"] = this.escapedCodeBase;
        data["manifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["globalAssemblyCache"] = this.globalAssemblyCache;
        data["hostContext"] = this.hostContext;
        data["securityRuleSet"] = this.securityRuleSet;
        return data; 
    }

    clone(): Assembly {
        const json = this.toJSON();
        let result = new Assembly();
        result.init(json);
        return result;
    }
}

export interface IAssembly {
    definedTypes: TypeInfo[] | undefined;
    exportedTypes: Type[] | undefined;
    codeBase: string | undefined;
    entryPoint: MethodInfo;
    fullName: string | undefined;
    imageRuntimeVersion: string | undefined;
    isDynamic: boolean;
    location: string | undefined;
    reflectionOnly: boolean;
    isCollectible: boolean;
    isFullyTrusted: boolean;
    customAttributes: CustomAttributeData[] | undefined;
    escapedCodeBase: string | undefined;
    manifestModule: Module;
    modules: Module[] | undefined;
    globalAssemblyCache: boolean;
    hostContext: number;
    securityRuleSet: SecurityRuleSet;
}

export class Type implements IType {
    readonly isInterface: boolean;
    memberType: MemberTypes;
    readonly namespace: string | undefined;
    readonly assemblyQualifiedName: string | undefined;
    readonly fullName: string | undefined;
    assembly: Assembly;
    module: Module;
    readonly isNested: boolean;
    declaringType: Type;
    declaringMethod: MethodBase;
    reflectedType: Type;
    underlyingSystemType: Type;
    readonly isTypeDefinition: boolean;
    readonly isArray: boolean;
    readonly isByRef: boolean;
    readonly isPointer: boolean;
    readonly isConstructedGenericType: boolean;
    readonly isGenericParameter: boolean;
    readonly isGenericTypeParameter: boolean;
    readonly isGenericMethodParameter: boolean;
    readonly isGenericType: boolean;
    readonly isGenericTypeDefinition: boolean;
    readonly isSZArray: boolean;
    readonly isVariableBoundArray: boolean;
    readonly isByRefLike: boolean;
    readonly hasElementType: boolean;
    readonly genericTypeArguments: Type[] | undefined;
    readonly genericParameterPosition: number;
    genericParameterAttributes: GenericParameterAttributes;
    attributes: TypeAttributes;
    readonly isAbstract: boolean;
    readonly isImport: boolean;
    readonly isSealed: boolean;
    readonly isSpecialName: boolean;
    readonly isClass: boolean;
    readonly isNestedAssembly: boolean;
    readonly isNestedFamANDAssem: boolean;
    readonly isNestedFamily: boolean;
    readonly isNestedFamORAssem: boolean;
    readonly isNestedPrivate: boolean;
    readonly isNestedPublic: boolean;
    readonly isNotPublic: boolean;
    readonly isPublic: boolean;
    readonly isAutoLayout: boolean;
    readonly isExplicitLayout: boolean;
    readonly isLayoutSequential: boolean;
    readonly isAnsiClass: boolean;
    readonly isAutoClass: boolean;
    readonly isUnicodeClass: boolean;
    readonly isCOMObject: boolean;
    readonly isContextful: boolean;
    readonly isEnum: boolean;
    readonly isMarshalByRef: boolean;
    readonly isPrimitive: boolean;
    readonly isValueType: boolean;
    readonly isSignatureType: boolean;
    readonly isSecurityCritical: boolean;
    readonly isSecuritySafeCritical: boolean;
    readonly isSecurityTransparent: boolean;
    structLayoutAttribute: StructLayoutAttribute;
    typeInitializer: ConstructorInfo;
    typeHandle: RuntimeTypeHandle;
    readonly guid: string;
    baseType: Type;
    readonly isSerializable: boolean;
    readonly containsGenericParameters: boolean;
    readonly isVisible: boolean;
    readonly name: string | undefined;
    readonly customAttributes: CustomAttributeData[] | undefined;
    readonly isCollectible: boolean;
    readonly metadataToken: number;

    constructor(data?: IType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isInterface = _data["isInterface"];
            this.memberType = _data["memberType"];
            (<any>this).namespace = _data["namespace"];
            (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
            (<any>this).fullName = _data["fullName"];
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            (<any>this).isNested = _data["isNested"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.declaringMethod = _data["declaringMethod"] ? MethodBase.fromJS(_data["declaringMethod"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["underlyingSystemType"] ? Type.fromJS(_data["underlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["isTypeDefinition"];
            (<any>this).isArray = _data["isArray"];
            (<any>this).isByRef = _data["isByRef"];
            (<any>this).isPointer = _data["isPointer"];
            (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
            (<any>this).isGenericParameter = _data["isGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
            (<any>this).isGenericType = _data["isGenericType"];
            (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
            (<any>this).isSZArray = _data["isSZArray"];
            (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
            (<any>this).isByRefLike = _data["isByRefLike"];
            (<any>this).hasElementType = _data["hasElementType"];
            if (Array.isArray(_data["genericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["genericTypeArguments"])
                    (<any>this).genericTypeArguments.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["genericParameterPosition"];
            this.genericParameterAttributes = _data["genericParameterAttributes"];
            this.attributes = _data["attributes"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isImport = _data["isImport"];
            (<any>this).isSealed = _data["isSealed"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isClass = _data["isClass"];
            (<any>this).isNestedAssembly = _data["isNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["isNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["isNestedPrivate"];
            (<any>this).isNestedPublic = _data["isNestedPublic"];
            (<any>this).isNotPublic = _data["isNotPublic"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isAutoLayout = _data["isAutoLayout"];
            (<any>this).isExplicitLayout = _data["isExplicitLayout"];
            (<any>this).isLayoutSequential = _data["isLayoutSequential"];
            (<any>this).isAnsiClass = _data["isAnsiClass"];
            (<any>this).isAutoClass = _data["isAutoClass"];
            (<any>this).isUnicodeClass = _data["isUnicodeClass"];
            (<any>this).isCOMObject = _data["isCOMObject"];
            (<any>this).isContextful = _data["isContextful"];
            (<any>this).isEnum = _data["isEnum"];
            (<any>this).isMarshalByRef = _data["isMarshalByRef"];
            (<any>this).isPrimitive = _data["isPrimitive"];
            (<any>this).isValueType = _data["isValueType"];
            (<any>this).isSignatureType = _data["isSignatureType"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.structLayoutAttribute = _data["structLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["typeInitializer"] ? ConstructorInfo.fromJS(_data["typeInitializer"]) : <any>undefined;
            this.typeHandle = _data["typeHandle"] ? RuntimeTypeHandle.fromJS(_data["typeHandle"]) : <any>undefined;
            (<any>this).guid = _data["guid"];
            this.baseType = _data["baseType"] ? Type.fromJS(_data["baseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["isSerializable"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).isVisible = _data["isVisible"];
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): Type {
        data = typeof data === 'object' ? data : {};
        let result = new Type();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isInterface"] = this.isInterface;
        data["memberType"] = this.memberType;
        data["namespace"] = this.namespace;
        data["assemblyQualifiedName"] = this.assemblyQualifiedName;
        data["fullName"] = this.fullName;
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["isNested"] = this.isNested;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["declaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["underlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["isTypeDefinition"] = this.isTypeDefinition;
        data["isArray"] = this.isArray;
        data["isByRef"] = this.isByRef;
        data["isPointer"] = this.isPointer;
        data["isConstructedGenericType"] = this.isConstructedGenericType;
        data["isGenericParameter"] = this.isGenericParameter;
        data["isGenericTypeParameter"] = this.isGenericTypeParameter;
        data["isGenericMethodParameter"] = this.isGenericMethodParameter;
        data["isGenericType"] = this.isGenericType;
        data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["isSZArray"] = this.isSZArray;
        data["isVariableBoundArray"] = this.isVariableBoundArray;
        data["isByRefLike"] = this.isByRefLike;
        data["hasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["genericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["genericTypeArguments"].push(item.toJSON());
        }
        data["genericParameterPosition"] = this.genericParameterPosition;
        data["genericParameterAttributes"] = this.genericParameterAttributes;
        data["attributes"] = this.attributes;
        data["isAbstract"] = this.isAbstract;
        data["isImport"] = this.isImport;
        data["isSealed"] = this.isSealed;
        data["isSpecialName"] = this.isSpecialName;
        data["isClass"] = this.isClass;
        data["isNestedAssembly"] = this.isNestedAssembly;
        data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["isNestedFamily"] = this.isNestedFamily;
        data["isNestedFamORAssem"] = this.isNestedFamORAssem;
        data["isNestedPrivate"] = this.isNestedPrivate;
        data["isNestedPublic"] = this.isNestedPublic;
        data["isNotPublic"] = this.isNotPublic;
        data["isPublic"] = this.isPublic;
        data["isAutoLayout"] = this.isAutoLayout;
        data["isExplicitLayout"] = this.isExplicitLayout;
        data["isLayoutSequential"] = this.isLayoutSequential;
        data["isAnsiClass"] = this.isAnsiClass;
        data["isAutoClass"] = this.isAutoClass;
        data["isUnicodeClass"] = this.isUnicodeClass;
        data["isCOMObject"] = this.isCOMObject;
        data["isContextful"] = this.isContextful;
        data["isEnum"] = this.isEnum;
        data["isMarshalByRef"] = this.isMarshalByRef;
        data["isPrimitive"] = this.isPrimitive;
        data["isValueType"] = this.isValueType;
        data["isSignatureType"] = this.isSignatureType;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["structLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["typeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["typeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["guid"] = this.guid;
        data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["isSerializable"] = this.isSerializable;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["isVisible"] = this.isVisible;
        data["name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }

    clone(): Type {
        const json = this.toJSON();
        let result = new Type();
        result.init(json);
        return result;
    }
}

export interface IType {
    isInterface: boolean;
    memberType: MemberTypes;
    namespace: string | undefined;
    assemblyQualifiedName: string | undefined;
    fullName: string | undefined;
    assembly: Assembly;
    module: Module;
    isNested: boolean;
    declaringType: Type;
    declaringMethod: MethodBase;
    reflectedType: Type;
    underlyingSystemType: Type;
    isTypeDefinition: boolean;
    isArray: boolean;
    isByRef: boolean;
    isPointer: boolean;
    isConstructedGenericType: boolean;
    isGenericParameter: boolean;
    isGenericTypeParameter: boolean;
    isGenericMethodParameter: boolean;
    isGenericType: boolean;
    isGenericTypeDefinition: boolean;
    isSZArray: boolean;
    isVariableBoundArray: boolean;
    isByRefLike: boolean;
    hasElementType: boolean;
    genericTypeArguments: Type[] | undefined;
    genericParameterPosition: number;
    genericParameterAttributes: GenericParameterAttributes;
    attributes: TypeAttributes;
    isAbstract: boolean;
    isImport: boolean;
    isSealed: boolean;
    isSpecialName: boolean;
    isClass: boolean;
    isNestedAssembly: boolean;
    isNestedFamANDAssem: boolean;
    isNestedFamily: boolean;
    isNestedFamORAssem: boolean;
    isNestedPrivate: boolean;
    isNestedPublic: boolean;
    isNotPublic: boolean;
    isPublic: boolean;
    isAutoLayout: boolean;
    isExplicitLayout: boolean;
    isLayoutSequential: boolean;
    isAnsiClass: boolean;
    isAutoClass: boolean;
    isUnicodeClass: boolean;
    isCOMObject: boolean;
    isContextful: boolean;
    isEnum: boolean;
    isMarshalByRef: boolean;
    isPrimitive: boolean;
    isValueType: boolean;
    isSignatureType: boolean;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    structLayoutAttribute: StructLayoutAttribute;
    typeInitializer: ConstructorInfo;
    typeHandle: RuntimeTypeHandle;
    guid: string;
    baseType: Type;
    isSerializable: boolean;
    containsGenericParameters: boolean;
    isVisible: boolean;
    name: string | undefined;
    customAttributes: CustomAttributeData[] | undefined;
    isCollectible: boolean;
    metadataToken: number;
}

export enum DataSetDateTime {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum MappingType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class DataColumn implements IDataColumn {
    allowDBNull: boolean;
    autoIncrement: boolean;
    autoIncrementSeed: number;
    autoIncrementStep: number;
    caption: string | undefined;
    columnName: string | undefined;
    prefix: string | undefined;
    dataType: Type;
    dateTimeMode: DataSetDateTime;
    defaultValue: any | undefined;
    expression: string | undefined;
    readonly extendedProperties: { [key: string]: any; } | undefined;
    maxLength: number;
    namespace: string | undefined;
    readonly ordinal: number;
    readOnly: boolean;
    table: DataTable;
    unique: boolean;
    columnMapping: MappingType;
    site: ISite;
    container: IContainer;
    readonly designMode: boolean;

    constructor(data?: IDataColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.allowDBNull = true;
            this.autoIncrement = false;
            this.autoIncrementSeed = 0;
            this.autoIncrementStep = 1;
            this.columnName = "";
            this.prefix = "";
            this.expression = "";
            this.maxLength = -1;
            this.readOnly = false;
            this.unique = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowDBNull = _data["allowDBNull"] !== undefined ? _data["allowDBNull"] : true;
            this.autoIncrement = _data["autoIncrement"] !== undefined ? _data["autoIncrement"] : false;
            this.autoIncrementSeed = _data["autoIncrementSeed"] !== undefined ? _data["autoIncrementSeed"] : 0;
            this.autoIncrementStep = _data["autoIncrementStep"] !== undefined ? _data["autoIncrementStep"] : 1;
            this.caption = _data["caption"];
            this.columnName = _data["columnName"] !== undefined ? _data["columnName"] : "";
            this.prefix = _data["prefix"] !== undefined ? _data["prefix"] : "";
            this.dataType = _data["dataType"] ? Type.fromJS(_data["dataType"]) : <any>undefined;
            this.dateTimeMode = _data["dateTimeMode"];
            this.defaultValue = _data["defaultValue"];
            this.expression = _data["expression"] !== undefined ? _data["expression"] : "";
            if (_data["extendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["extendedProperties"]) {
                    if (_data["extendedProperties"].hasOwnProperty(key))
                        (<any>this).extendedProperties[key] = _data["extendedProperties"][key];
                }
            }
            this.maxLength = _data["maxLength"] !== undefined ? _data["maxLength"] : -1;
            this.namespace = _data["namespace"];
            (<any>this).ordinal = _data["ordinal"];
            this.readOnly = _data["readOnly"] !== undefined ? _data["readOnly"] : false;
            this.table = _data["table"] ? DataTable.fromJS(_data["table"]) : <any>undefined;
            this.unique = _data["unique"] !== undefined ? _data["unique"] : false;
            this.columnMapping = _data["columnMapping"];
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
            this.container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
        }
    }

    static fromJS(data: any): DataColumn {
        data = typeof data === 'object' ? data : {};
        let result = new DataColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowDBNull"] = this.allowDBNull;
        data["autoIncrement"] = this.autoIncrement;
        data["autoIncrementSeed"] = this.autoIncrementSeed;
        data["autoIncrementStep"] = this.autoIncrementStep;
        data["caption"] = this.caption;
        data["columnName"] = this.columnName;
        data["prefix"] = this.prefix;
        data["dataType"] = this.dataType ? this.dataType.toJSON() : <any>undefined;
        data["dateTimeMode"] = this.dateTimeMode;
        data["defaultValue"] = this.defaultValue;
        data["expression"] = this.expression;
        if (this.extendedProperties) {
            data["extendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    data["extendedProperties"][key] = this.extendedProperties[key];
            }
        }
        data["maxLength"] = this.maxLength;
        data["namespace"] = this.namespace;
        data["ordinal"] = this.ordinal;
        data["readOnly"] = this.readOnly;
        data["table"] = this.table ? this.table.toJSON() : <any>undefined;
        data["unique"] = this.unique;
        data["columnMapping"] = this.columnMapping;
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        return data; 
    }

    clone(): DataColumn {
        const json = this.toJSON();
        let result = new DataColumn();
        result.init(json);
        return result;
    }
}

export interface IDataColumn {
    allowDBNull: boolean;
    autoIncrement: boolean;
    autoIncrementSeed: number;
    autoIncrementStep: number;
    caption: string | undefined;
    columnName: string | undefined;
    prefix: string | undefined;
    dataType: Type;
    dateTimeMode: DataSetDateTime;
    defaultValue: any | undefined;
    expression: string | undefined;
    extendedProperties: { [key: string]: any; } | undefined;
    maxLength: number;
    namespace: string | undefined;
    ordinal: number;
    readOnly: boolean;
    table: DataTable;
    unique: boolean;
    columnMapping: MappingType;
    site: ISite;
    container: IContainer;
    designMode: boolean;
}

export class DataTable implements IDataTable {
    caseSensitive: boolean;
    readonly isInitialized: boolean;
    remotingFormat: SerializationFormat;
    readonly childRelations: any[] | undefined;
    readonly columns: any[] | undefined;
    readonly constraints: any[] | undefined;
    dataSet: DataSet;
    readonly defaultView: any[] | undefined;
    displayExpression: string | undefined;
    readonly extendedProperties: { [key: string]: any; } | undefined;
    readonly hasErrors: boolean;
    locale: CultureInfo;
    minimumCapacity: number;
    readonly parentRelations: any[] | undefined;
    primaryKey: DataColumn[] | undefined;
    readonly rows: any[] | undefined;
    tableName: string | undefined;
    namespace: string | undefined;
    prefix: string | undefined;
    site: ISite;
    container: IContainer;
    readonly designMode: boolean;

    constructor(data?: IDataTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.displayExpression = "";
            this.minimumCapacity = 50;
            this.tableName = "";
            this.prefix = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseSensitive = _data["caseSensitive"];
            (<any>this).isInitialized = _data["isInitialized"];
            this.remotingFormat = _data["remotingFormat"];
            if (Array.isArray(_data["childRelations"])) {
                (<any>this).childRelations = [] as any;
                for (let item of _data["childRelations"])
                    (<any>this).childRelations.push(item);
            }
            if (Array.isArray(_data["columns"])) {
                (<any>this).columns = [] as any;
                for (let item of _data["columns"])
                    (<any>this).columns.push(item);
            }
            if (Array.isArray(_data["constraints"])) {
                (<any>this).constraints = [] as any;
                for (let item of _data["constraints"])
                    (<any>this).constraints.push(item);
            }
            this.dataSet = _data["dataSet"] ? DataSet.fromJS(_data["dataSet"]) : <any>undefined;
            if (Array.isArray(_data["defaultView"])) {
                (<any>this).defaultView = [] as any;
                for (let item of _data["defaultView"])
                    (<any>this).defaultView.push(item);
            }
            this.displayExpression = _data["displayExpression"] !== undefined ? _data["displayExpression"] : "";
            if (_data["extendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["extendedProperties"]) {
                    if (_data["extendedProperties"].hasOwnProperty(key))
                        (<any>this).extendedProperties[key] = _data["extendedProperties"][key];
                }
            }
            (<any>this).hasErrors = _data["hasErrors"];
            this.locale = _data["locale"] ? CultureInfo.fromJS(_data["locale"]) : <any>undefined;
            this.minimumCapacity = _data["minimumCapacity"] !== undefined ? _data["minimumCapacity"] : 50;
            if (Array.isArray(_data["parentRelations"])) {
                (<any>this).parentRelations = [] as any;
                for (let item of _data["parentRelations"])
                    (<any>this).parentRelations.push(item);
            }
            if (Array.isArray(_data["primaryKey"])) {
                this.primaryKey = [] as any;
                for (let item of _data["primaryKey"])
                    this.primaryKey.push(DataColumn.fromJS(item));
            }
            if (Array.isArray(_data["rows"])) {
                (<any>this).rows = [] as any;
                for (let item of _data["rows"])
                    (<any>this).rows.push(item);
            }
            this.tableName = _data["tableName"] !== undefined ? _data["tableName"] : "";
            this.namespace = _data["namespace"];
            this.prefix = _data["prefix"] !== undefined ? _data["prefix"] : "";
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
            this.container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
        }
    }

    static fromJS(data: any): DataTable {
        data = typeof data === 'object' ? data : {};
        let result = new DataTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseSensitive"] = this.caseSensitive;
        data["isInitialized"] = this.isInitialized;
        data["remotingFormat"] = this.remotingFormat;
        if (Array.isArray(this.childRelations)) {
            data["childRelations"] = [];
            for (let item of this.childRelations)
                data["childRelations"].push(item);
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        if (Array.isArray(this.constraints)) {
            data["constraints"] = [];
            for (let item of this.constraints)
                data["constraints"].push(item);
        }
        data["dataSet"] = this.dataSet ? this.dataSet.toJSON() : <any>undefined;
        if (Array.isArray(this.defaultView)) {
            data["defaultView"] = [];
            for (let item of this.defaultView)
                data["defaultView"].push(item);
        }
        data["displayExpression"] = this.displayExpression;
        if (this.extendedProperties) {
            data["extendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    data["extendedProperties"][key] = this.extendedProperties[key];
            }
        }
        data["hasErrors"] = this.hasErrors;
        data["locale"] = this.locale ? this.locale.toJSON() : <any>undefined;
        data["minimumCapacity"] = this.minimumCapacity;
        if (Array.isArray(this.parentRelations)) {
            data["parentRelations"] = [];
            for (let item of this.parentRelations)
                data["parentRelations"].push(item);
        }
        if (Array.isArray(this.primaryKey)) {
            data["primaryKey"] = [];
            for (let item of this.primaryKey)
                data["primaryKey"].push(item.toJSON());
        }
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item);
        }
        data["tableName"] = this.tableName;
        data["namespace"] = this.namespace;
        data["prefix"] = this.prefix;
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        return data; 
    }

    clone(): DataTable {
        const json = this.toJSON();
        let result = new DataTable();
        result.init(json);
        return result;
    }
}

export interface IDataTable {
    caseSensitive: boolean;
    isInitialized: boolean;
    remotingFormat: SerializationFormat;
    childRelations: any[] | undefined;
    columns: any[] | undefined;
    constraints: any[] | undefined;
    dataSet: DataSet;
    defaultView: any[] | undefined;
    displayExpression: string | undefined;
    extendedProperties: { [key: string]: any; } | undefined;
    hasErrors: boolean;
    locale: CultureInfo;
    minimumCapacity: number;
    parentRelations: any[] | undefined;
    primaryKey: DataColumn[] | undefined;
    rows: any[] | undefined;
    tableName: string | undefined;
    namespace: string | undefined;
    prefix: string | undefined;
    site: ISite;
    container: IContainer;
    designMode: boolean;
}

export class FormSubsectionDtoPagedResultDto implements IFormSubsectionDtoPagedResultDto {
    totalCount: number;
    items: FormSubsectionDto[] | undefined;

    constructor(data?: IFormSubsectionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FormSubsectionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormSubsectionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormSubsectionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FormSubsectionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FormSubsectionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFormSubsectionDtoPagedResultDto {
    totalCount: number;
    items: FormSubsectionDto[] | undefined;
}

export class GetPivotTableInput implements IGetPivotTableInput {
    formId: number;
    formStructureRowId: number;

    constructor(data?: IGetPivotTableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.formStructureRowId = _data["formStructureRowId"];
        }
    }

    static fromJS(data: any): GetPivotTableInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPivotTableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["formStructureRowId"] = this.formStructureRowId;
        return data; 
    }

    clone(): GetPivotTableInput {
        const json = this.toJSON();
        let result = new GetPivotTableInput();
        result.init(json);
        return result;
    }
}

export interface IGetPivotTableInput {
    formId: number;
    formStructureRowId: number;
}

export class CubeMemberSchema implements ICubeMemberSchema {
    name: string | undefined;
    labelText: string | undefined;
    mainText: string | undefined;

    constructor(data?: ICubeMemberSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.labelText = _data["labelText"];
            this.mainText = _data["mainText"];
        }
    }

    static fromJS(data: any): CubeMemberSchema {
        data = typeof data === 'object' ? data : {};
        let result = new CubeMemberSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["labelText"] = this.labelText;
        data["mainText"] = this.mainText;
        return data; 
    }

    clone(): CubeMemberSchema {
        const json = this.toJSON();
        let result = new CubeMemberSchema();
        result.init(json);
        return result;
    }
}

export interface ICubeMemberSchema {
    name: string | undefined;
    labelText: string | undefined;
    mainText: string | undefined;
}

export class CubeSchema implements ICubeSchema {
    currentQueryId: number;
    id: string | undefined;
    name: string | undefined;
    mdxQuery: string | undefined;
    mdxQueryFilter: string | undefined;
    dimensions: CubeMemberSchema[] | undefined;
    measures: CubeMemberSchema[] | undefined;
    selectedRows: CubeMemberSchema[] | undefined;
    selectedColumns: CubeMemberSchema[] | undefined;
    selectedMeasures: CubeMemberSchema[] | undefined;

    constructor(data?: ICubeSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentQueryId = _data["currentQueryId"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.mdxQuery = _data["mdxQuery"];
            this.mdxQueryFilter = _data["mdxQueryFilter"];
            if (Array.isArray(_data["dimensions"])) {
                this.dimensions = [] as any;
                for (let item of _data["dimensions"])
                    this.dimensions.push(CubeMemberSchema.fromJS(item));
            }
            if (Array.isArray(_data["measures"])) {
                this.measures = [] as any;
                for (let item of _data["measures"])
                    this.measures.push(CubeMemberSchema.fromJS(item));
            }
            if (Array.isArray(_data["selectedRows"])) {
                this.selectedRows = [] as any;
                for (let item of _data["selectedRows"])
                    this.selectedRows.push(CubeMemberSchema.fromJS(item));
            }
            if (Array.isArray(_data["selectedColumns"])) {
                this.selectedColumns = [] as any;
                for (let item of _data["selectedColumns"])
                    this.selectedColumns.push(CubeMemberSchema.fromJS(item));
            }
            if (Array.isArray(_data["selectedMeasures"])) {
                this.selectedMeasures = [] as any;
                for (let item of _data["selectedMeasures"])
                    this.selectedMeasures.push(CubeMemberSchema.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CubeSchema {
        data = typeof data === 'object' ? data : {};
        let result = new CubeSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentQueryId"] = this.currentQueryId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["mdxQuery"] = this.mdxQuery;
        data["mdxQueryFilter"] = this.mdxQueryFilter;
        if (Array.isArray(this.dimensions)) {
            data["dimensions"] = [];
            for (let item of this.dimensions)
                data["dimensions"].push(item.toJSON());
        }
        if (Array.isArray(this.measures)) {
            data["measures"] = [];
            for (let item of this.measures)
                data["measures"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedRows)) {
            data["selectedRows"] = [];
            for (let item of this.selectedRows)
                data["selectedRows"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedColumns)) {
            data["selectedColumns"] = [];
            for (let item of this.selectedColumns)
                data["selectedColumns"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedMeasures)) {
            data["selectedMeasures"] = [];
            for (let item of this.selectedMeasures)
                data["selectedMeasures"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CubeSchema {
        const json = this.toJSON();
        let result = new CubeSchema();
        result.init(json);
        return result;
    }
}

export interface ICubeSchema {
    currentQueryId: number;
    id: string | undefined;
    name: string | undefined;
    mdxQuery: string | undefined;
    mdxQueryFilter: string | undefined;
    dimensions: CubeMemberSchema[] | undefined;
    measures: CubeMemberSchema[] | undefined;
    selectedRows: CubeMemberSchema[] | undefined;
    selectedColumns: CubeMemberSchema[] | undefined;
    selectedMeasures: CubeMemberSchema[] | undefined;
}

export class Dimension implements IDimension {
    name: string | undefined;

    constructor(data?: IDimension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Dimension {
        data = typeof data === 'object' ? data : {};
        let result = new Dimension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): Dimension {
        const json = this.toJSON();
        let result = new Dimension();
        result.init(json);
        return result;
    }
}

export interface IDimension {
    name: string | undefined;
}

export enum PivotTableTotalsPosition {
    _0 = 0,
    _1 = 1,
}

export enum TableAxis {
    _0 = 0,
    _1 = 1,
}

export enum ListSortDirection {
    _0 = 0,
    _1 = 1,
}

export class AxisKeysOrder implements IAxisKeysOrder {
    axis: TableAxis;
    index: number;
    direction: ListSortDirection;

    constructor(data?: IAxisKeysOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.axis = _data["axis"];
            this.index = _data["index"];
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): AxisKeysOrder {
        data = typeof data === 'object' ? data : {};
        let result = new AxisKeysOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["axis"] = this.axis;
        data["index"] = this.index;
        data["direction"] = this.direction;
        return data; 
    }

    clone(): AxisKeysOrder {
        const json = this.toJSON();
        let result = new AxisKeysOrder();
        result.init(json);
        return result;
    }
}

export interface IAxisKeysOrder {
    axis: TableAxis;
    index: number;
    direction: ListSortDirection;
}

export class AxisValuesOrder implements IAxisValuesOrder {
    axis: TableAxis;
    index: number | undefined;
    direction: ListSortDirection;
    measure: number | undefined;

    constructor(data?: IAxisValuesOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.axis = _data["axis"];
            this.index = _data["index"];
            this.direction = _data["direction"];
            this.measure = _data["measure"];
        }
    }

    static fromJS(data: any): AxisValuesOrder {
        data = typeof data === 'object' ? data : {};
        let result = new AxisValuesOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["axis"] = this.axis;
        data["index"] = this.index;
        data["direction"] = this.direction;
        data["measure"] = this.measure;
        return data; 
    }

    clone(): AxisValuesOrder {
        const json = this.toJSON();
        let result = new AxisValuesOrder();
        result.init(json);
        return result;
    }
}

export interface IAxisValuesOrder {
    axis: TableAxis;
    index: number | undefined;
    direction: ListSortDirection;
    measure: number | undefined;
}

export class OrderOptions implements IOrderOptions {
    dimensions: AxisKeysOrder[] | undefined;
    values: AxisValuesOrder;
    preserveGroupOrder: boolean;

    constructor(data?: IOrderOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dimensions"])) {
                this.dimensions = [] as any;
                for (let item of _data["dimensions"])
                    this.dimensions.push(AxisKeysOrder.fromJS(item));
            }
            this.values = _data["values"] ? AxisValuesOrder.fromJS(_data["values"]) : <any>undefined;
            this.preserveGroupOrder = _data["preserveGroupOrder"];
        }
    }

    static fromJS(data: any): OrderOptions {
        data = typeof data === 'object' ? data : {};
        let result = new OrderOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dimensions)) {
            data["dimensions"] = [];
            for (let item of this.dimensions)
                data["dimensions"].push(item.toJSON());
        }
        data["values"] = this.values ? this.values.toJSON() : <any>undefined;
        data["preserveGroupOrder"] = this.preserveGroupOrder;
        return data; 
    }

    clone(): OrderOptions {
        const json = this.toJSON();
        let result = new OrderOptions();
        result.init(json);
        return result;
    }
}

export interface IOrderOptions {
    dimensions: AxisKeysOrder[] | undefined;
    values: AxisValuesOrder;
    preserveGroupOrder: boolean;
}

export class Page implements IPage {
    offset: number;
    limit: number;

    constructor(data?: IPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["offset"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): Page {
        data = typeof data === 'object' ? data : {};
        let result = new Page();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offset"] = this.offset;
        data["limit"] = this.limit;
        return data; 
    }

    clone(): Page {
        const json = this.toJSON();
        let result = new Page();
        result.init(json);
        return result;
    }
}

export interface IPage {
    offset: number;
    limit: number;
}

export class ExpandCollapseOptions implements IExpandCollapseOptions {
    enabled: boolean;
    expandedRows: number[][] | undefined;
    expandedColumns: number[][] | undefined;

    constructor(data?: IExpandCollapseOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["expandedRows"])) {
                this.expandedRows = [] as any;
                for (let item of _data["expandedRows"])
                    this.expandedRows.push(item);
            }
            if (Array.isArray(_data["expandedColumns"])) {
                this.expandedColumns = [] as any;
                for (let item of _data["expandedColumns"])
                    this.expandedColumns.push(item);
            }
        }
    }

    static fromJS(data: any): ExpandCollapseOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandCollapseOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        if (Array.isArray(this.expandedRows)) {
            data["expandedRows"] = [];
            for (let item of this.expandedRows)
                data["expandedRows"].push(item);
        }
        if (Array.isArray(this.expandedColumns)) {
            data["expandedColumns"] = [];
            for (let item of this.expandedColumns)
                data["expandedColumns"].push(item);
        }
        return data; 
    }

    clone(): ExpandCollapseOptions {
        const json = this.toJSON();
        let result = new ExpandCollapseOptions();
        result.init(json);
        return result;
    }
}

export interface IExpandCollapseOptions {
    enabled: boolean;
    expandedRows: number[][] | undefined;
    expandedColumns: number[][] | undefined;
}

export class PivotTableReportConfig implements IPivotTableReportConfig {
    cubeName: string | undefined;
    rows: Dimension[] | undefined;
    columns: Dimension[] | undefined;
    measures: Measure[] | undefined;
    subtotalColumns: boolean;
    subtotalRows: boolean;
    grandTotal: boolean;
    totalsRow: boolean;
    totalsRowPosition: PivotTableTotalsPosition;
    totalsColumn: boolean;
    totalsColumnPosition: PivotTableTotalsPosition;
    limitRows: number | undefined;
    limitColumns: number | undefined;
    orderBy: OrderOptions;
    filter: string | undefined;
    columnPage: Page;
    rowPage: Page;
    expandCollapse: ExpandCollapseOptions;

    constructor(data?: IPivotTableReportConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cubeName = _data["cubeName"];
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows.push(Dimension.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(Dimension.fromJS(item));
            }
            if (Array.isArray(_data["measures"])) {
                this.measures = [] as any;
                for (let item of _data["measures"])
                    this.measures.push(Measure.fromJS(item));
            }
            this.subtotalColumns = _data["subtotalColumns"];
            this.subtotalRows = _data["subtotalRows"];
            this.grandTotal = _data["grandTotal"];
            this.totalsRow = _data["totalsRow"];
            this.totalsRowPosition = _data["totalsRowPosition"];
            this.totalsColumn = _data["totalsColumn"];
            this.totalsColumnPosition = _data["totalsColumnPosition"];
            this.limitRows = _data["limitRows"];
            this.limitColumns = _data["limitColumns"];
            this.orderBy = _data["orderBy"] ? OrderOptions.fromJS(_data["orderBy"]) : <any>undefined;
            this.filter = _data["filter"];
            this.columnPage = _data["columnPage"] ? Page.fromJS(_data["columnPage"]) : <any>undefined;
            this.rowPage = _data["rowPage"] ? Page.fromJS(_data["rowPage"]) : <any>undefined;
            this.expandCollapse = _data["expandCollapse"] ? ExpandCollapseOptions.fromJS(_data["expandCollapse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PivotTableReportConfig {
        data = typeof data === 'object' ? data : {};
        let result = new PivotTableReportConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cubeName"] = this.cubeName;
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.measures)) {
            data["measures"] = [];
            for (let item of this.measures)
                data["measures"].push(item.toJSON());
        }
        data["subtotalColumns"] = this.subtotalColumns;
        data["subtotalRows"] = this.subtotalRows;
        data["grandTotal"] = this.grandTotal;
        data["totalsRow"] = this.totalsRow;
        data["totalsRowPosition"] = this.totalsRowPosition;
        data["totalsColumn"] = this.totalsColumn;
        data["totalsColumnPosition"] = this.totalsColumnPosition;
        data["limitRows"] = this.limitRows;
        data["limitColumns"] = this.limitColumns;
        data["orderBy"] = this.orderBy ? this.orderBy.toJSON() : <any>undefined;
        data["filter"] = this.filter;
        data["columnPage"] = this.columnPage ? this.columnPage.toJSON() : <any>undefined;
        data["rowPage"] = this.rowPage ? this.rowPage.toJSON() : <any>undefined;
        data["expandCollapse"] = this.expandCollapse ? this.expandCollapse.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PivotTableReportConfig {
        const json = this.toJSON();
        let result = new PivotTableReportConfig();
        result.init(json);
        return result;
    }
}

export interface IPivotTableReportConfig {
    cubeName: string | undefined;
    rows: Dimension[] | undefined;
    columns: Dimension[] | undefined;
    measures: Measure[] | undefined;
    subtotalColumns: boolean;
    subtotalRows: boolean;
    grandTotal: boolean;
    totalsRow: boolean;
    totalsRowPosition: PivotTableTotalsPosition;
    totalsColumn: boolean;
    totalsColumnPosition: PivotTableTotalsPosition;
    limitRows: number | undefined;
    limitColumns: number | undefined;
    orderBy: OrderOptions;
    filter: string | undefined;
    columnPage: Page;
    rowPage: Page;
    expandCollapse: ExpandCollapseOptions;
}

export class PivotTableConfiguration implements IPivotTableConfiguration {
    rows: string[] | undefined;
    columns: string[] | undefined;
    measures: number[] | undefined;
    orderKeys: AxisKeysOrder[] | undefined;
    sortByValue: AxisValuesOrder;
    preserveGroupOrder: boolean;
    sortGroupsBySubtotals: boolean;

    constructor(data?: IPivotTableConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows.push(item);
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns.push(item);
            }
            if (Array.isArray(_data["measures"])) {
                this.measures = [] as any;
                for (let item of _data["measures"])
                    this.measures.push(item);
            }
            if (Array.isArray(_data["orderKeys"])) {
                this.orderKeys = [] as any;
                for (let item of _data["orderKeys"])
                    this.orderKeys.push(AxisKeysOrder.fromJS(item));
            }
            this.sortByValue = _data["sortByValue"] ? AxisValuesOrder.fromJS(_data["sortByValue"]) : <any>undefined;
            this.preserveGroupOrder = _data["preserveGroupOrder"];
            this.sortGroupsBySubtotals = _data["sortGroupsBySubtotals"];
        }
    }

    static fromJS(data: any): PivotTableConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new PivotTableConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item);
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        if (Array.isArray(this.measures)) {
            data["measures"] = [];
            for (let item of this.measures)
                data["measures"].push(item);
        }
        if (Array.isArray(this.orderKeys)) {
            data["orderKeys"] = [];
            for (let item of this.orderKeys)
                data["orderKeys"].push(item.toJSON());
        }
        data["sortByValue"] = this.sortByValue ? this.sortByValue.toJSON() : <any>undefined;
        data["preserveGroupOrder"] = this.preserveGroupOrder;
        data["sortGroupsBySubtotals"] = this.sortGroupsBySubtotals;
        return data; 
    }

    clone(): PivotTableConfiguration {
        const json = this.toJSON();
        let result = new PivotTableConfiguration();
        result.init(json);
        return result;
    }
}

export interface IPivotTableConfiguration {
    rows: string[] | undefined;
    columns: string[] | undefined;
    measures: number[] | undefined;
    orderKeys: AxisKeysOrder[] | undefined;
    sortByValue: AxisValuesOrder;
    preserveGroupOrder: boolean;
    sortGroupsBySubtotals: boolean;
}

export class PivotTableBuilder implements IPivotTableBuilder {
    htmlContent: string | undefined;
    jsonData: string | undefined;
    mdxQuery: string | undefined;
    configuration: PivotTableConfiguration;
    dimensionsHierarchy: { [key: string]: string[]; } | undefined;

    constructor(data?: IPivotTableBuilder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.htmlContent = _data["htmlContent"];
            this.jsonData = _data["jsonData"];
            this.mdxQuery = _data["mdxQuery"];
            this.configuration = _data["configuration"] ? PivotTableConfiguration.fromJS(_data["configuration"]) : <any>undefined;
            if (_data["dimensionsHierarchy"]) {
                this.dimensionsHierarchy = {} as any;
                for (let key in _data["dimensionsHierarchy"]) {
                    if (_data["dimensionsHierarchy"].hasOwnProperty(key))
                        this.dimensionsHierarchy[key] = _data["dimensionsHierarchy"][key] !== undefined ? _data["dimensionsHierarchy"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): PivotTableBuilder {
        data = typeof data === 'object' ? data : {};
        let result = new PivotTableBuilder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["htmlContent"] = this.htmlContent;
        data["jsonData"] = this.jsonData;
        data["mdxQuery"] = this.mdxQuery;
        data["configuration"] = this.configuration ? this.configuration.toJSON() : <any>undefined;
        if (this.dimensionsHierarchy) {
            data["dimensionsHierarchy"] = {};
            for (let key in this.dimensionsHierarchy) {
                if (this.dimensionsHierarchy.hasOwnProperty(key))
                    data["dimensionsHierarchy"][key] = this.dimensionsHierarchy[key];
            }
        }
        return data; 
    }

    clone(): PivotTableBuilder {
        const json = this.toJSON();
        let result = new PivotTableBuilder();
        result.init(json);
        return result;
    }
}

export interface IPivotTableBuilder {
    htmlContent: string | undefined;
    jsonData: string | undefined;
    mdxQuery: string | undefined;
    configuration: PivotTableConfiguration;
    dimensionsHierarchy: { [key: string]: string[]; } | undefined;
}

export class MdxQueryWithParamsDto implements IMdxQueryWithParamsDto {
    mdxQuery: string | undefined;
    mdxQueryFilter: string | undefined;

    constructor(data?: IMdxQueryWithParamsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mdxQuery = _data["mdxQuery"];
            this.mdxQueryFilter = _data["mdxQueryFilter"];
        }
    }

    static fromJS(data: any): MdxQueryWithParamsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MdxQueryWithParamsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mdxQuery"] = this.mdxQuery;
        data["mdxQueryFilter"] = this.mdxQueryFilter;
        return data; 
    }

    clone(): MdxQueryWithParamsDto {
        const json = this.toJSON();
        let result = new MdxQueryWithParamsDto();
        result.init(json);
        return result;
    }
}

export interface IMdxQueryWithParamsDto {
    mdxQuery: string | undefined;
    mdxQueryFilter: string | undefined;
}

export class CreateOrUpdatePivotQueryDto implements ICreateOrUpdatePivotQueryDto {
    formId: number;
    currentQueryId: number;
    formStructureRowId: number;
    mdxQueryWithParams: MdxQueryWithParamsDto;
    pivotConfig: PivotConfiguration;
    dimensionsHierarchy: { [key: string]: string[]; } | undefined;

    constructor(data?: ICreateOrUpdatePivotQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.currentQueryId = _data["currentQueryId"];
            this.formStructureRowId = _data["formStructureRowId"];
            this.mdxQueryWithParams = _data["mdxQueryWithParams"] ? MdxQueryWithParamsDto.fromJS(_data["mdxQueryWithParams"]) : <any>undefined;
            this.pivotConfig = _data["pivotConfig"] ? PivotConfiguration.fromJS(_data["pivotConfig"]) : <any>undefined;
            if (_data["dimensionsHierarchy"]) {
                this.dimensionsHierarchy = {} as any;
                for (let key in _data["dimensionsHierarchy"]) {
                    if (_data["dimensionsHierarchy"].hasOwnProperty(key))
                        this.dimensionsHierarchy[key] = _data["dimensionsHierarchy"][key] !== undefined ? _data["dimensionsHierarchy"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): CreateOrUpdatePivotQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePivotQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["currentQueryId"] = this.currentQueryId;
        data["formStructureRowId"] = this.formStructureRowId;
        data["mdxQueryWithParams"] = this.mdxQueryWithParams ? this.mdxQueryWithParams.toJSON() : <any>undefined;
        data["pivotConfig"] = this.pivotConfig ? this.pivotConfig.toJSON() : <any>undefined;
        if (this.dimensionsHierarchy) {
            data["dimensionsHierarchy"] = {};
            for (let key in this.dimensionsHierarchy) {
                if (this.dimensionsHierarchy.hasOwnProperty(key))
                    data["dimensionsHierarchy"][key] = this.dimensionsHierarchy[key];
            }
        }
        return data; 
    }

    clone(): CreateOrUpdatePivotQueryDto {
        const json = this.toJSON();
        let result = new CreateOrUpdatePivotQueryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdatePivotQueryDto {
    formId: number;
    currentQueryId: number;
    formStructureRowId: number;
    mdxQueryWithParams: MdxQueryWithParamsDto;
    pivotConfig: PivotConfiguration;
    dimensionsHierarchy: { [key: string]: string[]; } | undefined;
}

export class QueryResultOutPutDto implements IQueryResultOutPutDto {
    name: string | undefined;
    value: any | undefined;

    constructor(data?: IQueryResultOutPutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): QueryResultOutPutDto {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOutPutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): QueryResultOutPutDto {
        const json = this.toJSON();
        let result = new QueryResultOutPutDto();
        result.init(json);
        return result;
    }
}

export interface IQueryResultOutPutDto {
    name: string | undefined;
    value: any | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class Int32EntityDto implements IInt32EntityDto {
    id: number;

    constructor(data?: IInt32EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int32EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int32EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): Int32EntityDto {
        const json = this.toJSON();
        let result = new Int32EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt32EntityDto {
    id: number;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        this.features[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    id: number;
}

export class Int64EntityDto implements IInt64EntityDto {
    id: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class CustomUserDtoList implements ICustomUserDtoList {
    userId: number;
    userName: string | undefined;

    constructor(data?: ICustomUserDtoList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CustomUserDtoList {
        data = typeof data === 'object' ? data : {};
        let result = new CustomUserDtoList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): CustomUserDtoList {
        const json = this.toJSON();
        let result = new CustomUserDtoList();
        result.init(json);
        return result;
    }
}

export interface ICustomUserDtoList {
    userId: number;
    userName: string | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;
}

export class UserFormDto implements IUserFormDto {
    userId: number;
    businessFormId: number;
    businessUnitId: number;
    businessUnitName: string | undefined;
    businessUnitSortName: string | undefined;
    id: number;

    constructor(data?: IUserFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.businessFormId = _data["businessFormId"];
            this.businessUnitId = _data["businessUnitId"];
            this.businessUnitName = _data["businessUnitName"];
            this.businessUnitSortName = _data["businessUnitSortName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["businessFormId"] = this.businessFormId;
        data["businessUnitId"] = this.businessUnitId;
        data["businessUnitName"] = this.businessUnitName;
        data["businessUnitSortName"] = this.businessUnitSortName;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserFormDto {
        const json = this.toJSON();
        let result = new UserFormDto();
        result.init(json);
        return result;
    }
}

export interface IUserFormDto {
    userId: number;
    businessFormId: number;
    businessUnitId: number;
    businessUnitName: string | undefined;
    businessUnitSortName: string | undefined;
    id: number;
}

export class UserBusinessFormsGroupDto implements IUserBusinessFormsGroupDto {
    userId: number;
    userName: string | undefined;
    userForms: UserFormDto[] | undefined;

    constructor(data?: IUserBusinessFormsGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            if (Array.isArray(_data["userForms"])) {
                this.userForms = [] as any;
                for (let item of _data["userForms"])
                    this.userForms.push(UserFormDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserBusinessFormsGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserBusinessFormsGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        if (Array.isArray(this.userForms)) {
            data["userForms"] = [];
            for (let item of this.userForms)
                data["userForms"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserBusinessFormsGroupDto {
        const json = this.toJSON();
        let result = new UserBusinessFormsGroupDto();
        result.init(json);
        return result;
    }
}

export interface IUserBusinessFormsGroupDto {
    userId: number;
    userName: string | undefined;
    userForms: UserFormDto[] | undefined;
}

export class FormUsersGroupDto implements IFormUsersGroupDto {
    formId: number;
    formName: string | undefined;
    users: UserBusinessFormsGroupDto[] | undefined;

    constructor(data?: IFormUsersGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.formName = _data["formName"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users.push(UserBusinessFormsGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormUsersGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormUsersGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["formName"] = this.formName;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FormUsersGroupDto {
        const json = this.toJSON();
        let result = new FormUsersGroupDto();
        result.init(json);
        return result;
    }
}

export interface IFormUsersGroupDto {
    formId: number;
    formName: string | undefined;
    users: UserBusinessFormsGroupDto[] | undefined;
}

export class FormUsersGroupDtoPagedResultDto implements IFormUsersGroupDtoPagedResultDto {
    totalCount: number;
    items: FormUsersGroupDto[] | undefined;

    constructor(data?: IFormUsersGroupDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(FormUsersGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormUsersGroupDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormUsersGroupDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FormUsersGroupDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FormUsersGroupDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFormUsersGroupDtoPagedResultDto {
    totalCount: number;
    items: FormUsersGroupDto[] | undefined;
}

export class UserFormListDto implements IUserFormListDto {
    id: number;

    constructor(data?: IUserFormListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserFormListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserFormListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): UserFormListDto {
        const json = this.toJSON();
        let result = new UserFormListDto();
        result.init(json);
        return result;
    }
}

export interface IUserFormListDto {
    id: number;
}

export class UserFormListDtoPagedResultDto implements IUserFormListDtoPagedResultDto {
    totalCount: number;
    items: UserFormListDto[] | undefined;

    constructor(data?: IUserFormListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserFormListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserFormListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserFormListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserFormListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserFormListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserFormListDtoPagedResultDto {
    totalCount: number;
    items: UserFormListDto[] | undefined;
}

export class UserFormsEditDto implements IUserFormsEditDto {
    formUserId: number;
    formId: number;
    businessFormList: number[] | undefined;
    prevUserForms: UserFormDto[] | undefined;

    constructor(data?: IUserFormsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formUserId = _data["formUserId"];
            this.formId = _data["formId"];
            if (Array.isArray(_data["businessFormList"])) {
                this.businessFormList = [] as any;
                for (let item of _data["businessFormList"])
                    this.businessFormList.push(item);
            }
            if (Array.isArray(_data["prevUserForms"])) {
                this.prevUserForms = [] as any;
                for (let item of _data["prevUserForms"])
                    this.prevUserForms.push(UserFormDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserFormsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserFormsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formUserId"] = this.formUserId;
        data["formId"] = this.formId;
        if (Array.isArray(this.businessFormList)) {
            data["businessFormList"] = [];
            for (let item of this.businessFormList)
                data["businessFormList"].push(item);
        }
        if (Array.isArray(this.prevUserForms)) {
            data["prevUserForms"] = [];
            for (let item of this.prevUserForms)
                data["prevUserForms"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserFormsEditDto {
        const json = this.toJSON();
        let result = new UserFormsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserFormsEditDto {
    formUserId: number;
    formId: number;
    businessFormList: number[] | undefined;
    prevUserForms: UserFormDto[] | undefined;
}

export class CreateOrUpdateUserFormDto implements ICreateOrUpdateUserFormDto {
    userForms: UserFormsEditDto;

    constructor(data?: ICreateOrUpdateUserFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userForms = _data["userForms"] ? UserFormsEditDto.fromJS(_data["userForms"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateUserFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userForms"] = this.userForms ? this.userForms.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateUserFormDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateUserFormDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateUserFormDto {
    userForms: UserFormsEditDto;
}

export class DeleteUserFormsDto implements IDeleteUserFormsDto {
    userId: number;
    formId: number;
    userFormsIds: number[] | undefined;

    constructor(data?: IDeleteUserFormsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.formId = _data["formId"];
            if (Array.isArray(_data["userFormsIds"])) {
                this.userFormsIds = [] as any;
                for (let item of _data["userFormsIds"])
                    this.userFormsIds.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteUserFormsDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteUserFormsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["formId"] = this.formId;
        if (Array.isArray(this.userFormsIds)) {
            data["userFormsIds"] = [];
            for (let item of this.userFormsIds)
                data["userFormsIds"].push(item);
        }
        return data; 
    }

    clone(): DeleteUserFormsDto {
        const json = this.toJSON();
        let result = new DeleteUserFormsDto();
        result.init(json);
        return result;
    }
}

export interface IDeleteUserFormsDto {
    userId: number;
    formId: number;
    userFormsIds: number[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}